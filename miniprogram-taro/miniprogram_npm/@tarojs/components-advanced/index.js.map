{"version":3,"sources":["index.js","components/index.js","components/virtual-list/index.js","components/virtual-list/vue/index.js","components/virtual-list/vue/list.js","utils/index.js","utils/convert.js","utils/dom.js","utils/helper.js","utils/lodash.js","utils/math.js","utils/timer.js","utils/vue-render.js","components/virtual-list/constants.js","components/virtual-list/dom-helpers.js","components/virtual-list/preset.js","components/virtual-list/list-set.js","components/virtual-list/utils.js","components/virtual-list/react/index.js","components/virtual-list/react/list.js","components/virtual-list/react/validate.js","components/virtual-list/react/wrapper.js","components/virtual-waterfall/index.js","components/virtual-waterfall/vue/index.js","components/virtual-waterfall/vue/waterfall.js","components/virtual-waterfall/constants.js","components/virtual-waterfall/preset.js","components/virtual-waterfall/list-map.js","components/virtual-waterfall/react/index.js","components/virtual-waterfall/react/waterfall.js","components/virtual-waterfall/react/wrapper.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;AELA,AFMA;AELA,AFMA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA;AHUA,AENA,ACHA,ACHA;AJaA,AENA,ACHA,ACHA;AJaA,AENA,ACHA,ACHA;AJaA,AENA,ACHA,ACHA,ACHA;ALgBA,AENA,ACHA,ACHA,ACHA;ALgBA,AENA,ACHA,ACHA,ACHA;ALgBA,AENA,ACHA,ACHA,ACHA,ACHA;ANmBA,AENA,ACHA,ACHA,ACHA,ACHA;ANmBA,AENA,ACHA,ACHA,ACHA,ACHA;ANmBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;APsBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;APsBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;APsBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;ARyBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;ARyBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;ACFA,AT2BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;ACFA,AT2BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;ACFA,AT2BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;ACFA,ACHA,AV8BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;ACFA,ACHA,AV8BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AELA,AV8BA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AELA,ACHA,AXiCA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AELA,ACHA,AXiCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,ACHA,AXiCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AXiCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AXiCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AXiCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AENA,AbuCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AENA,AbuCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AENA,AbuCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AGTA,ADGA,AbuCA,AGTA,ACHA,ACHA,AENA,ACHA;AELA,AENA,ADGA,AGTA,ADGA,AbuCA,AGTA,ACHA,ACHA,AENA;AGRA,AENA,ADGA,AGTA,ADGA,AbuCA,AGTA,ACHA,ACHA,AENA;AGRA,AENA,ADGA,AGTA,ACHA,AFMA,AbuCA,AGTA,ACHA,ACHA,AENA;AGRA,AENA,ADGA,AGTA,ACHA,AFMA,AbuCA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,AFMA,AbuCA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,AHSA,AbuCA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,AhBgDA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,AhBgDA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AGTA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,Af6CA,ACHA,ACHA;AKdA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,Ad0CA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,Ad0CA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,ACHA,Af6CA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,ACHA,Af6CA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,ACHA,Af6CA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AkBtDA,ACHA,ACHA,AhBgDA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AmBzDA,ACHA,AhBgDA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AmBzDA,ACHA,AhBgDA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AqB/DA,AFMA,ACHA,AhBgDA;AMjBA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AqB/DA,AFMA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AqB/DA,AFMA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AqB/DA,ACHA,AHSA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AqB/DA,ACHA,AHSA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AsBlEA,AHSA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AHSA,ACHA;AV+BA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AFMA;AV+BA,AENA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AFMA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,AJYA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,AJYA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,AJYA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ALeA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ALeA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ALeA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AENA,ACHA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,ACHA,ACHA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,AENA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,AENA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,AENA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,AENA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,AENA,AjBmDA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ACHA,ANkBA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ARyBA,ADGA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;AT4BA,AIZA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,ADGA,AGTA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AuBrEA,AENA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AyB3EA,ALeA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ALgBA,Af6CA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA,AoB5DA;ApB6DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./components/index.js');\nvar __TEMP__ = require('./utils/index.js');\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./components/virtual-list/index.js');Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualList; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./components/virtual-waterfall/index.js');Object.defineProperty(exports, 'VirtualWaterfall', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualWaterfall; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/convert.js');Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertPX2Int; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/dom.js');Object.defineProperty(exports, 'getRectSize', { enumerable: true, configurable: true, get: function() { return __TEMP__.getRectSize; } });Object.defineProperty(exports, 'getRectSizeSync', { enumerable: true, configurable: true, get: function() { return __TEMP__.getRectSizeSync; } });Object.defineProperty(exports, 'getScrollViewContextNode', { enumerable: true, configurable: true, get: function() { return __TEMP__.getScrollViewContextNode; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/helper.js');Object.defineProperty(exports, 'defaultItemKey', { enumerable: true, configurable: true, get: function() { return __TEMP__.defaultItemKey; } });Object.defineProperty(exports, 'getOffsetForIndexAndAlignment', { enumerable: true, configurable: true, get: function() { return __TEMP__.getOffsetForIndexAndAlignment; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/lodash.js');Object.defineProperty(exports, 'debounce', { enumerable: true, configurable: true, get: function() { return __TEMP__.debounce; } });Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return __TEMP__.omit; } });Object.defineProperty(exports, 'throttle', { enumerable: true, configurable: true, get: function() { return __TEMP__.throttle; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/math.js');Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return __TEMP__.getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return __TEMP__.isCosDistributing; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/timer.js');Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.requestTimeout; } });\n//# sourceMappingURL=index.js.map\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./virtual-list/index.js');Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualList; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./virtual-waterfall/index.js');Object.defineProperty(exports, 'VirtualWaterfall', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualWaterfall; } });\n//# sourceMappingURL=index.js.map\n","const VirtualList = (process.env.FRAMEWORK === 'vue' || process.env.FRAMEWORK === 'vue3')\n    ? require('./vue').default\n    : require('./react').default;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return VirtualList; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualList; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('./list.js');var List = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst VirtualList = List;\nfunction install(Vue) {\n    Vue.component('virtual-list', VirtualList);\n}\nvar index = {\n    install\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return VirtualList; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return index; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('@tarojs/shared');var isNumber = __TEMP__['isNumber'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('vue');var defineComponent = __TEMP__['defineComponent'];\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../../../utils/vue-render.js');var render = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../dom-helpers.js');var getRTLOffsetType = __TEMP__['getRTLOffsetType'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/dom.js');var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];var getRectSizeSync = __TEMP__['getRectSizeSync'];\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../../../utils/helper.js');var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\n\nvar List = defineComponent({\n    props: {\n        id: String,\n        height: {\n            type: [String, Number],\n            required: true\n        },\n        width: {\n            type: [String, Number],\n            required: true\n        },\n        item: {\n            required: true\n        },\n        itemCount: {\n            type: Number,\n            required: true\n        },\n        itemData: {\n            type: Array,\n            required: true\n        },\n        itemKey: Function,\n        itemSize: {\n            type: [Number, Function],\n            required: true\n        },\n        queryPrefix: {\n            type: String,\n            default: ''\n        },\n        unlimitedSize: {\n            type: Boolean,\n            default: false\n        },\n        position: {\n            type: String,\n            default: 'absolute'\n        },\n        direction: {\n            type: String,\n            default: 'ltr'\n        },\n        layout: {\n            type: String,\n            default: 'vertical'\n        },\n        initialScrollOffset: {\n            type: Number,\n            default: 0\n        },\n        overscanCount: {\n            type: Number,\n            default: 1\n        },\n        placeholderCount: {\n            type: Number\n        },\n        useIsScrolling: {\n            type: Boolean,\n            default: false\n        },\n        enhanced: {\n            type: Boolean,\n            default: false\n        },\n        shouldResetStyleCacheOnItemSizeChange: {\n            type: Boolean,\n            default: true\n        },\n        outerElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-scroll-view-core' : 'scroll-view'\n        },\n        innerElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-view-core' : 'view'\n        },\n        itemElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-view-core' : 'view'\n        },\n        outerTagName: String,\n        innerTagName: String,\n        itemTagName: String,\n        outerRef: String,\n        innerRef: String,\n        onScrollNative: Function,\n        onItemsRendered: Function,\n    },\n    data() {\n        const preset = new Preset(this.$props, this.refresh);\n        const id = this.$props.id || preset.id;\n        preset.updateWrapper(id);\n        return {\n            itemList: preset.itemList,\n            preset,\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.$props.initialScrollOffset === 'number'\n                ? this.$props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            resetIsScrollingTimeoutId: null,\n            refreshCount: 0\n        };\n    },\n    methods: {\n        refresh() {\n            this.refreshCount = this.refreshCount + 1;\n        },\n        scrollTo(scrollOffset = 0, enhanced = this.preset.enhanced) {\n            scrollOffset = Math.max(0, scrollOffset);\n            if (this.scrollOffset === scrollOffset)\n                return;\n            if (enhanced) {\n                const isHorizontal = this.preset.isHorizontal;\n                const option = {\n                    animated: true,\n                    duration: 300,\n                };\n                if (isHorizontal) {\n                    option.left = scrollOffset;\n                }\n                else {\n                    option.top = scrollOffset;\n                }\n                return getScrollViewContextNode(`${this.$props.queryPrefix}#${this.preset.id}`).then((node) => node.scrollTo(option));\n            }\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = true;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        scrollToItem(index, align = 'auto', enhanced = this.preset.enhanced) {\n            const { itemCount } = this.$props;\n            const { scrollOffset } = this.$data;\n            index = Math.max(0, Math.min(index, itemCount - 1));\n            this.scrollTo(this.itemList.getOffsetForIndexAndAlignment(index, align, scrollOffset), enhanced);\n        },\n        _callOnItemsRendered: memoizeOne(function (overscanStartIndex, overscanStopIndex, startIndex, stopIndex) {\n            return this.$props.onItemsRendered({\n                overscanStartIndex,\n                overscanStopIndex,\n                startIndex,\n                stopIndex\n            });\n        }),\n        _callOnScroll: memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) {\n            this.$emit('scroll', {\n                scrollDirection,\n                scrollOffset,\n                scrollUpdateWasRequested,\n                detail\n            });\n        }),\n        _callPropsCallbacks() {\n            if (typeof this.$props.onItemsRendered === 'function') {\n                if (this.$props.itemCount > 0) {\n                    const [overscanStartIndex, overscanStopIndex, startIndex, stopIndex] = this._getRangeToRender();\n                    this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, startIndex, stopIndex);\n                }\n            }\n            if (typeof this.$props.onScroll === 'function') {\n                this._callOnScroll(this.scrollDirection, this.scrollOffset, this.scrollUpdateWasRequested, this.preset.field);\n            }\n            if (this.itemList.isUnlimitedMode) {\n                setTimeout(() => {\n                    const [startIndex, stopIndex] = this._getRangeToRender();\n                    const isHorizontal = this.preset.isHorizontal;\n                    for (let index = startIndex; index <= stopIndex; index++) {\n                        this._getSizeUploadSync(index, isHorizontal);\n                    }\n                }, 0);\n            }\n        },\n        _getSizeUploadSync(index, isHorizontal) {\n            return new Promise((resolve) => {\n                if (index >= 0 && index < this.$props.itemCount) {\n                    const times = this.itemList.compareSize(index) ? 0 : 2;\n                    getRectSizeSync(`${this.$props.queryPrefix}#${this.preset.id}-${index}`, 100, times).then(({ width, height }) => {\n                        const size = isHorizontal ? width : height;\n                        if (typeof size === 'number' && size > 0 && !this.itemList.compareSize(index, size)) {\n                            this.itemList.setSize(index, size);\n                            resolve(this.itemList.getSize(index));\n                        }\n                    });\n                }\n            });\n        },\n        _getRangeToRender() {\n            return this.itemList.getRangeToRender(this.$data.scrollDirection, this.$data.scrollOffset, this.$data.isScrolling);\n        },\n        _onScrollHorizontal(event) {\n            const { scrollHeight, scrollWidth = this.itemList.getOffsetSizeCache(), scrollTop, scrollLeft, } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientWidth = this.itemList.wrapperSize;\n            this.preset.field = {\n                scrollHeight,\n                scrollWidth,\n                scrollTop,\n                scrollLeft,\n                clientHeight: scrollHeight,\n                clientWidth: scrollWidth\n            };\n            if (this.$props.onScrollNative) {\n                this.$props.onScrollNative(event);\n            }\n            const diffOffset = this.preset.field.scrollLeft - scrollLeft;\n            if (this.scrollOffset === scrollLeft || this.preset.isShaking(diffOffset)) {\n                return;\n            }\n            let scrollOffset = scrollLeft;\n            if (this.preset.isRtl) {\n                // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                switch (getRTLOffsetType()) {\n                    case 'negative':\n                        scrollOffset = -scrollLeft;\n                        break;\n                    case 'positive-descending':\n                        scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                        break;\n                }\n            }\n            // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n            scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n            this.preset.field = {\n                scrollWidth: scrollOffset,\n            };\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < scrollLeft ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = false;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        _onScrollVertical(event) {\n            const { scrollHeight = this.itemList.getOffsetSizeCache(), scrollWidth, scrollTop, scrollLeft, } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientHeight = this.itemList.wrapperSize;\n            if (this.$props.onScrollNative) {\n                this.$props.onScrollNative(event);\n            }\n            const diffOffset = this.preset.field.scrollTop - scrollTop;\n            if (this.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                return;\n            }\n            // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n            const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n            this.preset.field = {\n                scrollHeight,\n                scrollWidth,\n                scrollTop: scrollOffset,\n                scrollLeft,\n                clientHeight,\n                clientWidth: scrollWidth,\n                diffOffset: this.preset.field.scrollTop - scrollOffset,\n            };\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = false;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        _outerRefSetter(ref) {\n            const { outerRef } = this.$props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('value')) {\n                outerRef.value = ref;\n            }\n        },\n        _resetIsScrollingDebounced() {\n            if (this.resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this.resetIsScrollingTimeoutId);\n            }\n            this.resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        },\n        _resetIsScrolling() {\n            this.resetIsScrollingTimeoutId = null;\n            this.isScrolling = false;\n            this.$nextTick(() => {\n                this.preset.resetCache();\n            });\n        },\n        getRenderItemNode(index, type = 'node') {\n            const { item, itemData, itemKey = defaultItemKey, useIsScrolling } = this.$props;\n            const { isScrolling } = this.$data;\n            const key = itemKey(index, itemData);\n            const style = this.preset.getItemStyle(index);\n            if (type === 'placeholder') {\n                return render(this.preset.itemElement, {\n                    key,\n                    id: `${this.preset.id}-${index}-wrapper`,\n                    style: this.preset.isBrick ? style : { display: 'none' }\n                });\n            }\n            return render(this.preset.itemElement, {\n                key: itemKey(index, itemData),\n                id: `${this.preset.id}-${index}-wrapper`,\n                style\n            }, render(item, {\n                id: `${this.preset.id}-${index}`,\n                data: itemData,\n                index,\n                isScrolling: useIsScrolling ? isScrolling : undefined\n            }));\n        },\n        getRenderColumnNode() {\n            const { isScrolling } = this.$data;\n            const { innerRef, itemCount } = this.$props;\n            const isHorizontal = this.preset.isHorizontal;\n            // Read this value AFTER items have been created,\n            // So their actual sizes (if variable) are taken into consideration.\n            const estimatedTotalSize = convertNumber2PX(this.itemList.getOffsetSize());\n            const columnProps = {\n                ref: innerRef,\n                key: `${this.preset.id}-inner`,\n                id: `${this.preset.id}-inner`,\n                style: {\n                    height: isHorizontal ? '100%' : estimatedTotalSize,\n                    width: !isHorizontal ? '100%' : estimatedTotalSize,\n                    position: 'relative',\n                    pointerEvents: isScrolling ? 'none' : 'auto',\n                }\n            };\n            const [startIndex, stopIndex] = this._getRangeToRender();\n            const items = [];\n            if (this.preset.isRelative && !this.preset.isBrick) {\n                const pre = convertNumber2PX(this.itemList.getOffsetSizeCache(startIndex));\n                items.push(render(this.preset.itemElement, {\n                    key: `${this.preset.id}-pre`,\n                    id: `${this.preset.id}-pre`,\n                    style: {\n                        height: isHorizontal ? '100%' : pre,\n                        width: !isHorizontal ? '100%' : pre\n                    }\n                }));\n            }\n            const placeholderCount = this.preset.placeholderCount;\n            const restCount = itemCount - stopIndex;\n            const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n            const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n            for (let itemIndex = 0; itemIndex < stopIndex + postPlaceholder; itemIndex++) {\n                if (!this.preset.isBrick) {\n                    if (itemIndex < startIndex - prevPlaceholder) {\n                        itemIndex = startIndex - prevPlaceholder;\n                        continue;\n                    }\n                }\n                if (itemIndex < startIndex || itemIndex > stopIndex) {\n                    items.push(this.getRenderItemNode(itemIndex, 'placeholder'));\n                }\n                else {\n                    items.push(this.getRenderItemNode(itemIndex));\n                }\n            }\n            return render(this.preset.innerElement, columnProps, items);\n        },\n        getRenderExpandNodes(direction) {\n            const isHorizontal = this.preset.isHorizontal;\n            const isRtl = this.preset.isRtl;\n            const props = {\n                id: `${this.preset.id}-${direction}`,\n                style: {\n                    visibility: 'hidden',\n                    height: isHorizontal ? '100%' : 100,\n                    width: isHorizontal ? 100 : '100%',\n                    [isHorizontal ? isRtl ? 'marginRight' : 'marginLeft' : 'marginTop']: -100,\n                    zIndex: -1,\n                }\n            };\n            return render(this.preset.innerElement, props);\n        }\n    },\n    mounted() {\n        const { initialScrollOffset } = this.$props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                outerRef.scrollLeft = initialScrollOffset;\n            }\n            else {\n                outerRef.scrollTop = initialScrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n        this.preset.boundaryDetection();\n    },\n    updated() {\n        this.preset.update(this.$props);\n        const { scrollOffset, scrollUpdateWasRequested } = this.$data;\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // So we need to determine which browser behavior we're dealing with, and mimic it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            outerRef.scrollLeft = -scrollOffset;\n                            break;\n                        case 'positive-ascending':\n                            outerRef.scrollLeft = scrollOffset;\n                            break;\n                        default: {\n                            const { clientWidth, scrollWidth } = outerRef;\n                            outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    outerRef.scrollLeft = scrollOffset;\n                }\n            }\n            else {\n                outerRef.scrollTop = scrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n    },\n    beforeDestroy() {\n        if (this.resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this.resetIsScrollingTimeoutId);\n        }\n        this.preset.dispose();\n    },\n    render() {\n        var _a, _b, _c, _d;\n        const { direction, height, layout, width, enhanced = false } = omit(this.$props, [\n            'item', 'itemCount', 'itemData', 'itemKey', 'useIsScrolling',\n            'innerElementType', 'innerTagName', 'itemElementType', 'itemTagName',\n            'outerElementType', 'outerTagName', 'onScrollToLower', 'onScrollToUpper',\n            'upperThreshold', 'lowerThreshold',\n            'position', 'innerRef',\n        ]);\n        const { scrollOffset, scrollUpdateWasRequested } = this.$data;\n        const isHorizontal = this.preset.isHorizontal;\n        const isRtl = this.preset.isRtl;\n        const outerElementProps = {\n            id: this.preset.id,\n            ref: this._outerRefSetter,\n            layout,\n            enhanced,\n            style: {\n                position: 'relative',\n                height: convertNumber2PX(height),\n                width: convertNumber2PX(width),\n                overflow: 'auto',\n                WebkitOverflowScrolling: 'touch',\n                willChange: 'transform',\n                direction\n            },\n            attrs: {\n                scrollY: !this.preset.isHorizontal,\n                scrollX: this.preset.isHorizontal\n            },\n            on: {\n                scroll: isHorizontal\n                    ? this._onScrollHorizontal\n                    : this._onScrollVertical\n            }\n        };\n        if (!enhanced) {\n            if (isHorizontal) {\n                outerElementProps.scrollLeft = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollLeft;\n            }\n            else {\n                outerElementProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n            }\n        }\n        return render(this.preset.outerElement, outerElementProps, [\n            this.getRenderExpandNodes(isHorizontal ? isRtl ? 'right' : 'left' : 'top'),\n            process.env.FRAMEWORK === 'vue3' ? (_b = (_a = this.$slots).top) === null || _b === void 0 ? void 0 : _b.call(_a) : this.$slots.top,\n            this.getRenderColumnNode(),\n            process.env.FRAMEWORK === 'vue3' ? (_d = (_c = this.$slots).bottom) === null || _d === void 0 ? void 0 : _d.call(_c) : this.$slots.bottom,\n            this.getRenderExpandNodes(isHorizontal ? isRtl ? 'left' : 'right' : 'bottom'),\n        ]);\n    }\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return List; } });\n//# sourceMappingURL=list.js.map\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./convert.js');Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertPX2Int; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./dom.js');Object.defineProperty(exports, 'getRectSize', { enumerable: true, configurable: true, get: function() { return __TEMP__.getRectSize; } });Object.defineProperty(exports, 'getRectSizeSync', { enumerable: true, configurable: true, get: function() { return __TEMP__.getRectSizeSync; } });Object.defineProperty(exports, 'getScrollViewContextNode', { enumerable: true, configurable: true, get: function() { return __TEMP__.getScrollViewContextNode; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./helper.js');Object.defineProperty(exports, 'defaultItemKey', { enumerable: true, configurable: true, get: function() { return __TEMP__.defaultItemKey; } });Object.defineProperty(exports, 'getOffsetForIndexAndAlignment', { enumerable: true, configurable: true, get: function() { return __TEMP__.getOffsetForIndexAndAlignment; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./lodash.js');Object.defineProperty(exports, 'debounce', { enumerable: true, configurable: true, get: function() { return __TEMP__.debounce; } });Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return __TEMP__.omit; } });Object.defineProperty(exports, 'throttle', { enumerable: true, configurable: true, get: function() { return __TEMP__.throttle; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./math.js');Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return __TEMP__.getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return __TEMP__.isCosDistributing; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./timer.js');Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.requestTimeout; } });\n//# sourceMappingURL=index.js.map\n","/** 将距离值根据单位转换为 Number 类型\n * TODO: 未来可以考虑支持更多单位\n */\nfunction convertPX2Int(distance) {\n    if (typeof distance === 'string') {\n        const str = distance.toLowerCase();\n        if (/px$/.test(str)) {\n            return Number(str.replace(/px$/, ''));\n        }\n    }\n    return distance;\n}\nfunction convertNumber2PX(styleValue) {\n    if (!styleValue && styleValue !== 0)\n        return '';\n    return typeof styleValue === 'number' ? styleValue + 'px' : styleValue;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return convertPX2Int; } });\n//# sourceMappingURL=convert.js.map\n","var __TEMP__ = require('@tarojs/taro');var createSelectorQuery = __TEMP__['createSelectorQuery'];\n\nfunction getRectSize(id, success, fail, retryMs = 500) {\n    const query = createSelectorQuery();\n    try {\n        query.select(id).boundingClientRect((res) => {\n            if (res) {\n                success === null || success === void 0 ? void 0 : success(res);\n            }\n            else {\n                fail === null || fail === void 0 ? void 0 : fail();\n            }\n        }).exec();\n    }\n    catch (err) {\n        setTimeout(() => {\n            getRectSize(id, success, fail, retryMs);\n        }, retryMs);\n    }\n}\nfunction getRectSizeSync(id, retryMs = 500, retryTimes = 5) {\n    return new Promise((resolve) => {\n        function retry() {\n            if (retryTimes <= 0)\n                return;\n            setTimeout(async () => {\n                try {\n                    const res = await getRectSizeSync(id, retryMs, --retryTimes);\n                    resolve(res);\n                }\n                catch (err) {\n                    retry();\n                }\n            }, retryMs);\n        }\n        getRectSize(id, resolve, retry, retryMs);\n    });\n}\nasync function getScrollViewContextNode(id) {\n    const query = createSelectorQuery();\n    return new Promise((resolve) => query.select(id).node(({ node }) => resolve(node)).exec());\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'getRectSize', { enumerable: true, configurable: true, get: function() { return getRectSize; } });Object.defineProperty(exports, 'getRectSizeSync', { enumerable: true, configurable: true, get: function() { return getRectSizeSync; } });Object.defineProperty(exports, 'getScrollViewContextNode', { enumerable: true, configurable: true, get: function() { return getScrollViewContextNode; } });\n//# sourceMappingURL=dom.js.map\n","// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nconst defaultItemKey = (index, _itemData) => index;\nfunction getOffsetForIndexAndAlignment({ align = 'auto', containerSize = 0, currentOffset = 0, scrollSize = 0, slideSize = 0, targetOffset = 0, }) {\n    const lastItemOffset = Math.max(0, scrollSize - containerSize);\n    const maxOffset = Math.min(lastItemOffset, targetOffset);\n    const minOffset = Math.max(0, targetOffset - containerSize + slideSize);\n    if (align === 'smart') {\n        if (currentOffset >= minOffset - containerSize && currentOffset <= maxOffset + containerSize) {\n            align = 'auto';\n        }\n        else {\n            align = 'center';\n        }\n    }\n    switch (align) {\n        case 'start':\n            return maxOffset;\n        case 'end':\n            return minOffset;\n        case 'center':\n            {\n                // \"Centered\" offset is usually the average of the min and max.\n                // But near the edges of the list, this doesn't hold true.\n                const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                if (middleOffset < Math.ceil(containerSize / 2)) {\n                    return 0; // near the beginning\n                }\n                else if (middleOffset > lastItemOffset + Math.floor(containerSize / 2)) {\n                    return lastItemOffset; // near the end\n                }\n                else {\n                    return middleOffset;\n                }\n            }\n        case 'auto':\n        default:\n            if (currentOffset >= minOffset && currentOffset <= maxOffset) {\n                return currentOffset;\n            }\n            else if (currentOffset < minOffset) {\n                return minOffset;\n            }\n            else {\n                return maxOffset;\n            }\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'defaultItemKey', { enumerable: true, configurable: true, get: function() { return defaultItemKey; } });Object.defineProperty(exports, 'getOffsetForIndexAndAlignment', { enumerable: true, configurable: true, get: function() { return getOffsetForIndexAndAlignment; } });\n//# sourceMappingURL=helper.js.map\n","function omit(obj = {}, fields = []) {\n    const shallow = Object.assign({}, obj);\n    fields.forEach((key) => {\n        delete shallow[key];\n    });\n    return shallow;\n}\nfunction throttle(fn, threshold = 250, scope) {\n    let lastTime = 0;\n    let deferTimer;\n    return function (...args) {\n        const context = scope || this;\n        const now = Date.now();\n        if (now - lastTime > threshold) {\n            fn.apply(this, args);\n            lastTime = now;\n        }\n        else {\n            clearTimeout(deferTimer);\n            deferTimer = setTimeout(() => {\n                lastTime = now;\n                fn.apply(context, args);\n            }, threshold);\n        }\n    };\n}\nfunction debounce(fn, ms = 250, scope) {\n    let timer;\n    return function (...args) {\n        const context = scope || this;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            fn.apply(context, args);\n        }, ms);\n    };\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'debounce', { enumerable: true, configurable: true, get: function() { return debounce; } });Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return omit; } });Object.defineProperty(exports, 'throttle', { enumerable: true, configurable: true, get: function() { return throttle; } });\n//# sourceMappingURL=lodash.js.map\n","function getMiddleNumber(...list) {\n    return list.sort((a, b) => a - b)[Math.floor(list.length / 2)];\n}\nfunction isCosDistributing(list, datum = 0) {\n    let flags = 0;\n    for (let i = 0; i < list.length - 1; i++) {\n        if (getMiddleNumber(list[i], datum, list[i + 1]) === datum) {\n            flags++;\n        }\n    }\n    return flags === list.length - 1;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return isCosDistributing; } });\n//# sourceMappingURL=math.js.map\n","var __TEMP__ = require('@tarojs/runtime');var cancelAnimationFrame = __TEMP__['cancelAnimationFrame'];var now = __TEMP__['now'];var requestAnimationFrame = __TEMP__['requestAnimationFrame'];\n\nfunction cancelTimeout(timeoutID) {\n    cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay = 0) {\n    const start = now();\n    const timeoutID = {\n        id: requestAnimationFrame(tick)\n    };\n    function tick() {\n        if (now() - start >= delay) {\n            // eslint-disable-next-line no-useless-call\n            callback.call(null);\n        }\n        else {\n            timeoutID.id = requestAnimationFrame(tick);\n        }\n    }\n    return timeoutID;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return requestTimeout; } });\n//# sourceMappingURL=timer.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('vue');var h = __TEMP__['h'];\n\nfunction render (componentName, options, children) {\n    const { attrs = {}, on = {}, props = {}, slots = {} } = options, el = __rest(options, [\"attrs\", \"on\", \"props\", \"slots\"]);\n    if (process.env.FRAMEWORK === 'vue3') {\n        // Events\n        Object.keys(on).forEach(key => {\n            const name = `on${key.charAt(0).toUpperCase()}${key.slice(1)}`;\n            el[name] = on[key];\n        });\n        return h(componentName, Object.assign(Object.assign(Object.assign(Object.assign({}, attrs), props), slots), el), children);\n    }\n    return h(componentName, options, children);\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return render; } });\n//# sourceMappingURL=vue-render.js.map\n","const IS_SCROLLING_DEBOUNCE_INTERVAL = 200;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'IS_SCROLLING_DEBOUNCE_INTERVAL', { enumerable: true, configurable: true, get: function() { return IS_SCROLLING_DEBOUNCE_INTERVAL; } });\n//# sourceMappingURL=constants.js.map\n","// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n    if (cachedRTLResult === null || recalculate) {\n        const outerDiv = document.createElement('div');\n        const outerStyle = outerDiv.style;\n        outerStyle.width = '50px';\n        outerStyle.height = '50px';\n        outerStyle.overflow = 'scroll';\n        outerStyle.direction = 'rtl';\n        const innerDiv = document.createElement('div');\n        const innerStyle = innerDiv.style;\n        innerStyle.width = '100px';\n        innerStyle.height = '100px';\n        outerDiv.appendChild(innerDiv);\n        document.body.appendChild(outerDiv);\n        if (outerDiv.scrollLeft > 0) {\n            cachedRTLResult = 'positive-descending';\n        }\n        else {\n            outerDiv.scrollLeft = 1;\n            if (outerDiv.scrollLeft === 0) {\n                cachedRTLResult = 'negative';\n            }\n            else {\n                cachedRTLResult = 'positive-ascending';\n            }\n        }\n        document.body.removeChild(outerDiv);\n        return cachedRTLResult;\n    }\n    return cachedRTLResult;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'getRTLOffsetType', { enumerable: true, configurable: true, get: function() { return getRTLOffsetType; } });\n//# sourceMappingURL=dom-helpers.js.map\n","var __TEMP__ = require('@tarojs/taro');var createSelectorQuery = __TEMP__['createSelectorQuery'];var getCurrentInstance = __TEMP__['getCurrentInstance'];var createIntersectionObserver = __TEMP__['createIntersectionObserver'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/index.js');\nvar __TEMP__ = require('./list-set.js');var ListSet = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./utils.js');var isHorizontalFunc = __TEMP__['isHorizontalFunc'];var isRtlFunc = __TEMP__['isRtlFunc'];\nvar __TEMP__ = require('../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../utils/dom.js');var getRectSizeSync = __TEMP__['getRectSizeSync'];\nvar __TEMP__ = require('../../utils/math.js');var isCosDistributing = __TEMP__['isCosDistributing'];\nvar __TEMP__ = require('../../utils/lodash.js');var throttle = __TEMP__['throttle'];\n\nlet INSTANCE_ID = 0;\nclass Preset {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this._observer = {};\n        this.wrapperField = {\n            scrollLeft: 0,\n            scrollTop: 0,\n            scrollHeight: 0,\n            scrollWidth: 0,\n            clientHeight: 0,\n            clientWidth: 0,\n            diffOffset: 0\n        };\n        this.diffList = [0, 0, 0];\n        this.getItemStyleCache = memoizeOne((itemIndex, itemSize, _flag = this.itemList.refreshCounter) => {\n            itemSize = itemSize || this.itemList.getSize(itemIndex);\n            const style = this.isRelative ? {} : {\n                position: 'absolute',\n            };\n            const offset = convertNumber2PX(this.itemList.getOffsetSizeCache(itemIndex));\n            const size = convertNumber2PX(this.itemList.getSize(itemIndex));\n            const isHorizontal = this.isHorizontal;\n            const isRtl = this.isRtl;\n            style.height = !isHorizontal ? size : '100%';\n            style.width = isHorizontal ? size : '100%';\n            if (!this.isRelative) {\n                const offsetHorizontal = isHorizontal ? offset : 0;\n                style.top = !isHorizontal ? offset : 0;\n                if (isRtl) {\n                    style.right = offsetHorizontal;\n                }\n                else {\n                    style.left = offsetHorizontal;\n                }\n            }\n            return style;\n        });\n        this.init(this.props);\n        this.itemList = new ListSet(props, refresh);\n    }\n    init(props) {\n        this.props = props;\n    }\n    update(props) {\n        this.props = props;\n        this.itemList.update(props);\n    }\n    async updateWrapper(id) {\n        var _a;\n        var _b, _c;\n        this.id = id;\n        const { width = 0, height = 0 } = this.props;\n        const validWidth = typeof width === 'number' && width > 0;\n        const validHeight = typeof height === 'number' && height > 0;\n        if (validWidth) {\n            this.itemList.wrapperWidth = width;\n        }\n        if (validHeight) {\n            this.itemList.wrapperHeight = height;\n        }\n        if (!validHeight || !validWidth) {\n            const res = await getRectSizeSync(`#${id}`, 100);\n            (_b = this.itemList).wrapperWidth || (_b.wrapperWidth = res.width);\n            (_c = this.itemList).wrapperHeight || (_c.wrapperHeight = res.height);\n            (_a = this.refresh) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        this.itemList.update(this.props);\n    }\n    set id(id) {\n        this._id = id;\n    }\n    get id() {\n        this._id || (this._id = `virtual-waterfall-${INSTANCE_ID++}`);\n        return this._id;\n    }\n    get isHorizontal() {\n        return isHorizontalFunc(this.props);\n    }\n    get isRtl() {\n        return isRtlFunc(this.props);\n    }\n    get isRelative() {\n        return this.props.position && this.props.position !== 'absolute';\n    }\n    get isBrick() {\n        return this.props.position === 'brick';\n    }\n    get placeholderCount() {\n        return this.props.placeholderCount >= 0 ? this.props.placeholderCount : this.props.overscanCount;\n    }\n    get outerElement() {\n        return this.props.outerElementType || this.props.outerTagName || 'div';\n    }\n    get innerElement() {\n        return this.props.innerElementType || this.props.innerTagName || 'div';\n    }\n    get itemElement() {\n        return this.props.itemElementType || this.props.itemTagName || 'div';\n    }\n    get field() {\n        return this.wrapperField;\n    }\n    set field(o) {\n        Object.assign(this.wrapperField, o);\n        // Object.keys(o).forEach(key => {\n        //   if (typeof o[key] === 'number' && typeof this.wrapperField[key] === 'number') {\n        //     this.wrapperField[key] = o[key]\n        //   }\n        // })\n    }\n    get enhanced() {\n        return this.props.enhanced || true;\n    }\n    isShaking(diff) {\n        if (process.env.TARO_PLATFORM === 'web' || this.props.enhanced)\n            return false;\n        const list = this.diffList.slice(-3);\n        this.diffList.push(diff);\n        return list.findIndex(e => Math.abs(e) === Math.abs(diff)) !== -1 || isCosDistributing(this.diffList.slice(-4));\n    }\n    resetCache() {\n        this.itemList.refreshCounter++;\n    }\n    getItemStyle(index) {\n        const { shouldResetStyleCacheOnItemSizeChange } = this.props;\n        return this.getItemStyleCache(index, shouldResetStyleCacheOnItemSizeChange ? this.itemList.getSize(index) : false);\n    }\n    boundaryDetection() {\n        if ([typeof this.props.onScrollToUpper, typeof this.props.onScrollToLower].every(e => e !== 'function'))\n            return;\n        createSelectorQuery().select(`#${this.id}`).node().exec(() => {\n            const upperObserver = this.boundaryDetectionHelper({\n                event: typeof this.props.onScrollToUpper === 'function' ? () => {\n                    if (this.field.diffOffset >= 0)\n                        this.props.onScrollToUpper();\n                } : undefined,\n                id: `${this.id}-${this.isHorizontal ? this.isRtl ? 'right' : 'left' : 'top'}`,\n            });\n            if (upperObserver) {\n                this._observer.top = upperObserver;\n            }\n            const lowerObserver = this.boundaryDetectionHelper({\n                event: typeof this.props.onScrollToLower === 'function' ? () => {\n                    if (this.field.diffOffset <= 0)\n                        this.props.onScrollToLower();\n                } : undefined,\n                id: `${this.id}-${this.isHorizontal ? this.isRtl ? 'left' : 'right' : 'bottom'}`,\n            });\n            if (lowerObserver) {\n                this._observer.bottom = lowerObserver;\n            }\n        });\n    }\n    boundaryDetectionHelper({ component, event, id, }) {\n        if (typeof event !== 'function')\n            return;\n        const eventFunc = throttle(event);\n        component || (component = getCurrentInstance().page);\n        const observer = createIntersectionObserver(component, {\n            thresholds: [0.4],\n        });\n        observer\n            .relativeTo(`#${this.id}`, {\n            top: typeof this.props.lowerThreshold === 'number' ? this.props.lowerThreshold : 50,\n            bottom: typeof this.props.upperThreshold === 'number' ? this.props.upperThreshold : 50,\n        })\n            .observe(`#${id}`, eventFunc);\n        return observer;\n    }\n    dispose() {\n        Object.values(this._observer).forEach(e => { var _a; return (_a = e.disconnect) === null || _a === void 0 ? void 0 : _a.call(e); });\n        this._observer = {};\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return Preset; } });\n//# sourceMappingURL=preset.js.map\n","var __TEMP__ = require('@tarojs/shared');var isFunction = __TEMP__['isFunction'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/index.js');\nvar __TEMP__ = require('./utils.js');var isHorizontalFunc = __TEMP__['isHorizontalFunc'];\nvar __TEMP__ = require('../../utils/helper.js');var getOffsetForIndexAndAlignment = __TEMP__['getOffsetForIndexAndAlignment'];\n\nclass ListSet {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this.list = [];\n        this.defaultSize = 1;\n        this.wrapperHeight = 0;\n        this.wrapperWidth = 0;\n        this.refreshCounter = 0;\n        this.getOffsetSizeCache = memoizeOne((i = this.list.length, _flag = this.refreshCounter) => {\n            return this.getOffsetSize(i);\n        });\n        this.update(props);\n        // Note: 不考虑列表模式切换情况，可能会导致列表抖动体验过差\n        if (this.props.unlimitedSize) {\n            this.mode = 'unlimited';\n        }\n        else if (isFunction(this.props.itemSize)) {\n            this.mode = 'function';\n        }\n        else {\n            this.mode = 'normal';\n        }\n        this.defaultSize = (isFunction(this.props.itemSize) ? this.props.itemSize() : this.props.itemSize) || 1;\n        if (!this.isNormalMode) {\n            this.list = new Array(this.length).fill(-1);\n        }\n    }\n    get isNormalMode() {\n        return this.mode === 'normal';\n    }\n    get isFunctionMode() {\n        return this.mode === 'function';\n    }\n    get isUnlimitedMode() {\n        return this.mode === 'unlimited';\n    }\n    get length() {\n        return this.props.itemCount || 100;\n    }\n    get overscan() {\n        return this.props.overscanCount || 0;\n    }\n    get wrapperSize() {\n        return isHorizontalFunc(this.props) ? this.wrapperWidth : this.wrapperHeight;\n    }\n    update(props) {\n        this.props = props;\n        if (this.length > this.list.length) {\n            const arr = new Array(this.length - this.list.length).fill(-1);\n            this.list.push(...arr);\n        }\n        else if (this.length < this.list.length) {\n            this.list.length = this.length;\n        }\n    }\n    setSize(i = 0, size = this.defaultSize) {\n        var _a;\n        this.list[i] = size;\n        (_a = this.refresh) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.refreshCounter++;\n    }\n    getSize(i = 0) {\n        const size = this.props.itemSize;\n        const item = this.list[i];\n        if (item >= 0)\n            return item;\n        if (this.isFunctionMode && isFunction(size)) {\n            const itemSize = size(i, this.props.itemData);\n            this.setSize(i, itemSize);\n            return itemSize;\n        }\n        return this.defaultSize;\n    }\n    getOffsetSize(i = this.list.length) {\n        if (this.isNormalMode)\n            return i * this.defaultSize;\n        return this.list.slice(0, i).reduce((sum, _, idx) => sum + this.getSize(idx), 0);\n    }\n    getSizeCount(offset = 0) {\n        if (offset === 0)\n            return 0;\n        // if (this.isNormalMode) {\n        //   return Math.min(this.length - 1, Math.floor(offset / this.length))\n        // }\n        let offsetSize = 0;\n        const count = this.list.reduce((sum, _, idx) => {\n            if (offsetSize < offset) {\n                offsetSize += this.getSize(idx);\n                return ++sum;\n            }\n            return sum;\n        }, 0);\n        return count - 1;\n    }\n    getStartIndex(scrollOffset = 0) {\n        return Math.max(0, this.getSizeCount(scrollOffset) - 1);\n    }\n    getStopIndex(wrapperSize = 0, scrollOffset = 0, startIndex = 0) {\n        // const visibleOffset = this.getOffsetSizeCache(startIndex)\n        // if (this.isNormalMode) {\n        //   const numVisibleItems = Math.ceil((wrapperSize + scrollOffset - visibleOffset) / this.length)\n        //   /** -1 is because stop index is inclusive */\n        //   return Math.max(startIndex, Math.min(this.length - 1, startIndex + numVisibleItems - 1))\n        // }\n        return Math.max(startIndex, Math.min(this.length - 1, this.getSizeCount(wrapperSize + scrollOffset)));\n    }\n    getRangeToRender(direction, scrollOffset = 0, block = false) {\n        if (this.length === 0) {\n            return [0, 0, 0, 0];\n        }\n        const startIndex = this.getStartIndex(scrollOffset);\n        const stopIndex = this.getStopIndex(this.wrapperSize, scrollOffset, startIndex);\n        // Overscan by one item in each direction so that tab/focus works. If there isn't at least one extra item, tab loops back around.\n        const overscanBackward = !block || direction === 'backward' ? Math.max(1, this.overscan) : 1;\n        const overscanForward = !block || direction === 'forward' ? Math.max(1, this.overscan) : 1;\n        return [\n            Math.max(0, startIndex - overscanBackward),\n            Math.max(0, Math.min(this.length - 1, stopIndex + overscanForward)),\n            startIndex,\n            stopIndex\n        ];\n    }\n    getOffsetForIndexAndAlignment(index, align, scrollOffset) {\n        return getOffsetForIndexAndAlignment({\n            align,\n            containerSize: this.wrapperSize,\n            currentOffset: scrollOffset,\n            scrollSize: this.getOffsetSizeCache(this.length),\n            slideSize: this.getSize(index),\n            targetOffset: this.getOffsetSizeCache(index),\n        });\n    }\n    compareSize(i = 0, size = this.defaultSize) {\n        if (this.isNormalMode)\n            return true;\n        return this.getSize(i) === size;\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return ListSet; } });\n//# sourceMappingURL=list-set.js.map\n","function isHorizontalFunc({ direction, layout }) {\n    return direction === 'horizontal' || layout === 'horizontal';\n}\nfunction isRtlFunc({ direction }) {\n    return direction === 'rtl';\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'isHorizontalFunc', { enumerable: true, configurable: true, get: function() { return isHorizontalFunc; } });Object.defineProperty(exports, 'isRtlFunc', { enumerable: true, configurable: true, get: function() { return isRtlFunc; } });\n//# sourceMappingURL=utils.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('@tarojs/components');var ScrollView = __TEMP__['ScrollView'];var View = __TEMP__['View'];\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./list.js');var List = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./wrapper.js');var outerWrapper = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst VirtualList = React.forwardRef(function VirtualList(props, ref) {\n    const _a = props, { direction = 'ltr', outerElementType = ScrollView, innerElementType = View, itemElementType = View, initialScrollOffset = 0, overscanCount = 1, queryPrefix = '' } = _a, rest = __rest(_a, [\"direction\", \"outerElementType\", \"innerElementType\", \"itemElementType\", \"initialScrollOffset\", \"overscanCount\", \"queryPrefix\"]);\n    if ('children' in rest) {\n        console.warn('Taro(VirtualList): children props have been deprecated. ' + 'Please use the item props instead.');\n        rest.item = rest.children;\n    }\n    if (rest.item instanceof Array) {\n        console.warn('Taro(VirtualList): item should not be an array');\n        rest.item = rest.item[0];\n    }\n    return React.createElement(List, Object.assign(Object.assign({ ref }, rest), { outerElementType,\n        itemElementType,\n        innerElementType,\n        direction,\n        initialScrollOffset,\n        overscanCount,\n        queryPrefix,\n        outerWrapper }));\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualList; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('@tarojs/shared');var isNumber = __TEMP__['isNumber'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../dom-helpers.js');var getRTLOffsetType = __TEMP__['getRTLOffsetType'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./validate.js');var validateListProps = __TEMP__['validateListProps'];\nvar __TEMP__ = require('../../../utils/dom.js');var getRectSizeSync = __TEMP__['getRectSizeSync'];var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../../../utils/helper.js');var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\n\nclass List extends React.PureComponent {\n    static getDerivedStateFromProps(nextProps, prevState) {\n        return validateListProps(nextProps, prevState);\n    }\n    constructor(props) {\n        super(props);\n        this.refresh = () => {\n            if (process.env.FRAMEWORK === 'preact') {\n                this.forceUpdate();\n            }\n            else {\n                this.setState(({ refreshCount }) => ({\n                    refreshCount: ++refreshCount\n                }));\n            }\n        };\n        this._outerRef = undefined;\n        this._resetIsScrollingTimeoutId = null;\n        this._callOnItemsRendered = memoizeOne((overscanStartIndex, overscanStopIndex, startIndex, stopIndex) => this.props.onItemsRendered({\n            overscanStartIndex,\n            overscanStopIndex,\n            startIndex,\n            stopIndex\n        }));\n        this._callOnScroll = memoizeOne((scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) => this.props.onScroll({\n            scrollDirection,\n            scrollOffset,\n            scrollUpdateWasRequested,\n            detail\n        }));\n        this._getSizeUploadSync = (index, isHorizontal) => {\n            return new Promise((resolve) => {\n                if (index >= 0 && index < this.props.itemCount) {\n                    const times = this.itemList.compareSize(index) ? 3 : 0;\n                    getRectSizeSync(`${this.props.queryPrefix}#${this.preset.id}-${index}`, 100, times).then(({ width, height }) => {\n                        const size = isHorizontal ? width : height;\n                        if (typeof size === 'number' && size > 0 && !this.itemList.compareSize(index, size)) {\n                            this.itemList.setSize(index, size);\n                            resolve(this.itemList.getSize(index));\n                        }\n                    });\n                }\n            });\n        };\n        this._onScrollHorizontal = event => {\n            const { scrollHeight, scrollWidth = this.itemList.getOffsetSizeCache(), scrollTop, scrollLeft, } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientWidth = this.itemList.wrapperSize;\n            this.preset.field = {\n                scrollHeight,\n                scrollWidth,\n                scrollTop,\n                scrollLeft,\n                clientHeight: scrollHeight,\n                clientWidth: scrollWidth\n            };\n            this.setState((prevState) => {\n                const diffOffset = this.preset.field.scrollLeft - scrollLeft;\n                if (prevState.scrollOffset === scrollLeft || this.preset.isShaking(diffOffset)) {\n                    // Scroll position may have been updated by cDM/cDU,\n                    // In which case we don't need to trigger another render,\n                    // And we don't want to update state.isScrolling.\n                    return null;\n                }\n                let scrollOffset = scrollLeft;\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                    // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            scrollOffset = -scrollLeft;\n                            break;\n                        case 'positive-descending':\n                            scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                            break;\n                    }\n                } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                this.preset.field = {\n                    scrollWidth: scrollOffset,\n                };\n                return {\n                    isScrolling: true,\n                    scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n                    scrollOffset,\n                    scrollUpdateWasRequested: false\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        this._onScrollVertical = event => {\n            const { scrollHeight = this.itemList.getOffsetSizeCache(), scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientHeight = this.itemList.wrapperSize;\n            this.setState((prevState) => {\n                const diffOffset = this.preset.field.scrollTop - scrollTop;\n                if (prevState.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                    // Scroll position may have been updated by cDM/cDU,\n                    // In which case we don't need to trigger another render,\n                    // And we don't want to update state.isScrolling.\n                    return null;\n                }\n                // FIXME preact 中使用时，该组件会出现触底滚动事件重复触发导致的抖动问题，后续修复\n                // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                this.preset.field = {\n                    scrollHeight,\n                    scrollWidth,\n                    scrollTop: scrollOffset,\n                    scrollLeft,\n                    clientHeight,\n                    clientWidth: scrollWidth,\n                    diffOffset: this.preset.field.scrollTop - scrollOffset,\n                };\n                return {\n                    isScrolling: true,\n                    scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                    scrollOffset,\n                    scrollUpdateWasRequested: false\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        this._outerRefSetter = ref => {\n            const { outerRef } = this.props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n                // @ts-ignore\n                outerRef.current = ref;\n            }\n        };\n        this._resetIsScrollingDebounced = () => {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n            this._resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        };\n        this._resetIsScrolling = () => {\n            this._resetIsScrollingTimeoutId = null;\n            this.setState({\n                isScrolling: false\n            }, () => {\n                // Clear style cache after state update has been committed.\n                // This way we don't break pure sCU for items that don't use isScrolling param.\n                this.preset.resetCache();\n            });\n        };\n        this.preset = new Preset(props, this.refresh);\n        this.itemList = this.preset.itemList;\n        const id = this.props.id || this.preset.id;\n        this.preset.updateWrapper(id);\n        this.state = {\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.props.initialScrollOffset === 'number'\n                ? this.props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            refreshCount: 0,\n        };\n    }\n    _callPropsCallbacks(prevProps = {}, prevState = {}) {\n        if (typeof this.props.onItemsRendered === 'function') {\n            if (this.props.itemCount > 0) {\n                if (prevProps && prevProps.itemCount !== this.props.itemCount) {\n                    const [overscanStartIndex, overscanStopIndex, startIndex, stopIndex] = this._getRangeToRender();\n                    this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, startIndex, stopIndex);\n                }\n            }\n        }\n        if (typeof this.props.onScroll === 'function') {\n            if (!prevState ||\n                prevState.scrollDirection !== this.state.scrollDirection ||\n                prevState.scrollOffset !== this.state.scrollOffset ||\n                prevState.scrollUpdateWasRequested !== this.state.scrollUpdateWasRequested) {\n                this._callOnScroll(this.state.scrollDirection, this.state.scrollOffset, this.state.scrollUpdateWasRequested, this.preset.field);\n            }\n        }\n        if (this.itemList.isUnlimitedMode) {\n            setTimeout(() => {\n                const [startIndex, stopIndex] = this._getRangeToRender();\n                const isHorizontal = this.preset.isHorizontal;\n                for (let index = startIndex; index <= stopIndex; index++) {\n                    this._getSizeUploadSync(index, isHorizontal);\n                }\n            }, 0);\n        }\n    }\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getRangeToRender() {\n        return this.itemList.getRangeToRender(this.state.scrollDirection, this.state.scrollOffset, this.state.isScrolling);\n    }\n    scrollTo(scrollOffset = 0, enhanced = this.preset.enhanced) {\n        scrollOffset = Math.max(0, scrollOffset);\n        if (this.state.scrollOffset === scrollOffset)\n            return;\n        if (enhanced) {\n            const isHorizontal = this.preset.isHorizontal;\n            const option = {\n                animated: true,\n                duration: 300,\n            };\n            if (isHorizontal) {\n                option.left = scrollOffset;\n            }\n            else {\n                option.top = scrollOffset;\n            }\n            return getScrollViewContextNode(`${this.props.queryPrefix}#${this.preset.id}`).then((node) => node.scrollTo(option));\n        }\n        this.setState((prevState) => {\n            if (prevState.scrollOffset === scrollOffset) {\n                return null;\n            }\n            return {\n                scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                scrollOffset,\n                scrollUpdateWasRequested: true\n            };\n        }, this._resetIsScrollingDebounced);\n    }\n    scrollToItem(index, align = 'auto', enhanced = this.preset.enhanced) {\n        const { itemCount } = this.props;\n        const { scrollOffset } = this.state;\n        index = Math.max(0, Math.min(index, itemCount - 1));\n        this.scrollTo(this.itemList.getOffsetForIndexAndAlignment(index, align, scrollOffset), enhanced);\n    }\n    componentDidMount() {\n        const { initialScrollOffset } = this.props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                outerRef.scrollLeft = initialScrollOffset;\n            }\n            else {\n                outerRef.scrollTop = initialScrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n        this.preset.boundaryDetection();\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { scrollOffset, scrollUpdateWasRequested } = this.state;\n        this.preset.update(this.props);\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // So we need to determine which browser behavior we're dealing with, and mimic it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            outerRef.scrollLeft = -scrollOffset;\n                            break;\n                        case 'positive-ascending':\n                            outerRef.scrollLeft = scrollOffset;\n                            break;\n                        default:\n                            outerRef.scrollLeft = outerRef.scrollWidth - outerRef.clientWidth - scrollOffset;\n                            break;\n                    }\n                }\n                else {\n                    outerRef.scrollLeft = scrollOffset;\n                }\n            }\n            else {\n                outerRef.scrollTop = scrollOffset;\n            }\n        }\n        this._callPropsCallbacks(prevProps, prevState);\n    }\n    componentWillUnmount() {\n        if (this._resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this._resetIsScrollingTimeoutId);\n        }\n        this.preset.dispose();\n    }\n    getRenderItemNode(index, type = 'node') {\n        const { item, itemData, itemKey = defaultItemKey, useIsScrolling } = this.props;\n        const { isScrolling } = this.state;\n        const key = itemKey(index, itemData);\n        const style = this.preset.getItemStyle(index);\n        if (type === 'placeholder') {\n            return React.createElement(this.preset.itemElement, {\n                key,\n                id: `${this.preset.id}-${index}-wrapper`,\n                style: this.preset.isBrick ? style : { display: 'none' }\n            });\n        }\n        return React.createElement(this.preset.itemElement, {\n            key: itemKey(index, itemData),\n            id: `${this.preset.id}-${index}-wrapper`,\n            style\n        }, React.createElement(item, {\n            id: `${this.preset.id}-${index}`,\n            data: itemData,\n            index,\n            isScrolling: useIsScrolling ? isScrolling : undefined\n        }));\n    }\n    getRenderColumnNode() {\n        const { isScrolling } = this.state;\n        const { innerRef, itemCount } = this.props;\n        const isHorizontal = this.preset.isHorizontal;\n        // Read this value AFTER items have been created,\n        // So their actual sizes (if variable) are taken into consideration.\n        const estimatedTotalSize = convertNumber2PX(this.itemList.getOffsetSize());\n        const columnProps = {\n            ref: innerRef,\n            key: `${this.preset.id}-inner`,\n            id: `${this.preset.id}-inner`,\n            style: {\n                height: isHorizontal ? '100%' : estimatedTotalSize,\n                width: !isHorizontal ? '100%' : estimatedTotalSize,\n                position: 'relative',\n                pointerEvents: isScrolling ? 'none' : 'auto',\n            }\n        };\n        const [startIndex, stopIndex] = this._getRangeToRender();\n        const items = [];\n        if (this.preset.isRelative && !this.preset.isBrick) {\n            const pre = convertNumber2PX(this.itemList.getOffsetSizeCache(startIndex));\n            items.push(React.createElement(this.preset.itemElement, {\n                key: `${this.preset.id}-pre`,\n                id: `${this.preset.id}-pre`,\n                style: {\n                    height: isHorizontal ? '100%' : pre,\n                    width: !isHorizontal ? '100%' : pre\n                }\n            }));\n        }\n        const placeholderCount = this.preset.placeholderCount;\n        const restCount = itemCount - stopIndex;\n        const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n        const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n        for (let itemIndex = 0; itemIndex < stopIndex + postPlaceholder; itemIndex++) {\n            if (!this.preset.isBrick) {\n                if (itemIndex < startIndex - prevPlaceholder) {\n                    itemIndex = startIndex - prevPlaceholder;\n                    continue;\n                }\n            }\n            if (itemIndex < startIndex || itemIndex > stopIndex) {\n                items.push(this.getRenderItemNode(itemIndex, 'placeholder'));\n            }\n            else {\n                items.push(this.getRenderItemNode(itemIndex));\n            }\n        }\n        return React.createElement(this.preset.innerElement, columnProps, items);\n    }\n    render() {\n        const _a = omit(this.props, [\n            'item', 'itemCount', 'itemData', 'itemKey', 'useIsScrolling',\n            'innerElementType', 'innerTagName', 'itemElementType', 'itemTagName',\n            'outerElementType', 'outerTagName', 'onScrollToLower', 'onScrollToUpper',\n            'upperThreshold', 'lowerThreshold',\n            'position', 'innerRef',\n        ]), { className, direction, height, layout, style, width, enhanced = false, outerWrapper, renderTop, renderBottom } = _a, rest = __rest(_a, [\"className\", \"direction\", \"height\", \"layout\", \"style\", \"width\", \"enhanced\", \"outerWrapper\", \"renderTop\", \"renderBottom\"]);\n        const { scrollOffset, scrollUpdateWasRequested } = this.state;\n        const isHorizontal = this.preset.isHorizontal;\n        const outerProps = Object.assign(Object.assign({}, rest), { id: this.preset.id, className, onScroll: isHorizontal ? this._onScrollHorizontal : this._onScrollVertical, ref: this._outerRefSetter, layout,\n            enhanced, style: Object.assign({ position: 'relative', height: convertNumber2PX(height), width: convertNumber2PX(width), overflow: 'auto', WebkitOverflowScrolling: 'touch', willChange: 'transform', direction }, style), outerElementType: this.preset.outerElement, innerElementType: this.preset.innerElement, renderTop,\n            renderBottom });\n        if (!enhanced) {\n            if (isHorizontal) {\n                outerProps.scrollLeft = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollLeft;\n            }\n            else {\n                outerProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n            }\n        }\n        return React.createElement(outerWrapper || this.preset.outerElement, outerProps, this.getRenderColumnNode());\n    }\n}\nList.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false,\n    shouldResetStyleCacheOnItemSizeChange: true\n};\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return List; } });\n//# sourceMappingURL=list.js.map\n","let devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n    if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n        devWarningsDirection = /* #__PURE__ */ new WeakSet();\n        devWarningsTagName = /* #__PURE__ */ new WeakSet();\n    }\n}\nconst validateListProps = ({ item, direction, layout, itemTagName, innerTagName, outerTagName, itemSize }, { instance, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!['number', 'function'].includes(typeof itemSize)) {\n            throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number or function. ' + `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`);\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (innerTagName != null || outerTagName != null || itemTagName != null) {\n            if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n                devWarningsTagName.add(instance);\n                console.warn('The itemTagName、innerTagName and outerTagName props have been deprecated. ' + 'Please use the itemElementType、innerElementType and outerElementType props instead.');\n            }\n        }\n        switch (direction) {\n            case 'horizontal':\n            case 'vertical':\n                if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n                    devWarningsDirection.add(instance);\n                    console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n                }\n                break;\n            case 'ltr':\n            case 'rtl':\n                // Valid values\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + `\"${direction}\" was specified.`);\n        }\n        switch (layout) {\n            case 'horizontal':\n            case 'vertical':\n                // Valid values\n                break;\n            default:\n                throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + `\"${layout}\" was specified.`);\n        }\n        if (item == null) {\n            throw Error('An invalid \"item\" prop has been specified. ' + 'Value should be a React component. ' + `\"${item === null ? 'null' : typeof item}\" was specified.`);\n        }\n        // if (isHorizontal && typeof width !== 'number') {\n        //   throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + `\"${width === null ? 'null' : typeof width}\" was specified.`)\n        // } else if (!isHorizontal && typeof height !== 'number') {\n        //   throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + `\"${height === null ? 'null' : typeof height}\" was specified.`)\n        // }\n    }\n    return null;\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'validateListProps', { enumerable: true, configurable: true, get: function() { return validateListProps; } });\n//# sourceMappingURL=validate.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../../../utils/convert.js');var convertPX2Int = __TEMP__['convertPX2Int'];\n\nfunction getRenderExpandNodes({ direction, isHorizontal, isRtl, id: sid, innerElement, renderExpand, }) {\n    const id = `${sid}-${direction}`;\n    const props = {\n        key: id,\n        id,\n        style: {\n            visibility: 'hidden',\n            height: isHorizontal ? '100%' : 100,\n            width: isHorizontal ? 100 : '100%',\n            [isHorizontal ? isRtl ? 'marginRight' : 'marginLeft' : 'marginTop']: -100,\n            zIndex: -1,\n        }\n    };\n    const expands = [renderExpand, React.createElement(innerElement, props)];\n    if (isHorizontal ? isRtl ? direction === 'right' : direction === 'left' : direction === 'top') {\n        expands.reverse();\n    }\n    return expands;\n}\nconst outerWrapper = React.forwardRef(function OuterWrapper(props, ref) {\n    const _a = props, { id = '', className, style = {}, children, outerElementType, innerElementType, onScroll, onScrollNative, renderTop, renderBottom, layout, direction } = _a, rest = __rest(_a, [\"id\", \"className\", \"style\", \"children\", \"outerElementType\", \"innerElementType\", \"onScroll\", \"onScrollNative\", \"renderTop\", \"renderBottom\", \"layout\", \"direction\"]);\n    const handleScroll = (event) => {\n        onScroll === null || onScroll === void 0 ? void 0 : onScroll(Object.assign(Object.assign({}, event), { currentTarget: Object.assign(Object.assign({}, event.detail), { clientWidth: convertPX2Int(style.width), clientHeight: convertPX2Int(style.height) }) }));\n        if (typeof onScrollNative === 'function') {\n            onScrollNative(event);\n        }\n    };\n    const isHorizontal = layout === 'horizontal';\n    const isRtl = direction === 'rtl';\n    return React.createElement(outerElementType, Object.assign({ ref,\n        id,\n        className,\n        style, scrollY: !isHorizontal, scrollX: isHorizontal, onScroll: handleScroll }, rest), [\n        getRenderExpandNodes({\n            direction: isHorizontal ? isRtl ? 'right' : 'left' : 'top',\n            isHorizontal,\n            isRtl,\n            id,\n            innerElement: innerElementType,\n            renderExpand: renderTop,\n        }),\n        children,\n        getRenderExpandNodes({\n            direction: isHorizontal ? isRtl ? 'left' : 'right' : 'bottom',\n            isHorizontal,\n            isRtl,\n            id,\n            innerElement: innerElementType,\n            renderExpand: renderBottom,\n        }),\n    ]);\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return outerWrapper; } });\n//# sourceMappingURL=wrapper.js.map\n","const VirtualWaterfall = (process.env.FRAMEWORK === 'vue' || process.env.FRAMEWORK === 'vue3')\n    ? require('./vue').default\n    : require('./react').default;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualWaterfall', { enumerable: true, configurable: true, get: function() { return VirtualWaterfall; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualWaterfall; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('./waterfall.js');var Waterfall = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst VirtualWaterfall = Waterfall;\nfunction install(Vue) {\n    Vue.component('virtual-waterfall', Waterfall);\n}\nvar index = {\n    install\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualWaterfall', { enumerable: true, configurable: true, get: function() { return VirtualWaterfall; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return index; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('@tarojs/shared');var isNumber = __TEMP__['isNumber'];\nvar __TEMP__ = require('classnames');var classNames = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('vue');var defineComponent = __TEMP__['defineComponent'];\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../../../utils/vue-render.js');var render = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/dom.js');var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];var getRectSizeSync = __TEMP__['getRectSizeSync'];\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../../../utils/helper.js');var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\n\nvar Waterfall = defineComponent({\n    props: {\n        id: String,\n        height: {\n            type: [String, Number],\n            required: true\n        },\n        width: {\n            type: [String, Number],\n            required: true\n        },\n        column: Number,\n        columnWidth: Number,\n        item: {\n            required: true\n        },\n        itemCount: {\n            type: Number,\n            required: true\n        },\n        itemData: {\n            type: Array,\n            required: true\n        },\n        itemKey: Function,\n        itemSize: {\n            type: [Number, Function],\n            required: true\n        },\n        unlimitedSize: {\n            type: Boolean,\n            default: false\n        },\n        queryPrefix: {\n            type: String,\n            default: ''\n        },\n        position: {\n            type: String,\n            default: 'absolute'\n        },\n        initialScrollOffset: {\n            type: Number,\n            default: 0\n        },\n        overscanDistance: {\n            type: Number,\n            default: 50\n        },\n        placeholderCount: {\n            type: Number,\n            default: 0\n        },\n        useIsScrolling: {\n            type: Boolean,\n            default: false\n        },\n        enhanced: {\n            type: Boolean,\n            default: true\n        },\n        shouldResetStyleCacheOnItemSizeChange: {\n            type: Boolean,\n            default: true\n        },\n        outerElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-scroll-view-core' : 'scroll-view'\n        },\n        innerElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-view-core' : 'view'\n        },\n        itemElementType: {\n            type: String,\n            default: process.env.TARO_PLATFORM === 'web' ? 'taro-view-core' : 'view'\n        },\n        outerTagName: String,\n        innerTagName: String,\n        itemTagName: String,\n        outerRef: String,\n        onScrollNative: Function,\n        onItemsRendered: Function,\n    },\n    data() {\n        const preset = new Preset(this.$props, this.refresh);\n        const id = this.$props.id || preset.id;\n        preset.updateWrapper(id);\n        return {\n            itemMap: preset.itemMap,\n            preset,\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.$props.initialScrollOffset === 'number'\n                ? this.$props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            resetIsScrollingTimeoutId: null,\n            refreshCount: 0\n        };\n    },\n    methods: {\n        refresh() {\n            this.refreshCount = this.refreshCount + 1;\n        },\n        scrollTo(scrollOffset = 0, enhanced = this.preset.enhanced) {\n            scrollOffset = Math.max(0, scrollOffset);\n            if (this.scrollOffset === scrollOffset)\n                return;\n            if (enhanced) {\n                const option = {\n                    animated: true,\n                    duration: 300,\n                };\n                option.top = scrollOffset;\n                return getScrollViewContextNode(`${this.$props.queryPrefix}#${this.preset.id}`).then((node) => node.scrollTo(option));\n            }\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = true;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        scrollToItem(index, align = 'auto', enhanced = this.preset.enhanced) {\n            const { itemCount } = this.$props;\n            const { scrollOffset } = this.$data;\n            index = Math.max(0, Math.min(index, itemCount - 1));\n            this.scrollTo(this.itemMap.getOffsetForIndexAndAlignment(index, align, scrollOffset), enhanced);\n        },\n        _callOnItemsRendered: memoizeOne(function (overscanStartIndex, overscanStopIndex, startIndex, stopIndex) {\n            return this.$props.onItemsRendered({\n                overscanStartIndex,\n                overscanStopIndex,\n                startIndex,\n                stopIndex\n            });\n        }),\n        _callOnScroll: memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) {\n            this.$emit('scroll', {\n                scrollDirection,\n                scrollOffset,\n                scrollUpdateWasRequested,\n                detail\n            });\n        }),\n        _callPropsCallbacks() {\n            if (typeof this.$props.onItemsRendered === 'function') {\n                if (this.$props.itemCount > 0) {\n                    for (let columnIndex = 0; columnIndex < this.itemMap.columns; columnIndex++) {\n                        const [overscanStartIndex, overscanStopIndex] = this._getRangeToRender(columnIndex);\n                        this._callOnItemsRendered(columnIndex, overscanStartIndex, overscanStopIndex);\n                    }\n                }\n            }\n            if (typeof this.$props.onScroll === 'function') {\n                this._callOnScroll(this.scrollDirection, this.scrollOffset, this.scrollUpdateWasRequested, this.preset.field);\n            }\n            if (this.itemMap.isUnlimitedMode) {\n                setTimeout(() => {\n                    for (let column = 0; column < this.itemMap.columns; column++) {\n                        const [startIndex, stopIndex] = this._getRangeToRender(column);\n                        for (let row = startIndex; row <= stopIndex; row++) {\n                            const itemIndex = this.itemMap.getItemIndexByPosition(column, row);\n                            if (itemIndex >= 0 && itemIndex < this.$props.itemCount) {\n                                const times = this.itemMap.compareSizeByPosition(column, row) ? 3 : 0;\n                                getRectSizeSync(`${this.$props.queryPrefix}#${this.preset.id}-${itemIndex}`, 100, times).then(({ height }) => {\n                                    if (typeof height === 'number' && height > 0 && !this.itemMap.compareSizeByPosition(column, row, height)) {\n                                        this.itemMap.setSizeByPosition(column, row, height);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }, 0);\n            }\n        },\n        _getRangeToRender(columnIndex = 0) {\n            return this.itemMap.getRangeToRender(this.$data.scrollDirection, columnIndex, this.$data.scrollOffset, this.$data.isScrolling);\n        },\n        _outerRefSetter(ref) {\n            const { outerRef } = this.$props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('value')) {\n                outerRef.value = ref;\n            }\n        },\n        _resetIsScrollingDebounced() {\n            if (this.resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this.resetIsScrollingTimeoutId);\n            }\n            this.resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        },\n        _resetIsScrolling() {\n            this.resetIsScrollingTimeoutId = null;\n            this.isScrolling = false;\n            this.$nextTick(() => {\n                this.preset.resetCache();\n            });\n        },\n        _onScroll(event) {\n            const { scrollHeight = this.itemMap.maxColumnSize, scrollWidth, scrollTop, scrollLeft, } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientHeight = this.itemMap.wrapperHeight;\n            const clientWidth = this.itemMap.wrapperWidth;\n            if (this.$props.onScrollNative) {\n                this.$props.onScrollNative(event);\n            }\n            const diffOffset = this.preset.field.scrollTop - scrollTop;\n            if (this.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                return;\n            }\n            // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n            const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n            this.preset.field = {\n                scrollHeight: this.itemMap.maxColumnSize,\n                scrollWidth,\n                scrollTop: scrollOffset,\n                scrollLeft,\n                clientHeight,\n                clientWidth,\n                diffOffset: this.preset.field.scrollTop - scrollOffset,\n            };\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = false;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        getRenderItemNode(itemIndex, type = 'node') {\n            const { item, itemData, itemKey = defaultItemKey, useIsScrolling } = this.$props;\n            const { isScrolling } = this.$data;\n            const key = itemKey(itemIndex, itemData);\n            const style = this.preset.getItemStyle(itemIndex);\n            if (type === 'placeholder') {\n                return render(this.preset.itemElement, {\n                    key,\n                    id: `${this.preset.id}-${itemIndex}-wrapper`,\n                    style: this.preset.isBrick ? style : { display: 'none' }\n                });\n            }\n            return render(this.preset.itemElement, {\n                key,\n                id: `${this.preset.id}-${itemIndex}-wrapper`,\n                style\n            }, render(item, {\n                id: `${this.preset.id}-${itemIndex}`,\n                data: itemData,\n                index: itemIndex,\n                isScrolling: useIsScrolling ? isScrolling : undefined\n            }));\n        },\n        getRenderColumnNode(columnIndex) {\n            const columnProps = {\n                key: `${this.preset.id}-column-${columnIndex}`,\n                id: `${this.preset.id}-column-${columnIndex}`,\n                style: {\n                    height: '100%',\n                    position: 'relative',\n                    width: convertNumber2PX(this.itemMap.columnWidth)\n                }\n            };\n            const [startIndex, stopIndex] = this._getRangeToRender(columnIndex);\n            const items = [];\n            if (this.preset.isRelative && !this.preset.isBrick) {\n                const pre = convertNumber2PX(this.itemMap.getOffsetSizeCache(columnIndex, startIndex));\n                items.push(render(this.preset.itemElement, {\n                    key: `${this.preset.id}-${columnIndex}-pre`,\n                    id: `${this.preset.id}-${columnIndex}-pre`,\n                    style: {\n                        height: pre,\n                        width: '100%'\n                    }\n                }));\n            }\n            const placeholderCount = this.preset.placeholderCount;\n            const restCount = this.itemMap.getColumnLength(columnIndex) - stopIndex;\n            const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n            const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n            const visibleItem = (stopIndex + postPlaceholder) * this.itemMap.columns + columnIndex;\n            this.itemMap.updateItem(visibleItem);\n            for (let row = 0; row < stopIndex + postPlaceholder; row++) {\n                const itemIndex = this.itemMap.getItemIndexByPosition(columnIndex, row);\n                if (itemIndex >= 0 && itemIndex < this.$props.itemCount) {\n                    if (!this.preset.isBrick) {\n                        if (row < startIndex - prevPlaceholder) {\n                            row = startIndex - prevPlaceholder;\n                            continue;\n                        }\n                    }\n                    if (row < startIndex || row > stopIndex) {\n                        items.push(this.getRenderItemNode(itemIndex, 'placeholder'));\n                    }\n                    else {\n                        items.push(this.getRenderItemNode(itemIndex));\n                    }\n                }\n            }\n            return render(this.preset.innerElement, columnProps, items);\n        },\n        getRenderExpandNodes(direction) {\n            const props = {\n                id: `${this.preset.id}-${direction}`,\n                style: {\n                    visibility: 'hidden',\n                    height: 100,\n                    width: '100%',\n                    marginTop: -100,\n                    zIndex: -1,\n                }\n            };\n            return render(this.preset.innerElement, props);\n        }\n    },\n    mounted() {\n        const { initialScrollOffset } = this.$props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            outerRef.scrollTop = initialScrollOffset;\n        }\n        this._callPropsCallbacks();\n        this.preset.boundaryDetection();\n    },\n    updated() {\n        const { scrollOffset, scrollUpdateWasRequested } = this.$data;\n        this.preset.update(this.$props);\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            this._outerRef.scrollTop = scrollOffset;\n        }\n        this._callPropsCallbacks();\n    },\n    beforeDestroy() {\n        if (this.resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this.resetIsScrollingTimeoutId);\n        }\n        this.preset.dispose();\n    },\n    render() {\n        var _a, _b, _c, _d;\n        const { height, width, enhanced = false } = omit(this.$props, [\n            'item', 'itemCount', 'itemData', 'itemKey', 'useIsScrolling',\n            'innerElementType', 'innerTagName', 'itemElementType', 'itemTagName',\n            'outerElementType', 'outerTagName', 'onScrollToLower', 'onScrollToUpper',\n            'upperThreshold', 'lowerThreshold',\n            'position'\n        ]);\n        const { isScrolling, scrollOffset, scrollUpdateWasRequested } = this.$data;\n        const estimatedHeight = convertNumber2PX(this.itemMap.maxColumnSize);\n        const outerElementProps = {\n            id: this.preset.id,\n            ref: this._outerRefSetter,\n            enhanced,\n            class: classNames(this.$attrs.class, 'virtual-waterfall'),\n            style: {\n                height: convertNumber2PX(height),\n                width: convertNumber2PX(width),\n                overflow: 'auto',\n                WebkitOverflowScrolling: 'touch',\n                willChange: 'transform',\n            },\n            attrs: {\n                scrollY: true,\n            },\n            on: {\n                scroll: this._onScroll\n            },\n        };\n        if (!enhanced) {\n            outerElementProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n        }\n        const columnNodes = [];\n        for (let i = 0; i < this.itemMap.columns; i++) {\n            columnNodes.push(this.getRenderColumnNode(i));\n        }\n        return render(this.preset.outerElement, outerElementProps, [\n            this.getRenderExpandNodes('top'),\n            process.env.FRAMEWORK === 'vue3' ? (_b = (_a = this.$slots).top) === null || _b === void 0 ? void 0 : _b.call(_a) : this.$slots.top,\n            render(this.preset.innerElement, {\n                key: `${this.preset.id}-wrapper`,\n                id: `${this.preset.id}-wrapper`,\n                class: classNames(this.$attrs.class, 'virtual-waterfall-wrapper'),\n                style: {\n                    display: 'flex',\n                    justifyContent: 'space-evenly',\n                    pointerEvents: isScrolling ? 'none' : 'auto',\n                    position: 'relative',\n                    height: estimatedHeight,\n                    width: '100%',\n                },\n            }, columnNodes),\n            process.env.FRAMEWORK === 'vue3' ? (_d = (_c = this.$slots).bottom) === null || _d === void 0 ? void 0 : _d.call(_c) : this.$slots.bottom,\n            this.getRenderExpandNodes('bottom'),\n        ]);\n    }\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return Waterfall; } });\n//# sourceMappingURL=waterfall.js.map\n","const IS_SCROLLING_DEBOUNCE_INTERVAL = 200;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'IS_SCROLLING_DEBOUNCE_INTERVAL', { enumerable: true, configurable: true, get: function() { return IS_SCROLLING_DEBOUNCE_INTERVAL; } });\n//# sourceMappingURL=constants.js.map\n","var __TEMP__ = require('@tarojs/taro');var createSelectorQuery = __TEMP__['createSelectorQuery'];var getCurrentInstance = __TEMP__['getCurrentInstance'];var createIntersectionObserver = __TEMP__['createIntersectionObserver'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/index.js');\nvar __TEMP__ = require('./list-map.js');var ListMap = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../utils/dom.js');var getRectSizeSync = __TEMP__['getRectSizeSync'];\nvar __TEMP__ = require('../../utils/math.js');var isCosDistributing = __TEMP__['isCosDistributing'];\nvar __TEMP__ = require('../../utils/lodash.js');var throttle = __TEMP__['throttle'];\n\nlet INSTANCE_ID = 0;\nclass Preset {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this._observer = {};\n        this._wrapperField = {\n            scrollLeft: 0,\n            scrollTop: 0,\n            scrollHeight: 0,\n            scrollWidth: 0,\n            clientHeight: 0,\n            clientWidth: 0,\n            diffOffset: 0\n        };\n        this.diffList = [0, 0, 0];\n        this.getItemStyleCache = memoizeOne((itemIndex, itemSize, _flag = this.itemMap.refreshCounter) => {\n            itemSize = itemSize || this.itemMap.getSize(itemIndex);\n            const style = this.isRelative ? {} : {\n                position: 'absolute',\n                left: 0,\n            };\n            style.width = '100%';\n            style.height = convertNumber2PX(itemSize);\n            if (!this.isRelative) {\n                const nodeOffset = this.itemMap.getOffsetSize(itemIndex);\n                style.top = convertNumber2PX(nodeOffset);\n            }\n            return style;\n        });\n        this.init(this.props);\n        this.itemMap = new ListMap(props, refresh);\n    }\n    init(props) {\n        this.props = props;\n    }\n    update(props) {\n        this.props = props;\n        this.itemMap.update(props);\n    }\n    async updateWrapper(id) {\n        var _a;\n        var _b, _c;\n        this.id = id;\n        const { width = 0, height = 0 } = this.props;\n        const validWidth = typeof width === 'number' && width > 0;\n        const validHeight = typeof height === 'number' && height > 0;\n        if (validWidth) {\n            this.itemMap.wrapperWidth = width;\n        }\n        if (validHeight) {\n            this.itemMap.wrapperHeight = height;\n        }\n        if (!validHeight || !validWidth) {\n            const res = await getRectSizeSync(`#${id}`, 100);\n            (_b = this.itemMap).wrapperWidth || (_b.wrapperWidth = res.width);\n            (_c = this.itemMap).wrapperHeight || (_c.wrapperHeight = res.height);\n            (_a = this.refresh) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        this.itemMap.update(this.props);\n    }\n    set id(id) {\n        this._id = id;\n    }\n    get id() {\n        this._id || (this._id = `virtual-waterfall-${INSTANCE_ID++}`);\n        return this._id;\n    }\n    get isRelative() {\n        return this.props.position && this.props.position !== 'absolute';\n    }\n    get isBrick() {\n        return this.props.position === 'brick';\n    }\n    get placeholderCount() {\n        return this.props.placeholderCount || 0;\n    }\n    get outerElement() {\n        return this.props.outerElementType || this.props.outerTagName || 'div';\n    }\n    get innerElement() {\n        return this.props.innerElementType || this.props.innerTagName || 'div';\n    }\n    get itemElement() {\n        return this.props.itemElementType || this.props.itemTagName || 'div';\n    }\n    get field() {\n        return this._wrapperField;\n    }\n    set field(o) {\n        Object.assign(this._wrapperField, o);\n    }\n    get enhanced() {\n        return this.props.enhanced || true;\n    }\n    isShaking(diff) {\n        if (process.env.TARO_PLATFORM === 'web' || this.props.enhanced)\n            return false;\n        const list = this.diffList.slice(-3);\n        this.diffList.push(diff);\n        return list.findIndex(e => Math.abs(e) === Math.abs(diff)) !== -1 || isCosDistributing(this.diffList.slice(-4));\n    }\n    resetCache() {\n        this.itemMap.refreshCounter++;\n    }\n    getItemStyle(itemIndex) {\n        const { shouldResetStyleCacheOnItemSizeChange } = this.props;\n        return this.getItemStyleCache(itemIndex, shouldResetStyleCacheOnItemSizeChange ? this.itemMap.getSize(itemIndex) : false);\n    }\n    boundaryDetection() {\n        if ([typeof this.props.onScrollToUpper, typeof this.props.onScrollToLower].every(e => e !== 'function'))\n            return;\n        createSelectorQuery().select(`#${this.id}`).node().exec(() => {\n            const upperObserver = this.boundaryDetectionHelper({\n                event: typeof this.props.onScrollToUpper === 'function' ? () => {\n                    if (this.field.diffOffset >= 0)\n                        this.props.onScrollToUpper();\n                } : undefined,\n                id: `${this.id}-top`,\n            });\n            if (upperObserver) {\n                this._observer.top = upperObserver;\n            }\n            const lowerObserver = this.boundaryDetectionHelper({\n                event: typeof this.props.onScrollToLower === 'function' ? () => {\n                    if (this.field.diffOffset <= 0)\n                        this.props.onScrollToLower();\n                } : undefined,\n                id: `${this.id}-bottom`,\n            });\n            if (lowerObserver) {\n                this._observer.bottom = lowerObserver;\n            }\n        });\n    }\n    boundaryDetectionHelper({ component, event, id, }) {\n        if (typeof event !== 'function')\n            return;\n        const eventFunc = throttle(event);\n        component || (component = getCurrentInstance().page);\n        const observer = createIntersectionObserver(component, {\n            thresholds: [0.4],\n        });\n        observer\n            .relativeTo(`#${this.id}`, {\n            top: typeof this.props.lowerThreshold === 'number' ? this.props.lowerThreshold : 50,\n            bottom: typeof this.props.upperThreshold === 'number' ? this.props.upperThreshold : 50,\n        })\n            .observe(`#${id}`, eventFunc);\n        return observer;\n    }\n    dispose() {\n        Object.values(this._observer).forEach(e => { var _a; return (_a = e.disconnect) === null || _a === void 0 ? void 0 : _a.call(e); });\n        this._observer = {};\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return Preset; } });\n//# sourceMappingURL=preset.js.map\n","var __TEMP__ = require('@tarojs/shared');var isFunction = __TEMP__['isFunction'];var isNumber = __TEMP__['isNumber'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/index.js');\nvar __TEMP__ = require('../../utils/helper.js');var getOffsetForIndexAndAlignment = __TEMP__['getOffsetForIndexAndAlignment'];\n\nclass ListMap {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this._columnMap = []; // [itemIndex, itemSize]\n        this._items = []; // columnIndex-rowIndex\n        this.minItemSize = 0;\n        this.maxItemSize = 0;\n        this.defaultSize = 1;\n        this.wrapperHeight = 0;\n        this.wrapperWidth = 0;\n        this.columns = 2;\n        this.columnWidth = 0;\n        this.refreshCounter = 0;\n        this.getOffsetSizeCache = memoizeOne((column, row, _flag = this.refreshCounter) => {\n            return this.getOffsetSizeByPosition(column, row);\n        });\n        // Note: 不考虑列表模式切换情况，可能会导致列表抖动体验过差\n        if (this.props.unlimitedSize) {\n            this.mode = 'unlimited';\n        }\n        else if (isFunction(this.props.itemSize)) {\n            this.mode = 'function';\n        }\n        else if (isNumber(this.props.itemSize)) {\n            this.mode = 'normal';\n        }\n        this.defaultSize = (isFunction(this.props.itemSize) ? this.props.itemSize() : this.props.itemSize) || 1;\n        this.minItemSize = this.defaultSize;\n        this.maxItemSize = this.defaultSize;\n        this.update(props);\n    }\n    get isNormalMode() {\n        return this.mode === 'normal';\n    }\n    get isFunctionMode() {\n        return this.mode === 'function';\n    }\n    get isUnlimitedMode() {\n        return this.mode === 'unlimited';\n    }\n    get length() {\n        return this.props.itemCount || 100;\n    }\n    get overscan() {\n        return this.props.overscanDistance || 50;\n    }\n    get columnsSize() {\n        if (this.isNormalMode) {\n            return new Array(this._columns).fill(this.getColumnSize());\n        }\n        return new Array(this._columns).fill(0).map((_, i) => this.getColumnSize(i));\n    }\n    get maxColumnSize() {\n        if (this.isNormalMode)\n            return this.getColumnSize();\n        return Math.max(...this.columnsSize);\n    }\n    get minColumnSize() {\n        if (this.isNormalMode)\n            return this.getColumnSize();\n        return Math.min(...this.columnsSize);\n    }\n    get maxColumnIndex() {\n        if (this.isNormalMode)\n            return 0;\n        const list = this.columnsSize;\n        return list.indexOf(Math.max(...list));\n    }\n    get minColumnIndex() {\n        if (this.isNormalMode)\n            return 0;\n        const list = this.columnsSize;\n        return list.indexOf(Math.min(...list));\n    }\n    update(props) {\n        this.props = props;\n        const { column, columnWidth } = this.props;\n        if (typeof column === 'number' && column > 0) {\n            this.columns = column;\n            this.columnWidth = this.wrapperWidth / column;\n        }\n        else if (typeof columnWidth === 'number' && columnWidth > 0) {\n            this.columns = Math.floor(this.wrapperWidth / columnWidth);\n            this.columnWidth = columnWidth;\n        }\n        else {\n            this.columns = 2;\n            this.columnWidth = this.wrapperWidth / this.columns;\n        }\n        this.columnWidth || (this.columnWidth = `calc(100% / ${this.columns})`);\n        this.updateColumns(this.columns);\n        // this.updateItem(this.length - 1)\n    }\n    updateColumns(columns = 2) {\n        if (!this.isNormalMode && this._columns !== columns) {\n            this._columnMap = new Array(columns).fill(0).map(() => []);\n            this._items = [];\n        }\n        this._columns = columns;\n    }\n    updateItem(itemIndex) {\n        if (this.isNormalMode)\n            return;\n        if (itemIndex >= this.length)\n            return this.updateItem(this.length - 1);\n        for (let i = 0; i <= itemIndex; i++) {\n            const position = this.getItemPosition(i);\n            if (position)\n                continue;\n            const column = this.minColumnIndex;\n            const row = this.getColumnLength(column);\n            this._items[i] = `${column}-${row}`;\n            const itemSize = this.getSizeByPosition(column, row, i);\n            if (!this.compareSizeByPosition(column, row, itemSize)) {\n                this.setSizeByPosition(column, row, itemSize, i);\n            }\n        }\n    }\n    setSizeByPosition(column = 0, row = 0, itemSize = this.defaultSize, itemIndex = this.getItemIndexByPosition(column, row)) {\n        var _a;\n        if (itemIndex >= 0) {\n            if (this.maxItemSize < itemSize || this.maxItemSize === 0) {\n                this.maxItemSize = itemSize;\n            }\n            if (this.minItemSize > itemSize || this.minItemSize === 0) {\n                this.minItemSize = itemSize;\n            }\n            this._columnMap[column][row] = [itemIndex, itemSize];\n            if (!this.isNormalMode) {\n                (_a = this.refresh) === null || _a === void 0 ? void 0 : _a.call(this);\n                this.refreshCounter++;\n            }\n        }\n    }\n    getSize(itemIndex = 0) {\n        const position = this.getItemPosition(itemIndex);\n        if (position) {\n            return this.getSizeByPosition(...position, itemIndex);\n        }\n        else {\n            return this.defaultSize;\n        }\n    }\n    getSizeByPosition(column = 0, row = 0, itemIndex = this.getItemIndexByPosition(column, row)) {\n        var _a;\n        if (this.isNormalMode)\n            return this.defaultSize;\n        let itemSize = (_a = this.getColumnList(column)[row]) === null || _a === void 0 ? void 0 : _a[1];\n        if (typeof itemSize === 'number')\n            return itemSize;\n        itemSize = (isFunction(this.props.itemSize) ? this.props.itemSize(itemIndex, this.props.itemData) : this.props.itemSize) || this.defaultSize;\n        this.setSizeByPosition(column, row, itemSize);\n        return itemSize;\n    }\n    // 不支持 normal 模式\n    getColumnList(column) {\n        var _a;\n        (_a = this._columnMap)[column] || (_a[column] = []);\n        return this._columnMap[column];\n    }\n    getColumnLength(columnIndex) {\n        if (this.isNormalMode)\n            return Math.ceil(this.length / this._columns);\n        return this.getColumnList(columnIndex).length;\n    }\n    getColumnSize(columnIndex = 0) {\n        if (this.isNormalMode) {\n            return this.defaultSize * this.getColumnLength(columnIndex);\n        }\n        // Note: 不考虑未同步节点情况\n        return this.getOffsetSizeCache(columnIndex, this.getColumnLength(columnIndex));\n    }\n    getItemPosition(itemIndex) {\n        var _a;\n        if (this.isNormalMode) {\n            const column = itemIndex % this._columns;\n            const row = Math.floor(itemIndex / this._columns);\n            return [column, row];\n        }\n        return ((_a = this._items[itemIndex]) === null || _a === void 0 ? void 0 : _a.split('-').map(Number)) || false;\n    }\n    getItemIndexByPosition(column = 0, row = 0) {\n        if (this.isNormalMode) {\n            return row * this._columns + column;\n        }\n        const columnList = this.getColumnList(column);\n        const [itemIndex] = columnList[row] || [];\n        return itemIndex;\n    }\n    getOffsetSize(itemIndex) {\n        const [column, row] = this.getItemPosition(itemIndex) || [];\n        return this.getOffsetSizeCache(column, row);\n    }\n    getOffsetSizeByPosition(column = 0, row = 0) {\n        column = Math.max(0, column);\n        row = Math.max(0, row);\n        let sum = 0;\n        for (let i = 0; i < row; i++) {\n            sum += this.getSizeByPosition(column, i);\n        }\n        return sum;\n    }\n    getStartIndex(column, offset) {\n        if (offset <= 0)\n            return 0;\n        if (this.isNormalMode) {\n            const size = this.minItemSize || 1;\n            return Math.max(0, Math.floor(offset / size));\n        }\n        const columnList = this.getColumnList(column);\n        const columnLength = columnList.length - 1;\n        let x = Math.floor(offset / (this.maxItemSize || 1));\n        let y = Math.ceil(offset / (this.minItemSize || 1));\n        this.updateItem(this.getItemIndexByPosition(column, y));\n        x = Math.min(x, columnLength);\n        y = Math.min(y, columnLength);\n        while (this.getOffsetSizeCache(column, x - 1) < offset && this.getOffsetSizeCache(column, y - 1) > offset && x < y) {\n            x < columnLength && x++;\n            y > 0 && y--;\n        }\n        return Math.max(0, Math.min(this.getOffsetSizeCache(column, x - 1) > offset ? x : y, columnLength) - 1);\n    }\n    getStopIndex(column, offset, start = 0) {\n        if (offset <= 0)\n            return 0;\n        if (this.isNormalMode) {\n            const size = this.minItemSize || 1;\n            const count = Math.ceil(offset / size);\n            return Math.min(count, this.getColumnSize(column));\n        }\n        const columnList = this.getColumnList(column);\n        const columnLength = columnList.length - 1;\n        let x = Math.max(start, Math.floor(offset / (this.maxItemSize || 1)));\n        let y = Math.max(start, Math.ceil(offset / (this.minItemSize || 1)));\n        this.updateItem(this.getItemIndexByPosition(column, y));\n        x = Math.min(x, columnLength);\n        y = Math.min(y, columnLength);\n        while (this.getOffsetSizeCache(column, x) < offset && this.getOffsetSizeCache(column, y) > offset && x < y) {\n            x < columnLength && x++;\n            y > 0 && y--;\n        }\n        return Math.max(1, Math.min(this.getOffsetSizeCache(column, x) > offset ? x : y, columnLength) + 1);\n    }\n    getRangeToRender(direction, column, offset, block = false) {\n        if (this.length === 0)\n            return [0, 0];\n        const scrollSize = this.maxColumnSize;\n        const backwardDistance = !block || direction === 'backward' ? Math.max(0, this.overscan) : 0;\n        const forwardDistance = !block || direction === 'forward' ? Math.max(0, this.overscan) : 0;\n        const overscanBackward = this.getStartIndex(column, Math.max(0, offset - this.wrapperHeight - backwardDistance));\n        const overscanForward = this.getStopIndex(column, Math.max(0, Math.min(scrollSize, offset + this.wrapperHeight + forwardDistance)), overscanBackward);\n        return [overscanBackward, overscanForward];\n    }\n    getOffsetForIndexAndAlignment(index, align, scrollOffset) {\n        return getOffsetForIndexAndAlignment({\n            align,\n            containerSize: this.wrapperHeight,\n            currentOffset: scrollOffset,\n            scrollSize: this.getOffsetSize(this.length),\n            slideSize: this.getColumnSize(index),\n            targetOffset: this.getOffsetSize(index),\n        });\n    }\n    compareSizeByPosition(column = 0, row = 0, size = this.getSizeByPosition(column, row)) {\n        var _a, _b;\n        if (this.isNormalMode)\n            return true;\n        const origenSize = (_b = (_a = this._columnMap[column]) === null || _a === void 0 ? void 0 : _a[row]) === null || _b === void 0 ? void 0 : _b[1];\n        return typeof origenSize === 'number' && origenSize === size;\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return ListMap; } });\n//# sourceMappingURL=list-map.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('@tarojs/components');var ScrollView = __TEMP__['ScrollView'];var View = __TEMP__['View'];\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./waterfall.js');var Waterfall = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./wrapper.js');var outerWrapper = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst VirtualWaterfall = React.forwardRef(function VirtualWaterfall(props, ref) {\n    const _a = props, { outerElementType = ScrollView, innerElementType = View, itemElementType = View, initialScrollOffset = 0, overscanDistance = 50, queryPrefix = '' } = _a, rest = __rest(_a, [\"outerElementType\", \"innerElementType\", \"itemElementType\", \"initialScrollOffset\", \"overscanDistance\", \"queryPrefix\"]);\n    if ('children' in rest) {\n        console.warn('Taro(VirtualWaterfall): children props have been deprecated. ' + 'Please use the item props instead.');\n        rest.item = rest.children;\n    }\n    if (rest.item instanceof Array) {\n        console.warn('Taro(VirtualWaterfall): item should not be an array');\n        rest.item = rest.item[0];\n    }\n    return React.createElement(Waterfall, Object.assign(Object.assign({ ref }, rest), { outerElementType,\n        itemElementType,\n        innerElementType,\n        initialScrollOffset,\n        overscanDistance,\n        outerWrapper,\n        queryPrefix }));\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualWaterfall; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('@tarojs/shared');var isNumber = __TEMP__['isNumber'];\nvar __TEMP__ = require('classnames');var classNames = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../../../utils/dom.js');var getRectSizeSync = __TEMP__['getRectSizeSync'];var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];\nvar __TEMP__ = require('../../../utils/helper.js');var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\n\nclass Waterfall extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.refresh = () => {\n            if (process.env.FRAMEWORK === 'preact') {\n                this.forceUpdate();\n            }\n            else {\n                this.setState(({ refreshCount }) => ({\n                    refreshCount: ++refreshCount\n                }));\n            }\n        };\n        this._outerRef = undefined;\n        this._resetIsScrollingTimeoutId = null;\n        this._callOnItemsRendered = memoizeOne((columnIndex, overscanStartIndex, overscanStopIndex) => this.props.onItemsRendered({\n            columnIndex,\n            overscanStartIndex,\n            overscanStopIndex,\n        }));\n        this._callOnScroll = memoizeOne((scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) => this.props.onScroll({\n            scrollDirection,\n            scrollOffset,\n            scrollUpdateWasRequested,\n            detail\n        }));\n        this._outerRefSetter = ref => {\n            const { outerRef } = this.props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n                // @ts-ignore\n                outerRef.current = ref;\n            }\n        };\n        this._resetIsScrollingDebounced = () => {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n            this._resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        };\n        this._resetIsScrolling = () => {\n            this._resetIsScrollingTimeoutId = null;\n            this.setState({\n                isScrolling: false\n            }, () => {\n                // Clear style cache after state update has been committed.\n                // This way we don't break pure sCU for items that don't use isScrolling param.\n                this.preset.resetCache();\n            });\n        };\n        this._onScroll = event => {\n            const { scrollHeight = this.itemMap.maxColumnSize, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n            if (!isNumber(scrollHeight) || !isNumber(scrollWidth))\n                return;\n            const clientHeight = this.itemMap.wrapperHeight;\n            const clientWidth = this.itemMap.wrapperWidth;\n            this.setState((prevState) => {\n                const diffOffset = this.preset.field.scrollTop - scrollTop;\n                if (prevState.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                    // Scroll position may have been updated by cDM/cDU,\n                    // In which case we don't need to trigger another render,\n                    // And we don't want to update state.isScrolling.\n                    return null;\n                }\n                // FIXME preact 中使用时，该组件会出现触底滚动事件重复触发导致的抖动问题，后续修复\n                // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                this.preset.field = {\n                    scrollHeight: this.itemMap.maxColumnSize,\n                    scrollWidth,\n                    scrollTop: scrollOffset,\n                    scrollLeft,\n                    clientHeight,\n                    clientWidth,\n                    diffOffset: this.preset.field.scrollTop - scrollOffset,\n                };\n                return {\n                    isScrolling: true,\n                    scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                    scrollOffset,\n                    scrollUpdateWasRequested: false\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        this.preset = new Preset(props, this.refresh);\n        const id = this.props.id || this.preset.id;\n        this.preset.updateWrapper(id);\n        this.itemMap = this.preset.itemMap;\n        this.state = {\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.props.initialScrollOffset === 'number'\n                ? this.props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            refreshCount: 0,\n        };\n    }\n    _callPropsCallbacks(prevProps = {}, prevState = {}) {\n        if (typeof this.props.onItemsRendered === 'function') {\n            if (this.props.itemCount > 0) {\n                if (prevProps && prevProps.itemCount !== this.props.itemCount) {\n                    for (let columnIndex = 0; columnIndex < this.itemMap.columns; columnIndex++) {\n                        const [overscanStartIndex, overscanStopIndex] = this._getRangeToRender(columnIndex);\n                        this._callOnItemsRendered(columnIndex, overscanStartIndex, overscanStopIndex);\n                    }\n                }\n            }\n        }\n        if (typeof this.props.onScroll === 'function') {\n            if (!prevState ||\n                prevState.scrollDirection !== this.state.scrollDirection ||\n                prevState.scrollOffset !== this.state.scrollOffset ||\n                prevState.scrollUpdateWasRequested !== this.state.scrollUpdateWasRequested) {\n                this._callOnScroll(this.state.scrollDirection, this.state.scrollOffset, this.state.scrollUpdateWasRequested, this.preset.field);\n            }\n        }\n        if (this.itemMap.isUnlimitedMode) {\n            setTimeout(() => {\n                for (let column = 0; column < this.itemMap.columns; column++) {\n                    const [startIndex, stopIndex] = this._getRangeToRender(column);\n                    for (let row = startIndex; row <= stopIndex; row++) {\n                        const itemIndex = this.itemMap.getItemIndexByPosition(column, row);\n                        if (itemIndex >= 0 && itemIndex < this.props.itemCount) {\n                            const times = this.itemMap.compareSizeByPosition(column, row) ? 3 : 0;\n                            getRectSizeSync(`${this.props.queryPrefix}#${this.preset.id}-${itemIndex}`, 100, times).then(({ height }) => {\n                                if (typeof height === 'number' && height > 0 && !this.itemMap.compareSizeByPosition(column, row, height)) {\n                                    this.itemMap.setSizeByPosition(column, row, height);\n                                }\n                            });\n                        }\n                    }\n                }\n            }, 0);\n        }\n    }\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getRangeToRender(columnIndex = 0) {\n        return this.itemMap.getRangeToRender(this.state.scrollDirection, columnIndex, this.state.scrollOffset, this.state.isScrolling);\n    }\n    scrollTo(scrollOffset = 0, enhanced = this.preset.enhanced) {\n        scrollOffset = Math.max(0, scrollOffset);\n        if (this.state.scrollOffset === scrollOffset)\n            return;\n        if (enhanced) {\n            const option = {\n                animated: true,\n                duration: 300,\n            };\n            option.top = scrollOffset;\n            return getScrollViewContextNode(`${this.props.queryPrefix}#${this.preset.id}`).then((node) => node.scrollTo(option));\n        }\n        this.setState((prevState) => {\n            if (prevState.scrollOffset === scrollOffset) {\n                return null;\n            }\n            return {\n                scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                scrollOffset,\n                scrollUpdateWasRequested: true\n            };\n        }, this._resetIsScrollingDebounced);\n    }\n    scrollToItem(index, align = 'auto', enhanced = this.preset.enhanced) {\n        const { itemCount } = this.props;\n        const { scrollOffset } = this.state;\n        index = Math.max(0, Math.min(index, itemCount - 1));\n        this.scrollTo(this.itemMap.getOffsetForIndexAndAlignment(index, align, scrollOffset), enhanced);\n    }\n    componentDidMount() {\n        const { initialScrollOffset } = this.props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            this._outerRef.scrollTop = initialScrollOffset;\n        }\n        this._callPropsCallbacks();\n        this.preset.boundaryDetection();\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { scrollOffset, scrollUpdateWasRequested } = this.state;\n        this.preset.update(this.props);\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            this._outerRef.scrollTop = scrollOffset;\n        }\n        this._callPropsCallbacks(prevProps, prevState);\n    }\n    componentWillUnmount() {\n        if (this._resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this._resetIsScrollingTimeoutId);\n        }\n        this.preset.dispose();\n    }\n    getRenderItemNode(itemIndex, type = 'node') {\n        const { item, itemData, itemKey = defaultItemKey, useIsScrolling } = this.props;\n        const { isScrolling } = this.state;\n        const key = itemKey(itemIndex, itemData);\n        const style = this.preset.getItemStyle(itemIndex);\n        if (type === 'placeholder') {\n            return React.createElement(this.preset.itemElement, {\n                key,\n                id: `${this.preset.id}-${itemIndex}-wrapper`,\n                style: this.preset.isBrick ? style : { display: 'none' }\n            });\n        }\n        return React.createElement(this.preset.itemElement, {\n            key,\n            id: `${this.preset.id}-${itemIndex}-wrapper`,\n            style\n        }, React.createElement(item, {\n            id: `${this.preset.id}-${itemIndex}`,\n            data: itemData,\n            index: itemIndex,\n            isScrolling: useIsScrolling ? isScrolling : undefined\n        }));\n    }\n    getRenderColumnNode(columnIndex) {\n        const columnProps = {\n            key: `${this.preset.id}-column-${columnIndex}`,\n            id: `${this.preset.id}-column-${columnIndex}`,\n            style: {\n                height: '100%',\n                position: 'relative',\n                width: convertNumber2PX(this.itemMap.columnWidth)\n            }\n        };\n        const [startIndex, stopIndex] = this._getRangeToRender(columnIndex);\n        const items = [];\n        if (this.preset.isRelative && !this.preset.isBrick) {\n            const pre = convertNumber2PX(this.itemMap.getOffsetSizeCache(columnIndex, startIndex));\n            items.push(React.createElement(this.preset.itemElement, {\n                key: `${this.preset.id}-${columnIndex}-pre`,\n                id: `${this.preset.id}-${columnIndex}-pre`,\n                style: {\n                    height: pre,\n                    width: '100%'\n                }\n            }));\n        }\n        const placeholderCount = this.preset.placeholderCount;\n        const restCount = this.itemMap.getColumnLength(columnIndex) - stopIndex;\n        const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n        const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n        const visibleItem = (stopIndex + postPlaceholder) * this.itemMap.columns + columnIndex;\n        this.itemMap.updateItem(visibleItem);\n        for (let row = 0; row < stopIndex + postPlaceholder; row++) {\n            const itemIndex = this.itemMap.getItemIndexByPosition(columnIndex, row);\n            if (itemIndex >= 0 && itemIndex < this.props.itemCount) {\n                if (!this.preset.isBrick) {\n                    if (row < startIndex - prevPlaceholder) {\n                        row = startIndex - prevPlaceholder;\n                        continue;\n                    }\n                }\n                if (row < startIndex || row > stopIndex) {\n                    items.push(this.getRenderItemNode(itemIndex, 'placeholder'));\n                }\n                else {\n                    items.push(this.getRenderItemNode(itemIndex));\n                }\n            }\n        }\n        return React.createElement(this.preset.innerElement, columnProps, items);\n    }\n    render() {\n        const _a = omit(this.props, [\n            'item', 'itemCount', 'itemData', 'itemKey', 'useIsScrolling',\n            'innerElementType', 'innerTagName', 'itemElementType', 'itemTagName',\n            'outerElementType', 'outerTagName', 'onScrollToLower', 'onScrollToUpper',\n            'upperThreshold', 'lowerThreshold',\n            'position',\n        ]), { className, style, height, width, enhanced, outerWrapper, renderTop, renderBottom } = _a, rest = __rest(_a, [\"className\", \"style\", \"height\", \"width\", \"enhanced\", \"outerWrapper\", \"renderTop\", \"renderBottom\"]);\n        const { isScrolling, scrollOffset, scrollUpdateWasRequested } = this.state;\n        const estimatedHeight = convertNumber2PX(this.itemMap.maxColumnSize);\n        const outerProps = Object.assign(Object.assign({}, rest), { id: this.preset.id, className: classNames(className, 'virtual-waterfall'), onScroll: this._onScroll, ref: this._outerRefSetter, style: Object.assign({ height: convertNumber2PX(height), width: convertNumber2PX(width), overflow: 'auto', WebkitOverflowScrolling: 'touch', willChange: 'transform' }, style), enhanced, outerElementType: this.preset.outerElement, innerElementType: this.preset.innerElement, renderTop,\n            renderBottom });\n        if (!this.preset.enhanced) {\n            outerProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n        }\n        const columnNodes = [];\n        for (let i = 0; i < this.itemMap.columns; i++) {\n            columnNodes.push(this.getRenderColumnNode(i));\n        }\n        return React.createElement(outerWrapper || this.preset.outerElement, outerProps, React.createElement(this.preset.innerElement, {\n            key: `${this.preset.id}-wrapper`,\n            id: `${this.preset.id}-wrapper`,\n            className: classNames(className, 'virtual-waterfall-wrapper'),\n            style: Object.assign({ display: 'flex', justifyContent: 'space-evenly', pointerEvents: isScrolling ? 'none' : 'auto', position: 'relative', height: estimatedHeight, width: '100%' }, style),\n        }, columnNodes));\n    }\n}\nWaterfall.defaultProps = {\n    itemData: undefined,\n    overscanDistance: 50,\n    useIsScrolling: false,\n    shouldResetStyleCacheOnItemSizeChange: true\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return Waterfall; } });\n//# sourceMappingURL=waterfall.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/index.js');\nvar __TEMP__ = require('../../../utils/convert.js');var convertPX2Int = __TEMP__['convertPX2Int'];\n\nfunction getRenderExpandNodes({ direction, id: sid, innerElement, renderExpand, }) {\n    const id = `${sid}-${direction}`;\n    const props = {\n        key: id,\n        id,\n    };\n    if (!renderExpand) {\n        props.style = {\n            visibility: 'hidden',\n            height: 100,\n            marginTop: -100,\n            zIndex: -1,\n        };\n    }\n    return React.createElement(renderExpand || innerElement, props);\n}\nconst outerWrapper = React.forwardRef(function OuterWrapper(props, ref) {\n    const _a = props, { id, className, style, children, outerElementType, innerElementType, onScroll, onScrollNative, renderTop, renderBottom } = _a, rest = __rest(_a, [\"id\", \"className\", \"style\", \"children\", \"outerElementType\", \"innerElementType\", \"onScroll\", \"onScrollNative\", \"renderTop\", \"renderBottom\"]);\n    const handleScroll = (event) => {\n        onScroll === null || onScroll === void 0 ? void 0 : onScroll(Object.assign(Object.assign({}, event), { currentTarget: Object.assign(Object.assign({}, event.detail), { clientWidth: convertPX2Int(style.width), clientHeight: convertPX2Int(style.height) }) }));\n        if (typeof onScrollNative === 'function') {\n            onScrollNative(event);\n        }\n    };\n    return React.createElement(outerElementType, Object.assign({ ref,\n        id,\n        className,\n        style, scrollY: true, onScroll: handleScroll }, rest), [\n        getRenderExpandNodes({\n            direction: 'top',\n            id,\n            innerElement: innerElementType,\n            renderExpand: renderTop,\n        }),\n        children,\n        getRenderExpandNodes({\n            direction: 'bottom',\n            id,\n            innerElement: innerElementType,\n            renderExpand: renderBottom,\n        }),\n    ]);\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return outerWrapper; } });\n//# sourceMappingURL=wrapper.js.map\n"]}