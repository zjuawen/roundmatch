{"version":3,"sources":["runtime.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('@tarojs/shared');var noop = __TEMP__['noop'];var isFunction = __TEMP__['isFunction'];var getComponentsAlias$1 = __TEMP__['getComponentsAlias'];var internalComponents = __TEMP__['internalComponents'];var EMPTY_OBJ = __TEMP__['EMPTY_OBJ'];var hooks = __TEMP__['hooks'];var toCamelCase = __TEMP__['toCamelCase'];var isObject = __TEMP__['isObject'];var warn = __TEMP__['warn'];var isArray = __TEMP__['isArray'];var ensure = __TEMP__['ensure'];var isNull = __TEMP__['isNull'];var isUndefined = __TEMP__['isUndefined'];var toDashed = __TEMP__['toDashed'];var isString = __TEMP__['isString'];var controlledComponent = __TEMP__['controlledComponent'];var Events = __TEMP__['Events'];var isNumber = __TEMP__['isNumber'];var EventChannel = __TEMP__['EventChannel'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('@tarojs/shared');Object.defineProperty(exports, 'Events', { enumerable: true, configurable: true, get: function() { return __TEMP__.Events; } });Object.defineProperty(exports, 'hooks', { enumerable: true, configurable: true, get: function() { return __TEMP__.hooks; } });\nvar __TEMP__ = require('tslib');var __classPrivateFieldGet = __TEMP__['__classPrivateFieldGet'];var __classPrivateFieldSet = __TEMP__['__classPrivateFieldSet'];\n\nconst PROPERTY_THRESHOLD = 2046;\nconst TARO_RUNTIME = 'Taro runtime';\nconst HOOKS_APP_ID = 'taro-app';\nconst SET_DATA = '小程序 setData';\nconst PAGE_INIT = '页面初始化';\nconst ROOT_STR = 'root';\nconst HTML = 'html';\nconst HEAD = 'head';\nconst BODY = 'body';\nconst APP = 'app';\nconst CONTAINER = 'container';\nconst DOCUMENT_ELEMENT_NAME = '#document';\nconst DOCUMENT_FRAGMENT = 'document-fragment';\nconst ID = 'id';\nconst UID = 'uid';\nconst CLASS = 'class';\nconst STYLE = 'style';\nconst FOCUS = 'focus';\nconst VIEW = 'view';\nconst STATIC_VIEW = 'static-view';\nconst PURE_VIEW = 'pure-view';\nconst PROPS = 'props';\nconst DATASET = 'dataset';\nconst OBJECT = 'object';\nconst VALUE = 'value';\nconst INPUT = 'input';\nconst CHANGE = 'change';\nconst CUSTOM_WRAPPER = 'custom-wrapper';\nconst TARGET = 'target';\nconst CURRENT_TARGET = 'currentTarget';\nconst TYPE = 'type';\nconst CONFIRM = 'confirm';\nconst TIME_STAMP = 'timeStamp';\nconst KEY_CODE = 'keyCode';\nconst TOUCHMOVE = 'touchmove';\nconst DATE = 'Date';\nconst SET_TIMEOUT = 'setTimeout';\nconst COMPILE_MODE = 'compileMode';\nconst CATCHMOVE = 'catchMove';\nconst CATCH_VIEW = 'catch-view';\nconst COMMENT = 'comment';\nconst ON_LOAD = 'onLoad';\nconst ON_READY = 'onReady';\nconst ON_SHOW = 'onShow';\nconst ON_HIDE = 'onHide';\nconst OPTIONS = 'options';\nconst EXTERNAL_CLASSES = 'externalClasses';\nconst EVENT_CALLBACK_RESULT = 'e_result';\nconst BEHAVIORS = 'behaviors';\nconst A = 'a';\n/**\n * 页面上下文切换时的行为\n */\nvar CONTEXT_ACTIONS;\n(function (CONTEXT_ACTIONS) {\n    CONTEXT_ACTIONS[\"INIT\"] = \"0\";\n    CONTEXT_ACTIONS[\"RESTORE\"] = \"1\";\n    CONTEXT_ACTIONS[\"RECOVER\"] = \"2\";\n    CONTEXT_ACTIONS[\"DESTORY\"] = \"3\";\n})(CONTEXT_ACTIONS || (CONTEXT_ACTIONS = {}));\n\nconst observers = [];\n/**\n * The MutationObserver provides the ability\n * to watch for changes being made to the DOM tree.\n * It will invoke a specified callback function\n * when DOM changes occur.\n * @see https://dom.spec.whatwg.org/#mutationobserver\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n */\nclass MutationObserverImpl {\n    constructor(callback) {\n        this.records = [];\n        this.callback = callback;\n    }\n    /**\n     * Configures the MutationObserver\n     * to begin receiving notifications\n     * through its callback function\n     * when DOM changes matching the given options occur.\n     *\n     * Options matching is to be implemented.\n     */\n    observe(target, options) {\n        this.disconnect();\n        this.target = target;\n        this.options = options || {};\n        observers.push(this);\n    }\n    /**\n     * Stop the MutationObserver instance\n     * from receiving further notifications\n     * until and unless observe() is called again.\n     */\n    disconnect() {\n        this.target = null;\n        const index = observers.indexOf(this);\n        if (index >= 0) {\n            observers.splice(index, 1);\n        }\n    }\n    /**\n     * Removes all pending notifications\n     * from the MutationObserver's notification queue\n     * and returns them in a new Array of MutationRecord objects.\n     */\n    takeRecords() {\n        return this.records.splice(0, this.records.length);\n    }\n}\n/** Match two TaroNodes by sid. */\nconst sidMatches = (observerTarget, target) => {\n    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);\n};\nconst isConcerned = (record, options) => {\n    const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options;\n    switch (record.type) {\n        case \"characterData\" /* MutationRecordType.CHARACTER_DATA */:\n            if (characterData) {\n                if (!characterDataOldValue)\n                    record.oldValue = null;\n                return true;\n            }\n            return false;\n        case \"attributes\" /* MutationRecordType.ATTRIBUTES */:\n            if (attributes) {\n                if (!attributeOldValue)\n                    record.oldValue = null;\n                return true;\n            }\n            return false;\n        case \"childList\" /* MutationRecordType.CHILD_LIST */:\n            if (childList) {\n                return true;\n            }\n            return false;\n    }\n};\nlet pendingMuatations = false;\nfunction logMutation(observer, record) {\n    observer.records.push(record);\n    if (!pendingMuatations) {\n        pendingMuatations = true;\n        Promise\n            .resolve()\n            .then(() => {\n            pendingMuatations = false;\n            observers.forEach(observer => {\n                return observer.callback(observer.takeRecords());\n            });\n        });\n    }\n}\nfunction recordMutation(record) {\n    observers.forEach(observer => {\n        const { options } = observer;\n        for (let t = record.target; t; t = t.parentNode) {\n            if (sidMatches(observer.target, t) && isConcerned(record, options)) {\n                logMutation(observer, record);\n                break;\n            }\n            if (!options.subtree)\n                break;\n        }\n    });\n}\n\nlet MutationObserver$1 = class MutationObserver {\n    constructor(callback) {\n        if (ENABLE_MUTATION_OBSERVER) {\n            this.core = new MutationObserverImpl(callback);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                console.warn('[Taro Warning] 若要使用 MutationObserver，请在 Taro 编译配置中设置 \\'mini.runtime.enableMutationObserver: true\\'');\n            }\n            this.core = {\n                observe: noop,\n                disconnect: noop,\n                takeRecords: noop\n            };\n        }\n    }\n    observe(...args) {\n        this.core.observe(...args);\n    }\n    disconnect() {\n        this.core.disconnect();\n    }\n    takeRecords() {\n        return this.core.takeRecords();\n    }\n    static record(record) {\n        recordMutation(record);\n    }\n};\n\nfunction throttle(fn, threshold = 250, scope) {\n    let lastTime = 0;\n    let deferTimer;\n    return function (...args) {\n        const context = scope || this;\n        const now = Date.now();\n        if (now - lastTime > threshold) {\n            fn.apply(this, args);\n            lastTime = now;\n        }\n        else {\n            clearTimeout(deferTimer);\n            deferTimer = setTimeout(() => {\n                lastTime = now;\n                fn.apply(context, args);\n            }, threshold);\n        }\n    };\n}\n\nconst incrementId = () => {\n    const chatCodes = [];\n    // A-Z\n    for (let i = 65; i <= 90; i++) {\n        chatCodes.push(i);\n    }\n    // a-z\n    for (let i = 97; i <= 122; i++) {\n        chatCodes.push(i);\n    }\n    const chatCodesLen = chatCodes.length - 1;\n    const list = [0, 0];\n    return () => {\n        const target = list.map(item => chatCodes[item]);\n        const res = String.fromCharCode(...target);\n        let tailIdx = list.length - 1;\n        list[tailIdx]++;\n        while (list[tailIdx] > chatCodesLen) {\n            list[tailIdx] = 0;\n            tailIdx = tailIdx - 1;\n            if (tailIdx < 0) {\n                list.push(0);\n                break;\n            }\n            list[tailIdx]++;\n        }\n        return res;\n    };\n};\nfunction isElement(node) {\n    return node.nodeType === 1 /* NodeType.ELEMENT_NODE */;\n}\nfunction isText(node) {\n    return node.nodeType === 3 /* NodeType.TEXT_NODE */;\n}\nfunction isComment(node) {\n    return node.nodeName === COMMENT;\n}\nfunction isHasExtractProp(el) {\n    const res = Object.keys(el.props).find(prop => {\n        return !(/^(class|style|id)$/.test(prop) || prop.startsWith('data-'));\n    });\n    return Boolean(res);\n}\n/**\n * 往上寻找组件树直到 root，寻找是否有祖先组件绑定了同类型的事件\n * @param node 当前组件\n * @param type 事件类型\n */\nfunction isParentBinded(node, type) {\n    var _a;\n    while ((node = (node === null || node === void 0 ? void 0 : node.parentElement) || null)) {\n        if (!node || node.nodeName === ROOT_STR || node.nodeName === 'root-portal') {\n            return false;\n        }\n        else if ((_a = node.__handlers[type]) === null || _a === void 0 ? void 0 : _a.length) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction shortcutAttr(key) {\n    switch (key) {\n        case STYLE:\n            return \"st\" /* Shortcuts.Style */;\n        case ID:\n            return UID;\n        case CLASS:\n            return \"cl\" /* Shortcuts.Class */;\n        default:\n            return key;\n    }\n}\nconst customWrapperCache = new Map();\nfunction extend(ctor, methodName, options) {\n    if (isFunction(options)) {\n        options = {\n            value: options\n        };\n    }\n    Object.defineProperty(ctor.prototype, methodName, Object.assign({ configurable: true, enumerable: true }, options));\n}\nlet componentsAlias$1;\nfunction getComponentsAlias() {\n    if (!componentsAlias$1) {\n        componentsAlias$1 = getComponentsAlias$1(internalComponents);\n    }\n    return componentsAlias$1;\n}\n\nclass ClassList {\n    constructor(className, el) {\n        this.tokenList = [];\n        this.el = el;\n        className.trim().split(/\\s+/).forEach(token => this.tokenList.push(token));\n    }\n    get value() {\n        return this.toString();\n    }\n    get length() {\n        return this.tokenList.length;\n    }\n    add() {\n        let index = 0;\n        let updated = false;\n        const tokens = arguments;\n        const length = tokens.length;\n        const tokenList = this.tokenList;\n        do {\n            const token = tokens[index];\n            if (this.checkTokenIsValid(token) && !~tokenList.indexOf(token)) {\n                tokenList.push(token);\n                updated = true;\n            }\n        } while (++index < length);\n        if (updated) {\n            this._update();\n        }\n    }\n    remove() {\n        let i = 0;\n        let updated = false;\n        const tokens = arguments;\n        const length = tokens.length;\n        const tokenList = this.tokenList;\n        do {\n            const token = tokens[i] + '';\n            if (!this.checkTokenIsValid(token))\n                continue;\n            const index = tokenList.indexOf(token);\n            if (~tokenList.indexOf(token)) {\n                tokenList.splice(index, 1);\n                updated = true;\n            }\n        } while (++i < length);\n        if (updated) {\n            this._update();\n        }\n    }\n    contains(token) {\n        if (!this.checkTokenIsValid(token))\n            return false;\n        return !!~this.tokenList.indexOf(token);\n    }\n    toggle(token, force) {\n        const result = this.contains(token);\n        const method = result ? force !== true && 'remove' : force !== false && 'add';\n        if (method) {\n            // @ts-ignore\n            this[method](token);\n        }\n        if (force === true || force === false) {\n            return force;\n        }\n        else {\n            return !result;\n        }\n    }\n    replace(token, replacement_token) {\n        if (!this.checkTokenIsValid(token) || !this.checkTokenIsValid(replacement_token))\n            return;\n        const index = this.tokenList.indexOf(token);\n        if (~index) {\n            this.tokenList.splice(index, 1, replacement_token);\n            this._update();\n        }\n    }\n    toString() {\n        return this.tokenList.filter(v => v !== '').join(' ');\n    }\n    checkTokenIsValid(token) {\n        if (token === '' || /\\s/.test(token))\n            return false;\n        return true;\n    }\n    _update() {\n        this.el.className = this.value;\n    }\n}\n\nclass EventSource extends Map {\n    removeNode(child) {\n        const { sid, uid } = child;\n        this.delete(sid);\n        if (uid !== sid && uid)\n            this.delete(uid);\n    }\n    removeNodeTree(child) {\n        this.removeNode(child);\n        const { childNodes } = child;\n        childNodes.forEach(node => this.removeNodeTree(node));\n    }\n}\nconst eventSource = new EventSource();\n\nconst env = {\n    window: process.env.TARO_PLATFORM === 'web' ? window : EMPTY_OBJ,\n    document: process.env.TARO_PLATFORM === 'web' ? document : EMPTY_OBJ\n};\n\nlet SPECIAL_NODES;\nlet componentsAlias;\n/**\n * React also has a fancy function's name for this: `hydrate()`.\n * You may have been heard `hydrate` as a SSR-related function,\n * actually, `hydrate` basicly do the `render()` thing, but ignore some properties,\n * it's a vnode traverser and modifier: that's exactly what Taro's doing in here.\n */\nfunction hydrate(node) {\n    var _a;\n    // 初始化 componentsAlias\n    componentsAlias || (componentsAlias = getComponentsAlias());\n    // 初始化 SPECIAL_NODES\n    SPECIAL_NODES || (SPECIAL_NODES = hooks.call('getSpecialNodes'));\n    const nodeName = node.nodeName;\n    let compileModeName = null;\n    if (isText(node)) {\n        return {\n            sid: node.sid,\n            [\"v\" /* Shortcuts.Text */]: node.nodeValue,\n            [\"nn\" /* Shortcuts.NodeName */]: ((_a = componentsAlias[nodeName]) === null || _a === void 0 ? void 0 : _a._num) || '8'\n        };\n    }\n    const data = {\n        [\"nn\" /* Shortcuts.NodeName */]: nodeName,\n        sid: node.sid\n    };\n    if (node.uid !== node.sid) {\n        data.uid = node.uid;\n    }\n    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {\n        data[\"nn\" /* Shortcuts.NodeName */] = `static-${nodeName}`;\n        if (nodeName === VIEW && !isHasExtractProp(node)) {\n            data[\"nn\" /* Shortcuts.NodeName */] = PURE_VIEW;\n        }\n    }\n    const { props } = node;\n    for (const prop in props) {\n        const propInCamelCase = toCamelCase(prop);\n        if (!prop.startsWith('data-') && // 在 node.dataset 的数据\n            prop !== CLASS &&\n            prop !== STYLE &&\n            prop !== ID &&\n            propInCamelCase !== CATCHMOVE &&\n            propInCamelCase !== COMPILE_MODE) {\n            data[propInCamelCase] = props[prop];\n        }\n        if (process.env.TARO_ENV !== 'swan' &&\n            nodeName === VIEW &&\n            propInCamelCase === CATCHMOVE &&\n            props[prop] !== false) {\n            data[\"nn\" /* Shortcuts.NodeName */] = CATCH_VIEW;\n        }\n        if (propInCamelCase === COMPILE_MODE) {\n            compileModeName = props[prop];\n        }\n    }\n    // Children\n    data[\"cn\" /* Shortcuts.Childnodes */] = node.childNodes.filter(node => !isComment(node)).map(hydrate);\n    if (node.className !== '') {\n        data[\"cl\" /* Shortcuts.Class */] = node.className;\n    }\n    const cssText = node.cssText;\n    if (cssText !== '' && nodeName !== 'swiper-item') {\n        data[\"st\" /* Shortcuts.Style */] = cssText;\n    }\n    hooks.call('modifyHydrateData', data, node);\n    const nn = data[\"nn\" /* Shortcuts.NodeName */];\n    const componentAlias = componentsAlias[nn];\n    if (componentAlias) {\n        data[\"nn\" /* Shortcuts.NodeName */] = componentAlias._num;\n        for (const prop in data) {\n            if (prop in componentAlias) {\n                data[componentAlias[prop]] = data[prop];\n                delete data[prop];\n            }\n        }\n    }\n    if (compileModeName !== null) {\n        data[\"nn\" /* Shortcuts.NodeName */] = compileModeName;\n    }\n    const resData = hooks.call('transferHydrateData', data, node, componentAlias);\n    return resData || data;\n}\n\nclass TaroEventTarget {\n    constructor() {\n        this.__handlers = {};\n    }\n    addEventListener(type, handler, options) {\n        type = type.toLowerCase();\n        hooks.call('onAddEvent', type, handler, options, this);\n        if (type === 'regionchange') {\n            // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766\n            this.addEventListener('begin', handler, options);\n            this.addEventListener('end', handler, options);\n            return;\n        }\n        let isCapture = Boolean(options);\n        let isOnce = false;\n        if (isObject(options)) {\n            isCapture = Boolean(options.capture);\n            isOnce = Boolean(options.once);\n        }\n        if (isOnce) {\n            const wrapper = function () {\n                handler.apply(this, arguments); // this 指向 Element\n                this.removeEventListener(type, wrapper);\n            };\n            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options), { once: false }));\n            return;\n        }\n        process.env.NODE_ENV !== 'production' && warn(isCapture, 'Taro 暂未实现 event 的 capture 特性。');\n        // 某些框架，如 PReact 有委托的机制，handler 始终是同一个函数\n        // 这会导致多层停止冒泡失败：view -> view(handler.stop = false) -> view(handler.stop = true)\n        // 这样解决：view -> view(handlerA.stop = false) -> view(handlerB.stop = false)\n        // 因此每次绑定事件都新建一个函数，如果带来了性能问题，可以把这段逻辑抽取到 PReact 插件中。\n        const oldHandler = handler;\n        handler = function () {\n            return oldHandler.apply(this, arguments); // this 指向 Element\n        };\n        handler.oldHandler = oldHandler;\n        const handlers = this.__handlers[type];\n        if (isArray(handlers)) {\n            handlers.push(handler);\n        }\n        else {\n            this.__handlers[type] = [handler];\n        }\n    }\n    removeEventListener(type, handler) {\n        type = type.toLowerCase();\n        if (type === 'regionchange') {\n            // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766\n            this.removeEventListener('begin', handler);\n            this.removeEventListener('end', handler);\n            return;\n        }\n        if (!handler) {\n            return;\n        }\n        const handlers = this.__handlers[type];\n        if (!isArray(handlers)) {\n            return;\n        }\n        const index = handlers.findIndex(item => {\n            if (item === handler || item.oldHandler === handler)\n                return true;\n        });\n        process.env.NODE_ENV !== 'production' && warn(index === -1, `事件: '${type}' 没有注册在 DOM 中，因此不会被移除。`);\n        handlers.splice(index, 1);\n    }\n    isAnyEventBinded() {\n        const handlers = this.__handlers;\n        const isAnyEventBinded = Object.keys(handlers).find(key => handlers[key].length);\n        return Boolean(isAnyEventBinded);\n    }\n}\n\nconst CHILDNODES = \"cn\" /* Shortcuts.Childnodes */;\nconst nodeId = incrementId();\nclass TaroNode extends TaroEventTarget {\n    constructor() {\n        super();\n        this.parentNode = null;\n        this.childNodes = [];\n        this.hydrate = (node) => () => hydrate(node);\n        this.uid = '_' + nodeId(); // dom 节点 id，开发者可修改\n        this.sid = this.uid; // dom 节点全局唯一 id，不可被修改\n        eventSource.set(this.sid, this);\n    }\n    updateChildNodes(isClean) {\n        const cleanChildNodes = () => [];\n        const rerenderChildNodes = () => {\n            const childNodes = this.childNodes.filter(node => !isComment(node));\n            return childNodes.map(hydrate);\n        };\n        this.enqueueUpdate({\n            path: `${this._path}.${CHILDNODES}`,\n            value: isClean ? cleanChildNodes : rerenderChildNodes\n        });\n    }\n    updateSingleChild(index) {\n        this.childNodes.forEach((child, childIndex) => {\n            if (isComment(child))\n                return;\n            if (index && childIndex < index)\n                return;\n            this.enqueueUpdate({\n                path: child._path,\n                value: this.hydrate(child)\n            });\n        });\n    }\n    get _root() {\n        var _a;\n        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a._root) || null;\n    }\n    findIndex(refChild) {\n        const index = this.childNodes.indexOf(refChild);\n        ensure(index !== -1, 'The node to be replaced is not a child of this node.');\n        return index;\n    }\n    get _path() {\n        const parentNode = this.parentNode;\n        if (parentNode) {\n            // 计算路径时，先过滤掉 comment 节点\n            const list = parentNode.childNodes.filter(node => !isComment(node));\n            const indexOfNode = list.indexOf(this);\n            const index = hooks.call('getPathIndex', indexOfNode);\n            return `${parentNode._path}.${CHILDNODES}.${index}`;\n        }\n        return '';\n    }\n    get nextSibling() {\n        const parentNode = this.parentNode;\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;\n    }\n    get previousSibling() {\n        const parentNode = this.parentNode;\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;\n    }\n    get parentElement() {\n        const parentNode = this.parentNode;\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1 /* NodeType.ELEMENT_NODE */) {\n            return parentNode;\n        }\n        return null;\n    }\n    get firstChild() {\n        return this.childNodes[0] || null;\n    }\n    get lastChild() {\n        const childNodes = this.childNodes;\n        return childNodes[childNodes.length - 1] || null;\n    }\n    /**\n     * @textContent 目前只能置空子元素\n     * @TODO 等待完整 innerHTML 实现\n     */\n    // eslint-disable-next-line accessor-pairs\n    set textContent(text) {\n        const removedNodes = this.childNodes.slice();\n        const addedNodes = [];\n        // Handle old children' data structure & ref\n        while (this.firstChild) {\n            this.removeChild(this.firstChild, { doUpdate: false });\n        }\n        if (text === '') {\n            this.updateChildNodes(true);\n        }\n        else {\n            const newText = env.document.createTextNode(text);\n            addedNodes.push(newText);\n            this.appendChild(newText);\n            this.updateChildNodes();\n        }\n        // @Todo: appendChild 会多触发一次\n        MutationObserver$1.record({\n            type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n            target: this,\n            removedNodes,\n            addedNodes\n        });\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore\n     * @scenario\n     * [A,B,C]\n     *   1. insert D before C, D has no parent\n     *   2. insert D before C, D has the same parent of C\n     *   3. insert D before C, D has the different parent of C\n     */\n    insertBefore(newChild, refChild, isReplace) {\n        if (newChild.nodeName === DOCUMENT_FRAGMENT) {\n            newChild.childNodes.reduceRight((previousValue, currentValue) => {\n                this.insertBefore(currentValue, previousValue);\n                return currentValue;\n            }, refChild);\n            return newChild;\n        }\n        // Parent release newChild\n        //   - cleanRef: false (No need to clean eventSource, because newChild is about to be inserted)\n        //   - update: true (Need to update parent.childNodes, because parent.childNodes is reordered)\n        newChild.remove({ cleanRef: false });\n        let index = 0;\n        // Data structure\n        newChild.parentNode = this;\n        if (refChild) {\n            // insertBefore & replaceChild\n            index = this.findIndex(refChild);\n            this.childNodes.splice(index, 0, newChild);\n        }\n        else {\n            // appendChild\n            this.childNodes.push(newChild);\n        }\n        const childNodesLength = this.childNodes.length;\n        // Serialization\n        if (this._root) {\n            if (!refChild) {\n                // appendChild\n                const isOnlyChild = childNodesLength === 1;\n                if (isOnlyChild) {\n                    this.updateChildNodes();\n                }\n                else {\n                    this.enqueueUpdate({\n                        path: newChild._path,\n                        value: this.hydrate(newChild)\n                    });\n                }\n            }\n            else if (isReplace) {\n                // replaceChild\n                this.enqueueUpdate({\n                    path: newChild._path,\n                    value: this.hydrate(newChild)\n                });\n            }\n            else {\n                // insertBefore 有两种更新模式\n                // 比方说有 A B C 三个节点，现在要在 C 前插入 D\n                // 1. 插入 D，然后更新整个父节点的 childNodes 数组\n                // setData({ cn: [A, B, D, C] })\n                // 2. 插入 D，然后更新 D 以及 D 之后每个节点的数据\n                // setData ({\n                //   cn.[2]: D,\n                //   cn.[3]: C,\n                // })\n                // 由于微信解析 ’cn.[2]‘ 这些路径的时候也需要消耗时间，\n                // 所以根据 insertBefore 插入的位置来做不同的处理\n                const mark = childNodesLength * 2 / 3;\n                if (mark > index) {\n                    // 如果 insertBefore 的位置在 childNodes 的 2/3 前，则为了避免解析路径消耗过多的时间，采用第一种方式\n                    this.updateChildNodes();\n                }\n                else {\n                    // 如果 insertBefore 的位置在 childNodes 的 2/3 之后，则采用第二种方式，避免 childNodes 的全量更新\n                    this.updateSingleChild(index);\n                }\n            }\n        }\n        MutationObserver$1.record({\n            type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n            target: this,\n            addedNodes: [newChild],\n            removedNodes: isReplace\n                ? [refChild] /** replaceChild */\n                : [],\n            nextSibling: isReplace\n                ? refChild.nextSibling /** replaceChild */\n                : (refChild || null),\n            previousSibling: newChild.previousSibling\n        });\n        return newChild;\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild\n     * @scenario\n     * [A,B,C]\n     *   1. append C, C has no parent\n     *   2. append C, C has the same parent of B\n     *   3. append C, C has the different parent of B\n     */\n    appendChild(newChild) {\n        return this.insertBefore(newChild);\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild\n     * @scenario\n     * [A,B,C]\n     *   1. replace B with C, C has no parent\n     *   2. replace B with C, C has no parent, C has the same parent of B\n     *   3. replace B with C, C has no parent, C has the different parent of B\n     */\n    replaceChild(newChild, oldChild) {\n        if (oldChild.parentNode !== this)\n            return;\n        // Insert the newChild\n        this.insertBefore(newChild, oldChild, true);\n        // Destroy the oldChild\n        //   - cleanRef: true (Need to clean eventSource, because the oldChild was detached from the DOM tree)\n        //   - update: false (No need to update parent.childNodes, because replace will not cause the parent.childNodes being reordered)\n        oldChild.remove({ doUpdate: false });\n        return oldChild;\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild\n     * @scenario\n     * [A,B,C]\n     *   1. remove A or B\n     *   2. remove C\n     */\n    removeChild(child, options = {}) {\n        const { cleanRef, doUpdate } = options;\n        if (cleanRef !== false && doUpdate !== false) {\n            // appendChild/replaceChild/insertBefore 不应该触发\n            // @Todo: 但其实如果 newChild 的父节点是另一颗子树的节点，应该是要触发的\n            MutationObserver$1.record({\n                type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n                target: this,\n                removedNodes: [child],\n                nextSibling: child.nextSibling,\n                previousSibling: child.previousSibling\n            });\n        }\n        // Data Structure\n        const index = this.findIndex(child);\n        this.childNodes.splice(index, 1);\n        child.parentNode = null;\n        // Set eventSource\n        if (cleanRef !== false) {\n            eventSource.removeNodeTree(child);\n        }\n        // Serialization\n        if (this._root && doUpdate !== false) {\n            this.updateChildNodes();\n        }\n        return child;\n    }\n    remove(options) {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this, options);\n    }\n    hasChildNodes() {\n        return this.childNodes.length > 0;\n    }\n    enqueueUpdate(payload) {\n        var _a;\n        (_a = this._root) === null || _a === void 0 ? void 0 : _a.enqueueUpdate(payload);\n    }\n    get ownerDocument() {\n        return env.document;\n    }\n    static extend(methodName, options) {\n        extend(TaroNode, methodName, options);\n    }\n}\n\n/*\n *\n * https://www.w3.org/Style/CSS/all-properties.en.html\n */\nconst WEBKIT = 'webkit';\nconst styleProperties = [\n    'all',\n    'appearance',\n    'blockOverflow',\n    'blockSize',\n    'bottom',\n    'clear',\n    'contain',\n    'content',\n    'continue',\n    'cursor',\n    'direction',\n    'display',\n    'filter',\n    'float',\n    'gap',\n    'height',\n    'inset',\n    'isolation',\n    'left',\n    'letterSpacing',\n    'lightingColor',\n    'markerSide',\n    'mixBlendMode',\n    'opacity',\n    'order',\n    'position',\n    'quotes',\n    'resize',\n    'right',\n    'rowGap',\n    'tabSize',\n    'tableLayout',\n    'top',\n    'userSelect',\n    'verticalAlign',\n    'visibility',\n    'voiceFamily',\n    'volume',\n    'whiteSpace',\n    'widows',\n    'width',\n    'zIndex',\n    'pointerEvents',\n    'aspectRatio'\n    /** 非常用 style */\n    // 'azimuth',\n    // 'backfaceVisibility',\n    // 'baselineShift',\n    // 'captionSide',\n    // 'chains',\n    // 'dominantBaseline',\n    // 'elevation',\n    // 'emptyCells',\n    // 'forcedColorAdjust',\n    // 'glyphOrientationVertical',\n    // 'hangingPunctuation',\n    // 'hyphenateCharacter',\n    // 'hyphens',\n    // 'imageOrientation',\n    // 'imageResolution',\n    // 'orphans',\n    // 'playDuring',\n    // 'pointerEvents',\n    // 'regionFragment',\n    // 'richness',\n    // 'running',\n    // 'scrollBehavior',\n    // 'speechRate',\n    // 'stress',\n    // 'stringSet',\n    // 'unicodeBidi',\n    // 'willChange',\n    // 'writingMode',\n];\n// 减少文件体积\nfunction combine(prefix, list, excludeSelf) {\n    !excludeSelf && styleProperties.push(prefix);\n    list.forEach(item => {\n        styleProperties.push(prefix + item);\n        if (prefix === WEBKIT) {\n            styleProperties.push('Webkit' + item);\n        }\n    });\n}\nconst color = 'Color';\nconst style = 'Style';\nconst width = 'Width';\nconst image = 'Image';\nconst size = 'Size';\nconst color_style_width = [color, style, width];\nconst fitlength_fitwidth_image = ['FitLength', 'FitWidth', image];\nconst fitlength_fitwidth_image_radius = [...fitlength_fitwidth_image, 'Radius'];\nconst color_style_width_fitlength_fitwidth_image = [...color_style_width, ...fitlength_fitwidth_image];\nconst endRadius_startRadius = ['EndRadius', 'StartRadius'];\nconst bottom_left_right_top = ['Bottom', 'Left', 'Right', 'Top'];\nconst end_start = ['End', 'Start'];\nconst content_items_self = ['Content', 'Items', 'Self'];\nconst blockSize_height_inlineSize_width = ['BlockSize', 'Height', 'InlineSize', width];\nconst after_before = ['After', 'Before'];\ncombine('borderBlock', color_style_width);\ncombine('borderBlockEnd', color_style_width);\ncombine('borderBlockStart', color_style_width);\ncombine('outline', [...color_style_width, 'Offset']);\ncombine('border', [...color_style_width, 'Boundary', 'Break', 'Collapse', 'Radius', 'Spacing']);\ncombine('borderFit', ['Length', width]);\ncombine('borderInline', color_style_width);\ncombine('borderInlineEnd', color_style_width);\ncombine('borderInlineStart', color_style_width);\ncombine('borderLeft', color_style_width_fitlength_fitwidth_image);\ncombine('borderRight', color_style_width_fitlength_fitwidth_image);\ncombine('borderTop', color_style_width_fitlength_fitwidth_image);\ncombine('borderBottom', color_style_width_fitlength_fitwidth_image);\ncombine('textDecoration', [color, style, 'Line']);\ncombine('textEmphasis', [color, style, 'Position']);\ncombine('scrollMargin', bottom_left_right_top);\ncombine('scrollPadding', bottom_left_right_top);\ncombine('padding', bottom_left_right_top);\ncombine('margin', [...bottom_left_right_top, 'Trim']);\ncombine('scrollMarginBlock', end_start);\ncombine('scrollMarginInline', end_start);\ncombine('scrollPaddingBlock', end_start);\ncombine('scrollPaddingInline', end_start);\ncombine('gridColumn', end_start);\ncombine('gridRow', end_start);\ncombine('insetBlock', end_start);\ncombine('insetInline', end_start);\ncombine('marginBlock', end_start);\ncombine('marginInline', end_start);\ncombine('paddingBlock', end_start);\ncombine('paddingInline', end_start);\ncombine('pause', after_before);\ncombine('cue', after_before);\ncombine('mask', ['Clip', 'Composite', image, 'Mode', 'Origin', 'Position', 'Repeat', size, 'Type']);\ncombine('borderImage', ['Outset', 'Repeat', 'Slice', 'Source', 'Transform', width]);\ncombine('maskBorder', ['Mode', 'Outset', 'Repeat', 'Slice', 'Source', width]);\ncombine('font', ['Family', 'FeatureSettings', 'Kerning', 'LanguageOverride', 'MaxSize', 'MinSize', 'OpticalSizing', 'Palette', size, 'SizeAdjust', 'Stretch', style, 'Weight', 'VariationSettings']);\ncombine('transform', ['Box', 'Origin', style]);\ncombine('background', [color, image, 'Attachment', 'BlendMode', 'Clip', 'Origin', 'Position', 'Repeat', size]);\ncombine('listStyle', [image, 'Position', 'Type']);\ncombine('scrollSnap', ['Align', 'Stop', 'Type']);\ncombine('grid', ['Area', 'AutoColumns', 'AutoFlow', 'AutoRows']);\ncombine('gridTemplate', ['Areas', 'Columns', 'Rows']);\ncombine('overflow', ['Block', 'Inline', 'Wrap', 'X', 'Y']);\ncombine('transition', ['Delay', 'Duration', 'Property', 'TimingFunction']);\ncombine('color', ['Adjust', 'InterpolationFilters', 'Scheme']);\ncombine('textAlign', ['All', 'Last']);\ncombine('page', ['BreakAfter', 'BreakBefore', 'BreakInside']);\ncombine('animation', ['Delay', 'Direction', 'Duration', 'FillMode', 'IterationCount', 'Name', 'PlayState', 'TimingFunction']);\ncombine('flex', ['Basis', 'Direction', 'Flow', 'Grow', 'Shrink', 'Wrap']);\ncombine('offset', [...after_before, ...end_start, 'Anchor', 'Distance', 'Path', 'Position', 'Rotate']);\ncombine('perspective', ['Origin']);\ncombine('clip', ['Path', 'Rule']);\ncombine('flow', ['From', 'Into']);\ncombine('align', ['Content', 'Items', 'Self'], true);\ncombine('alignment', ['Adjust', 'Baseline'], true);\ncombine('borderStart', endRadius_startRadius, true);\ncombine('borderEnd', endRadius_startRadius, true);\ncombine('borderCorner', ['Fit', image, 'ImageTransform'], true);\ncombine('borderTopLeft', fitlength_fitwidth_image_radius, true);\ncombine('borderTopRight', fitlength_fitwidth_image_radius, true);\ncombine('borderBottomLeft', fitlength_fitwidth_image_radius, true);\ncombine('borderBottomRight', fitlength_fitwidth_image_radius, true);\ncombine('column', ['s', 'Count', 'Fill', 'Gap', 'Rule', 'RuleColor', 'RuleStyle', 'RuleWidth', 'Span', width], true);\ncombine('break', [...after_before, 'Inside'], true);\ncombine('wrap', [...after_before, 'Flow', 'Inside', 'Through'], true);\ncombine('justify', content_items_self, true);\ncombine('place', content_items_self, true);\ncombine('max', [...blockSize_height_inlineSize_width, 'Lines'], true);\ncombine('min', blockSize_height_inlineSize_width, true);\ncombine('line', ['Break', 'Clamp', 'Grid', 'Height', 'Padding', 'Snap'], true);\ncombine('inline', ['BoxAlign', size, 'Sizing'], true);\ncombine('text', ['CombineUpright', 'GroupAlign', 'Height', 'Indent', 'Justify', 'Orientation', 'Overflow', 'Shadow', 'SpaceCollapse', 'SpaceTrim', 'Spacing', 'Transform', 'UnderlinePosition', 'Wrap'], true);\ncombine('shape', ['ImageThreshold', 'Inside', 'Margin', 'Outside'], true);\ncombine('word', ['Break', 'Spacing', 'Wrap'], true);\ncombine('object', ['Fit', 'Position'], true);\ncombine('box', ['DecorationBreak', 'Shadow', 'Sizing', 'Snap'], true);\ncombine(WEBKIT, ['LineClamp', 'BoxOrient', 'TextFillColor', 'TextStroke', 'TextStrokeColor', 'TextStrokeWidth'], true);\n\nfunction recordCss(obj) {\n    MutationObserver$1.record({\n        type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n        target: obj._element,\n        attributeName: 'style',\n        oldValue: obj.cssText\n    });\n}\nfunction enqueueUpdate(obj) {\n    const element = obj._element;\n    if (element._root) {\n        element.enqueueUpdate({\n            path: `${element._path}.${\"st\" /* Shortcuts.Style */}`,\n            value: obj.cssText\n        });\n    }\n}\nfunction setStyle(newVal, styleKey) {\n    process.env.NODE_ENV !== 'production' && warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style 属性 ${styleKey} 的值数据量过大，可能会影响渲染性能，考虑使用 CSS 类或其它方案替代。`);\n    const old = this[styleKey];\n    if (old === newVal)\n        return;\n    !this._pending && recordCss(this);\n    if (isNull(newVal) || isUndefined(newVal) || newVal === '') {\n        this._usedStyleProp.delete(styleKey);\n        delete this._value[styleKey];\n    }\n    else {\n        this._usedStyleProp.add(styleKey);\n        this._value[styleKey] = newVal;\n    }\n    !this._pending && enqueueUpdate(this);\n}\nfunction initStyle(ctor, styleProperties) {\n    const properties = {};\n    for (let i = 0; i < styleProperties.length; i++) {\n        const styleKey = styleProperties[i];\n        if (ctor[styleKey])\n            return;\n        properties[styleKey] = {\n            get() {\n                const val = this._value[styleKey];\n                return isNull(val) || isUndefined(val) ? '' : val;\n            },\n            set(newVal) {\n                setStyle.call(this, newVal, styleKey);\n            }\n        };\n    }\n    Object.defineProperties(ctor.prototype, properties);\n}\nfunction isCssVariable(propertyName) {\n    return /^--/.test(propertyName);\n}\nclass Style {\n    constructor(element) {\n        this._element = element;\n        this._usedStyleProp = new Set();\n        this._value = {};\n    }\n    setCssVariables(styleKey) {\n        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {\n            enumerable: true,\n            configurable: true,\n            get: () => {\n                return this._value[styleKey] || '';\n            },\n            set: (newVal) => {\n                setStyle.call(this, newVal, styleKey);\n            }\n        });\n    }\n    get cssText() {\n        if (!this._usedStyleProp.size)\n            return '';\n        const texts = [];\n        this._usedStyleProp.forEach(key => {\n            const val = this[key];\n            if (isNull(val) || isUndefined(val))\n                return;\n            let styleName = isCssVariable(key) ? key : toDashed(key);\n            if (styleName.indexOf('webkit') === 0 || styleName.indexOf('Webkit') === 0) {\n                styleName = `-${styleName}`;\n            }\n            texts.push(`${styleName}: ${val};`);\n        });\n        return texts.join(' ');\n    }\n    set cssText(str) {\n        this._pending = true;\n        recordCss(this);\n        this._usedStyleProp.forEach(prop => {\n            this.removeProperty(prop);\n        });\n        if (str === '' || isUndefined(str) || isNull(str)) {\n            this._pending = false;\n            enqueueUpdate(this);\n            return;\n        }\n        const rules = str.split(';');\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i].trim();\n            if (rule === '') {\n                continue;\n            }\n            // 可能存在 'background: url(http:x/y/z)' 的情况\n            const [propName, ...valList] = rule.split(':');\n            const val = valList.join(':');\n            if (isUndefined(val)) {\n                continue;\n            }\n            this.setProperty(propName.trim(), val.trim());\n        }\n        this._pending = false;\n        enqueueUpdate(this);\n    }\n    setProperty(propertyName, value) {\n        if (propertyName[0] === '-') {\n            // 支持 webkit 属性或 css 变量\n            this.setCssVariables(propertyName);\n        }\n        else {\n            propertyName = toCamelCase(propertyName);\n        }\n        if (isNull(value) || isUndefined(value)) {\n            this.removeProperty(propertyName);\n        }\n        else {\n            this[propertyName] = value;\n        }\n    }\n    removeProperty(propertyName) {\n        propertyName = toCamelCase(propertyName);\n        if (!this._usedStyleProp.has(propertyName)) {\n            return '';\n        }\n        const value = this[propertyName];\n        this[propertyName] = undefined;\n        return value;\n    }\n    getPropertyValue(propertyName) {\n        propertyName = toCamelCase(propertyName);\n        const value = this[propertyName];\n        if (!value) {\n            return '';\n        }\n        return value;\n    }\n}\ninitStyle(Style, styleProperties);\nhooks.tap('injectNewStyleProperties', (newStyleProperties) => {\n    if (isArray(newStyleProperties)) {\n        initStyle(Style, newStyleProperties);\n    }\n    else {\n        if (typeof newStyleProperties !== 'string')\n            return;\n        initStyle(Style, [newStyleProperties]);\n    }\n});\n\nfunction returnTrue() {\n    return true;\n}\nfunction treeToArray(root, predict) {\n    const array = [];\n    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;\n    let object = root;\n    while (object) {\n        if (object.nodeType === 1 /* NodeType.ELEMENT_NODE */ && filter(object)) {\n            array.push(object);\n        }\n        object = following(object, root);\n    }\n    return array;\n}\nfunction following(el, root) {\n    const firstChild = el.firstChild;\n    const isElmentTypeValid = el.nodeType === 1 /* NodeType.ELEMENT_NODE */ || el.nodeType === 9 /* NodeType.DOCUMENT_NODE */;\n    // 如果当前 el 不是 element 或 document 元素，则可以直接不递归他的子元素了\n    if (firstChild && isElmentTypeValid) {\n        return firstChild;\n    }\n    let current = el;\n    do {\n        if (current === root) {\n            return null;\n        }\n        const nextSibling = current.nextSibling;\n        if (nextSibling) {\n            return nextSibling;\n        }\n        current = current.parentElement;\n    } while (current);\n    return null;\n}\n\nclass TaroElement extends TaroNode {\n    constructor() {\n        super();\n        this.props = {};\n        this.dataset = EMPTY_OBJ;\n        this.nodeType = 1 /* NodeType.ELEMENT_NODE */;\n        this.style = new Style(this);\n        hooks.call('patchElement', this);\n    }\n    _stopPropagation(event) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let target = this;\n        // eslint-disable-next-line no-cond-assign\n        while ((target = target.parentNode)) {\n            const listeners = target.__handlers[event.type];\n            if (!isArray(listeners)) {\n                continue;\n            }\n            for (let i = listeners.length; i--;) {\n                const l = listeners[i];\n                l._stop = true;\n            }\n        }\n    }\n    get id() {\n        return this.getAttribute(ID);\n    }\n    set id(val) {\n        this.setAttribute(ID, val);\n    }\n    get className() {\n        return this.getAttribute(CLASS) || '';\n    }\n    set className(val) {\n        this.setAttribute(CLASS, val);\n    }\n    get cssText() {\n        return this.getAttribute(STYLE) || '';\n    }\n    get classList() {\n        return new ClassList(this.className, this);\n    }\n    get children() {\n        return this.childNodes.filter(isElement);\n    }\n    get attributes() {\n        const props = this.props;\n        const propKeys = Object.keys(props);\n        const style = this.style.cssText;\n        const attrs = propKeys.map(key => ({ name: key, value: props[key] }));\n        return attrs.concat(style ? { name: STYLE, value: style } : []);\n    }\n    get textContent() {\n        let text = '';\n        const childNodes = this.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            text += childNodes[i].textContent;\n        }\n        return text;\n    }\n    set textContent(text) {\n        super.textContent = text;\n    }\n    hasAttribute(qualifiedName) {\n        return !isUndefined(this.props[qualifiedName]);\n    }\n    hasAttributes() {\n        return this.attributes.length > 0;\n    }\n    get focus() {\n        return function () {\n            this.setAttribute(FOCUS, true);\n        };\n    }\n    // 兼容 Vue3，详情请见：https://github.com/NervJS/taro/issues/10579\n    set focus(value) {\n        this.setAttribute(FOCUS, value);\n    }\n    blur() {\n        this.setAttribute(FOCUS, false);\n    }\n    setAttribute(qualifiedName, value) {\n        process.env.NODE_ENV !== 'production' && warn(isString(value) && value.length > PROPERTY_THRESHOLD, `元素 ${this.nodeName} 的 ${qualifiedName} 属性值数据量过大，可能会影响渲染性能。考虑降低图片转为 base64 的阈值或在 CSS 中使用 base64。`);\n        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();\n        if (qualifiedName !== STYLE) {\n            MutationObserver$1.record({\n                target: this,\n                type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n                attributeName: qualifiedName,\n                oldValue: this.getAttribute(qualifiedName)\n            });\n        }\n        switch (qualifiedName) {\n            case STYLE:\n                this.style.cssText = value;\n                break;\n            case ID:\n                if (this.uid !== this.sid) {\n                    // eventSource[sid] 永远保留，直到组件卸载\n                    // eventSource[uid] 可变\n                    eventSource.delete(this.uid);\n                }\n                value = String(value);\n                this.props[qualifiedName] = this.uid = value;\n                eventSource.set(value, this);\n                break;\n            default:\n                this.props[qualifiedName] = value;\n                if (qualifiedName.startsWith('data-')) {\n                    if (this.dataset === EMPTY_OBJ) {\n                        this.dataset = Object.create(null);\n                    }\n                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ''))] = value;\n                }\n                break;\n        }\n        // Serialization\n        if (!this._root)\n            return;\n        const componentsAlias = getComponentsAlias();\n        const _alias = componentsAlias[this.nodeName];\n        const viewAlias = componentsAlias[VIEW]._num;\n        const staticViewAlias = componentsAlias[STATIC_VIEW]._num;\n        const catchViewAlias = componentsAlias[CATCH_VIEW]._num;\n        const _path = this._path;\n        qualifiedName = shortcutAttr(qualifiedName);\n        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);\n        const payload = {\n            path: `${_path}.${qualifiedNameInCamelCase}`,\n            value: isFunction(value) ? () => value : value\n        };\n        hooks.call('modifySetAttrPayload', this, qualifiedName, payload, componentsAlias);\n        if (_alias) {\n            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;\n            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;\n        }\n        this.enqueueUpdate(payload);\n        if (this.nodeName === VIEW) {\n            if (qualifiedNameInCamelCase === CATCHMOVE) {\n                // catchMove = true: catch-view\n                // catchMove = false: view or static-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: value ? catchViewAlias : (this.isAnyEventBinded() ? viewAlias : staticViewAlias)\n                });\n            }\n            else if (isPureView && isHasExtractProp(this)) {\n                // pure-view => static-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: staticViewAlias\n                });\n            }\n        }\n    }\n    removeAttribute(qualifiedName) {\n        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();\n        MutationObserver$1.record({\n            target: this,\n            type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n            attributeName: qualifiedName,\n            oldValue: this.getAttribute(qualifiedName)\n        });\n        if (qualifiedName === STYLE) {\n            this.style.cssText = '';\n        }\n        else {\n            const isInterrupt = hooks.call('onRemoveAttribute', this, qualifiedName);\n            if (isInterrupt) {\n                return;\n            }\n            if (!this.props.hasOwnProperty(qualifiedName)) {\n                return;\n            }\n            delete this.props[qualifiedName];\n        }\n        // Serialization\n        if (!this._root)\n            return;\n        const componentsAlias = getComponentsAlias();\n        const _alias = componentsAlias[this.nodeName];\n        const viewAlias = componentsAlias[VIEW]._num;\n        const staticViewAlias = componentsAlias[STATIC_VIEW]._num;\n        const pureViewAlias = componentsAlias[PURE_VIEW]._num;\n        const _path = this._path;\n        qualifiedName = shortcutAttr(qualifiedName);\n        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);\n        const payload = {\n            path: `${_path}.${qualifiedNameInCamelCase}`,\n            value: ''\n        };\n        hooks.call('modifyRmAttrPayload', this, qualifiedName, payload, componentsAlias);\n        if (_alias) {\n            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;\n            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;\n        }\n        this.enqueueUpdate(payload);\n        if (this.nodeName === VIEW) {\n            if (qualifiedNameInCamelCase === CATCHMOVE) {\n                // catch-view => view or static-view or pure-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: this.isAnyEventBinded() ? viewAlias : (isHasExtractProp(this) ? staticViewAlias : pureViewAlias)\n                });\n            }\n            else if (isStaticView && !isHasExtractProp(this)) {\n                // static-view => pure-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: pureViewAlias\n                });\n            }\n        }\n    }\n    getAttribute(qualifiedName) {\n        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];\n        return attr !== null && attr !== void 0 ? attr : '';\n    }\n    getElementsByTagName(tagName) {\n        return treeToArray(this, (el) => {\n            return el.nodeName === tagName || (tagName === '*' && this !== el);\n        });\n    }\n    getElementsByClassName(className) {\n        const classNames = className.trim().split(/\\s+/);\n        return treeToArray(this, (el) => {\n            const classList = el.classList;\n            return classNames.every(c => classList.contains(c));\n        });\n    }\n    dispatchEvent(event) {\n        const cancelable = event.cancelable;\n        const listeners = this.__handlers[event.type];\n        if (!isArray(listeners)) {\n            return false;\n        }\n        for (let i = listeners.length; i--;) {\n            const listener = listeners[i];\n            let result;\n            if (listener._stop) {\n                listener._stop = false;\n            }\n            else {\n                hooks.call('modifyDispatchEvent', event, this);\n                result = listener.call(this, event);\n            }\n            if ((result === false || event._end) && cancelable) {\n                event.defaultPrevented = true;\n            }\n            if (!isUndefined(result) && event.mpEvent) {\n                const res = hooks.call('modifyTaroEventReturn', this, event, result);\n                if (res) {\n                    event.mpEvent[EVENT_CALLBACK_RESULT] = result;\n                }\n            }\n            if (event._end && event._stop) {\n                break;\n            }\n        }\n        if (event._stop) {\n            this._stopPropagation(event);\n        }\n        else {\n            event._stop = true;\n        }\n        return listeners != null;\n    }\n    addEventListener(type, handler, options) {\n        const name = this.nodeName;\n        const SPECIAL_NODES = hooks.call('getSpecialNodes');\n        let sideEffect = true;\n        if (isObject(options) && options.sideEffect === false) {\n            sideEffect = false;\n            delete options.sideEffect;\n        }\n        hooks.call('modifyAddEventListener', this, sideEffect, getComponentsAlias);\n        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\n            const componentsAlias = getComponentsAlias();\n            const alias = componentsAlias[name]._num;\n            this.enqueueUpdate({\n                path: `${this._path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                value: alias\n            });\n        }\n        super.addEventListener(type, handler, options);\n    }\n    removeEventListener(type, handler, sideEffect = true) {\n        super.removeEventListener(type, handler);\n        const name = this.nodeName;\n        const SPECIAL_NODES = hooks.call('getSpecialNodes');\n        hooks.call('modifyRemoveEventListener', this, sideEffect, getComponentsAlias);\n        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\n            const componentsAlias = getComponentsAlias();\n            const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;\n            const valueAlias = componentsAlias[value]._num;\n            this.enqueueUpdate({\n                path: `${this._path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                value: valueAlias\n            });\n        }\n    }\n    static extend(methodName, options) {\n        extend(TaroElement, methodName, options);\n    }\n}\n\nconst options = {\n    prerender: true,\n    debug: false\n};\n\nfunction initPosition() {\n    return {\n        index: 0,\n        column: 0,\n        line: 0\n    };\n}\nfunction feedPosition(position, str, len) {\n    const start = position.index;\n    const end = position.index = start + len;\n    for (let i = start; i < end; i++) {\n        const char = str.charAt(i);\n        if (char === '\\n') {\n            position.line++;\n            position.column = 0;\n        }\n        else {\n            position.column++;\n        }\n    }\n}\nfunction jumpPosition(position, str, end) {\n    const len = end - position.index;\n    return feedPosition(position, str, len);\n}\nfunction copyPosition(position) {\n    return {\n        index: position.index,\n        line: position.line,\n        column: position.column\n    };\n}\nconst whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n    return whitespace.test(char);\n}\nconst equalSign = /=/;\nfunction isEqualSignChar(char) {\n    return equalSign.test(char);\n}\nfunction shouldBeIgnore(tagName) {\n    const name = tagName.toLowerCase();\n    if (options.html.skipElements.has(name)) {\n        return true;\n    }\n    return false;\n}\nconst alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n    while (true) {\n        const textEnd = str.indexOf('<', index);\n        if (textEnd === -1) {\n            return textEnd;\n        }\n        const char = str.charAt(textEnd + 1);\n        if (char === '/' || char === '!' || alphanumeric.test(char)) {\n            return textEnd;\n        }\n        index = textEnd + 1;\n    }\n}\nfunction isWordEnd(cursor, wordBegin, html) {\n    if (!isWhitespaceChar(html.charAt(cursor)))\n        return false;\n    const len = html.length;\n    // backwrad\n    for (let i = cursor - 1; i > wordBegin; i--) {\n        const char = html.charAt(i);\n        if (!isWhitespaceChar(char)) {\n            if (isEqualSignChar(char))\n                return false;\n            break;\n        }\n    }\n    // forward\n    for (let i = cursor + 1; i < len; i++) {\n        const char = html.charAt(i);\n        if (!isWhitespaceChar(char)) {\n            if (isEqualSignChar(char))\n                return false;\n            return true;\n        }\n    }\n}\nclass Scaner {\n    constructor(html) {\n        this.tokens = [];\n        this.position = initPosition();\n        this.html = html;\n    }\n    scan() {\n        const { html, position } = this;\n        const len = html.length;\n        while (position.index < len) {\n            const start = position.index;\n            this.scanText();\n            if (position.index === start) {\n                const isComment = html.startsWith('!--', start + 1);\n                if (isComment) {\n                    this.scanComment();\n                }\n                else {\n                    const tagName = this.scanTag();\n                    if (shouldBeIgnore(tagName)) {\n                        this.scanSkipTag(tagName);\n                    }\n                }\n            }\n        }\n        return this.tokens;\n    }\n    scanText() {\n        const type = 'text';\n        const { html, position } = this;\n        let textEnd = findTextEnd(html, position.index);\n        if (textEnd === position.index) {\n            return;\n        }\n        if (textEnd === -1) {\n            textEnd = html.length;\n        }\n        const start = copyPosition(position);\n        const content = html.slice(position.index, textEnd);\n        jumpPosition(position, html, textEnd);\n        const end = copyPosition(position);\n        this.tokens.push({ type, content, position: { start, end } });\n    }\n    scanComment() {\n        const type = 'comment';\n        const { html, position } = this;\n        const start = copyPosition(position);\n        feedPosition(position, html, 4); // \"<!--\".length\n        let contentEnd = html.indexOf('-->', position.index);\n        let commentEnd = contentEnd + 3; // \"-->\".length\n        if (contentEnd === -1) {\n            contentEnd = commentEnd = html.length;\n        }\n        const content = html.slice(position.index, contentEnd);\n        jumpPosition(position, html, commentEnd);\n        this.tokens.push({\n            type,\n            content,\n            position: {\n                start,\n                end: copyPosition(position)\n            }\n        });\n    }\n    scanTag() {\n        this.scanTagStart();\n        const tagName = this.scanTagName();\n        this.scanAttrs();\n        this.scanTagEnd();\n        return tagName;\n    }\n    scanTagStart() {\n        const type = 'tag-start';\n        const { html, position } = this;\n        const secondChar = html.charAt(position.index + 1);\n        const close = secondChar === '/';\n        const start = copyPosition(position);\n        feedPosition(position, html, close ? 2 : 1);\n        this.tokens.push({ type, close, position: { start } });\n    }\n    scanTagEnd() {\n        const type = 'tag-end';\n        const { html, position } = this;\n        const firstChar = html.charAt(position.index);\n        const close = firstChar === '/';\n        feedPosition(position, html, close ? 2 : 1);\n        const end = copyPosition(position);\n        this.tokens.push({ type, close, position: { end } });\n    }\n    scanTagName() {\n        const type = 'tag';\n        const { html, position } = this;\n        const len = html.length;\n        let start = position.index;\n        while (start < len) {\n            const char = html.charAt(start);\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n            if (isTagChar)\n                break;\n            start++;\n        }\n        let end = start + 1;\n        while (end < len) {\n            const char = html.charAt(end);\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n            if (!isTagChar)\n                break;\n            end++;\n        }\n        jumpPosition(position, html, end);\n        const tagName = html.slice(start, end);\n        this.tokens.push({\n            type,\n            content: tagName\n        });\n        return tagName;\n    }\n    scanAttrs() {\n        const { html, position, tokens } = this;\n        let cursor = position.index;\n        let quote = null; // null, single-, or double-quote\n        let wordBegin = cursor; // index of word start\n        const words = []; // \"key\", \"key=value\", \"key='value'\", etc\n        const len = html.length;\n        while (cursor < len) {\n            const char = html.charAt(cursor);\n            if (quote) {\n                const isQuoteEnd = char === quote;\n                if (isQuoteEnd) {\n                    quote = null;\n                }\n                cursor++;\n                continue;\n            }\n            const isTagEnd = char === '/' || char === '>';\n            if (isTagEnd) {\n                if (cursor !== wordBegin) {\n                    words.push(html.slice(wordBegin, cursor));\n                }\n                break;\n            }\n            if (isWordEnd(cursor, wordBegin, html)) {\n                if (cursor !== wordBegin) {\n                    words.push(html.slice(wordBegin, cursor));\n                }\n                wordBegin = cursor + 1;\n                cursor++;\n                continue;\n            }\n            const isQuoteStart = char === '\\'' || char === '\"';\n            if (isQuoteStart) {\n                quote = char;\n                cursor++;\n                continue;\n            }\n            cursor++;\n        }\n        jumpPosition(position, html, cursor);\n        const wLen = words.length;\n        const type = 'attribute';\n        for (let i = 0; i < wLen; i++) {\n            const word = words[i];\n            const isNotPair = word.includes('=');\n            if (isNotPair) {\n                const secondWord = words[i + 1];\n                if (secondWord && secondWord.startsWith('=')) {\n                    if (secondWord.length > 1) {\n                        const newWord = word + secondWord;\n                        tokens.push({ type, content: newWord });\n                        i += 1;\n                        continue;\n                    }\n                    const thirdWord = words[i + 2];\n                    i += 1;\n                    if (thirdWord) {\n                        const newWord = word + '=' + thirdWord;\n                        tokens.push({ type, content: newWord });\n                        i += 1;\n                        continue;\n                    }\n                }\n            }\n            if (word.endsWith('=')) {\n                const secondWord = words[i + 1];\n                if (secondWord && !secondWord.includes('=')) {\n                    const newWord = word + secondWord;\n                    tokens.push({ type, content: newWord });\n                    i += 1;\n                    continue;\n                }\n                const newWord = word.slice(0, -1);\n                tokens.push({ type, content: newWord });\n                continue;\n            }\n            tokens.push({ type, content: word });\n        }\n    }\n    scanSkipTag(tagName) {\n        const { html, position } = this;\n        const safeTagName = tagName.toLowerCase();\n        const len = html.length;\n        while (position.index < len) {\n            const nextTag = html.indexOf('</', position.index);\n            if (nextTag === -1) {\n                this.scanText();\n                break;\n            }\n            jumpPosition(position, html, nextTag);\n            const name = this.scanTag();\n            if (safeTagName === name.toLowerCase()) {\n                break;\n            }\n        }\n    }\n}\n\nfunction unquote(str) {\n    const car = str.charAt(0);\n    const end = str.length - 1;\n    const isQuoteStart = car === '\"' || car === \"'\";\n    if (isQuoteStart && car === str.charAt(end)) {\n        return str.slice(1, end);\n    }\n    return str;\n}\n\nconst LEFT_BRACKET = '{';\nconst RIGHT_BRACKET = '}';\nconst CLASS_SELECTOR = '.';\nconst ID_SELECTOR = '#';\nconst CHILD_COMBINATOR = '>';\nconst GENERAL_SIBLING_COMBINATOR = '~';\nconst ADJACENT_SIBLING_COMBINATOR = '+';\nclass StyleTagParser {\n    constructor() {\n        this.styles = [];\n    }\n    extractStyle(src) {\n        const REG_STYLE = /<style\\s?[^>]*>((.|\\n|\\s)+?)<\\/style>/g;\n        let html = src;\n        // let html = src.replace(/\\n/g, '')\n        html = html.replace(REG_STYLE, (_, $1) => {\n            const style = $1.trim();\n            this.stringToSelector(style);\n            return '';\n        });\n        return html.trim();\n    }\n    stringToSelector(style) {\n        let lb = style.indexOf(LEFT_BRACKET);\n        while (lb > -1) {\n            const rb = style.indexOf(RIGHT_BRACKET);\n            const selectors = style.slice(0, lb).trim();\n            let content = style.slice(lb + 1, rb);\n            content = content.replace(/:(.*);/g, function (_, $1) {\n                const t = $1.trim().replace(/ +/g, '+++');\n                return `:${t};`;\n            });\n            content = content.replace(/ /g, '');\n            content = content.replace(/\\+\\+\\+/g, ' ');\n            if (!(/;$/.test(content))) {\n                content += ';';\n            }\n            selectors.split(',').forEach(src => {\n                const selectorList = this.parseSelector(src);\n                this.styles.push({\n                    content,\n                    selectorList\n                });\n            });\n            style = style.slice(rb + 1);\n            lb = style.indexOf(LEFT_BRACKET);\n        }\n        // console.log('res this.styles: ', this.styles)\n    }\n    parseSelector(src) {\n        const list = src\n            .trim()\n            .replace(/ *([>~+]) */g, ' $1')\n            .replace(/ +/g, ' ')\n            .replace(/\\[\\s*([^[\\]=\\s]+)\\s*=\\s*([^[\\]=\\s]+)\\s*\\]/g, '[$1=$2]')\n            .split(' ');\n        const selectors = list.map(item => {\n            const firstChar = item.charAt(0);\n            const selector = {\n                isChild: firstChar === CHILD_COMBINATOR,\n                isGeneralSibling: firstChar === GENERAL_SIBLING_COMBINATOR,\n                isAdjacentSibling: firstChar === ADJACENT_SIBLING_COMBINATOR,\n                tag: null,\n                id: null,\n                class: [],\n                attrs: []\n            };\n            item = item.replace(/^[>~+]/, '');\n            // 属性选择器\n            item = item.replace(/\\[(.+?)\\]/g, function (_, $1) {\n                const [key, value] = $1.split('=');\n                const all = $1.indexOf('=') === -1;\n                const attr = {\n                    all,\n                    key,\n                    value: all ? null : value\n                };\n                selector.attrs.push(attr);\n                return '';\n            });\n            item = item.replace(/([.#][A-Za-z0-9-_]+)/g, function (_, $1) {\n                if ($1[0] === ID_SELECTOR) {\n                    // id 选择器\n                    selector.id = $1.substr(1);\n                }\n                else if ($1[0] === CLASS_SELECTOR) {\n                    // class 选择器\n                    selector.class.push($1.substr(1));\n                }\n                return '';\n            });\n            // 标签选择器\n            if (item !== '') {\n                selector.tag = item;\n            }\n            return selector;\n        });\n        return selectors;\n    }\n    matchStyle(tagName, el, list) {\n        const res = sortStyles(this.styles).reduce((str, { content, selectorList }, i) => {\n            let idx = list[i];\n            let selector = selectorList[idx];\n            const nextSelector = selectorList[idx + 1];\n            if ((nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isGeneralSibling) || (nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isAdjacentSibling)) {\n                selector = nextSelector;\n                idx += 1;\n                list[i] += 1;\n            }\n            let isMatch = this.matchCurrent(tagName, el, selector);\n            if (isMatch && selector.isGeneralSibling) {\n                let prev = getPreviousElement(el);\n                while (prev) {\n                    if (prev.h5tagName && this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1])) {\n                        isMatch = true;\n                        break;\n                    }\n                    prev = getPreviousElement(prev);\n                    isMatch = false;\n                }\n            }\n            if (isMatch && selector.isAdjacentSibling) {\n                const prev = getPreviousElement(el);\n                if (!prev || !prev.h5tagName) {\n                    isMatch = false;\n                }\n                else {\n                    const isSiblingMatch = this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1]);\n                    if (!isSiblingMatch) {\n                        isMatch = false;\n                    }\n                }\n            }\n            if (isMatch) {\n                if (idx === selectorList.length - 1) {\n                    return str + content;\n                }\n                else if (idx < selectorList.length - 1) {\n                    list[i] += 1;\n                }\n            }\n            else {\n                // 直接子代组合器: >\n                if (selector.isChild && idx > 0) {\n                    list[i] -= 1;\n                    if (this.matchCurrent(tagName, el, selectorList[list[i]])) {\n                        list[i] += 1;\n                    }\n                }\n            }\n            return str;\n        }, '');\n        return res;\n    }\n    matchCurrent(tagName, el, selector) {\n        // 标签选择器\n        if (selector.tag && selector.tag !== tagName)\n            return false;\n        // id 选择器\n        if (selector.id && selector.id !== el.id)\n            return false;\n        // class 选择器\n        if (selector.class.length) {\n            const classList = el.className.split(' ');\n            for (let i = 0; i < selector.class.length; i++) {\n                const cls = selector.class[i];\n                if (classList.indexOf(cls) === -1) {\n                    return false;\n                }\n            }\n        }\n        // 属性选择器\n        if (selector.attrs.length) {\n            for (let i = 0; i < selector.attrs.length; i++) {\n                const { all, key, value } = selector.attrs[i];\n                if (all && !el.hasAttribute(key)) {\n                    return false;\n                }\n                else {\n                    const attr = el.getAttribute(key);\n                    if (attr !== unquote(value || '')) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\nfunction getPreviousElement(el) {\n    const parent = el.parentElement;\n    if (!parent)\n        return null;\n    const prev = el.previousSibling;\n    if (!prev)\n        return null;\n    if (prev.nodeType === 1 /* NodeType.ELEMENT_NODE */) {\n        return prev;\n    }\n    else {\n        return getPreviousElement(prev);\n    }\n}\n// 根据 css selector 权重排序: 权重大的靠后\n// @WARN 不考虑伪类\n// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#specificity_2\nfunction sortStyles(styles) {\n    return styles.sort((s1, s2) => {\n        const hundreds1 = getHundredsWeight(s1.selectorList);\n        const hundreds2 = getHundredsWeight(s2.selectorList);\n        if (hundreds1 !== hundreds2)\n            return hundreds1 - hundreds2;\n        const tens1 = getTensWeight(s1.selectorList);\n        const tens2 = getTensWeight(s2.selectorList);\n        if (tens1 !== tens2)\n            return tens1 - tens2;\n        const ones1 = getOnesWeight(s1.selectorList);\n        const ones2 = getOnesWeight(s2.selectorList);\n        return ones1 - ones2;\n    });\n}\nfunction getHundredsWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + (cur.id ? 1 : 0), 0);\n}\nfunction getTensWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + cur.class.length + cur.attrs.length, 0);\n}\nfunction getOnesWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + (cur.tag ? 1 : 0), 0);\n}\n\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\nconst specialMiniElements = {\n    img: 'image',\n    iframe: 'web-view'\n};\nconst specialElements = new Map([\n    ['a', {\n            mapName(props) {\n                if (props.as && isString(props.as))\n                    return props.as.toLowerCase();\n                return !props.href || isString(props.href) && (/^javascript/.test(props.href)) ? 'view' : 'navigator';\n            }\n        }],\n]);\nconst getSpecialElementMapping = (tag, expectsLowerCase = true) => {\n    tag = expectsLowerCase ? tag.toLowerCase() : tag;\n    return specialElements.get(tag);\n};\nconst internalCompsList = Object.keys(internalComponents)\n    .map(i => i.toLowerCase())\n    .join(',');\n// https://developers.weixin.qq.com/miniprogram/dev/component\nconst isMiniElements = makeMap(internalCompsList, true);\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst isInlineElements = makeMap('i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b', true);\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst isBlockElements = makeMap('address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt', true);\n// specialElements\nconst isSpecialElements = makeMap('a', true);\n\nconst closingTagAncestorBreakers = {\n    li: ['ul', 'ol', 'menu'],\n    dt: ['dl'],\n    dd: ['dl'],\n    tbody: ['table'],\n    thead: ['table'],\n    tfoot: ['table'],\n    tr: ['table'],\n    td: ['table']\n};\nfunction hasTerminalParent(tagName, stack) {\n    const tagParents = closingTagAncestorBreakers[tagName];\n    if (tagParents) {\n        let currentIndex = stack.length - 1;\n        while (currentIndex >= 0) {\n            const parentTagName = stack[currentIndex].tagName;\n            if (parentTagName === tagName) {\n                break;\n            }\n            if (tagParents && tagParents.includes(parentTagName)) {\n                return true;\n            }\n            currentIndex--;\n        }\n    }\n    return false;\n}\n/**\n * 将属性数组转换为属性对象\n * @param attributes 字符串数组，包含属性信息\n * @returns 属性对象，键为属性名，值为属性值或true\n */\nfunction attributesArray2Props(attributes) {\n    const props = {};\n    for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        const [key, value] = splitEqual(attr);\n        props[key] = value == null ? true : unquote(value);\n    }\n    return props;\n}\nfunction getTagName(tag, attributes) {\n    if (options.html.renderHTMLTag) {\n        return tag;\n    }\n    if (specialMiniElements[tag]) {\n        return specialMiniElements[tag];\n    }\n    else if (isMiniElements(tag)) {\n        return tag;\n    }\n    else if (isBlockElements(tag)) {\n        return 'view';\n    }\n    else if (isInlineElements(tag)) {\n        return 'text';\n    }\n    else if (isSpecialElements(tag)) {\n        // if it's special tag, the real tag is determined by the config mapping\n        const mapping = getSpecialElementMapping(tag);\n        const props = attributesArray2Props(attributes);\n        if (mapping) {\n            return mapping.mapName(props);\n        }\n    }\n    return 'view';\n}\nfunction splitEqual(str) {\n    const sep = '=';\n    const idx = str.indexOf(sep);\n    if (idx === -1)\n        return [str];\n    const key = str.slice(0, idx).trim();\n    const value = str.slice(idx + sep.length).trim();\n    return [key, value];\n}\nfunction format(children, document, styleOptions, parent) {\n    return children\n        .filter(child => {\n        // 过滤注释和空文本节点\n        if (child.type === 'comment') {\n            return false;\n        }\n        else if (child.type === 'text') {\n            return child.content !== '';\n        }\n        return true;\n    })\n        .map((child) => {\n        // 文本节点\n        if (child.type === 'text') {\n            let text = document.createTextNode(child.content);\n            if (isFunction(options.html.transformText)) {\n                text = options.html.transformText(text, child);\n            }\n            parent === null || parent === void 0 ? void 0 : parent.appendChild(text);\n            return text;\n        }\n        // img标签,把width和height写入style,删除原有的width、height和style属性\n        if (child.tagName === 'img') {\n            let styleText = '';\n            const toBeRemovedIndexs = [];\n            for (let i = 0; i < child.attributes.length; i++) {\n                const attr = child.attributes[i];\n                const [key, value] = splitEqual(attr);\n                if (key === 'width' || key === 'height') {\n                    styleText += `${key}:${value};`;\n                    toBeRemovedIndexs.push(i);\n                }\n                else if (key === 'style') {\n                    styleText = `${styleText}${value};`;\n                    toBeRemovedIndexs.push(i);\n                }\n            }\n            child.attributes = child.attributes.filter((_, index) => !toBeRemovedIndexs.includes(index));\n            child.attributes.push(`style=${styleText.replace(/['\"]/g, '')}`);\n        }\n        const el = document.createElement(getTagName(child.tagName, child.attributes));\n        el.h5tagName = child.tagName;\n        parent === null || parent === void 0 ? void 0 : parent.appendChild(el);\n        if (!options.html.renderHTMLTag) {\n            el.className = `h5-${child.tagName}`;\n        }\n        for (let i = 0; i < child.attributes.length; i++) {\n            const attr = child.attributes[i];\n            const [key, value] = splitEqual(attr);\n            if (key === 'class') {\n                el.className += ' ' + unquote(value);\n            }\n            else if (key[0] === 'o' && key[1] === 'n') {\n                continue;\n            }\n            else {\n                el.setAttribute(key, value == null ? true : unquote(value));\n            }\n        }\n        const { styleTagParser, descendantList } = styleOptions;\n        const list = descendantList.slice();\n        const style = styleTagParser.matchStyle(child.tagName, el, list);\n        el.setAttribute('style', style + el.style.cssText);\n        // console.log('style, ', style)\n        format(child.children, document, {\n            styleTagParser,\n            descendantList: list\n        }, el);\n        if (isFunction(options.html.transformElement)) {\n            return options.html.transformElement(el, child);\n        }\n        return el;\n    });\n}\nfunction parser(html, document) {\n    const styleTagParser = new StyleTagParser();\n    html = styleTagParser.extractStyle(html);\n    const tokens = new Scaner(html).scan();\n    const root = { tagName: '', children: [], type: 'element', attributes: [] };\n    const state = { tokens, options, cursor: 0, stack: [root] };\n    parse(state);\n    return format(root.children, document, {\n        styleTagParser,\n        descendantList: Array(styleTagParser.styles.length).fill(0)\n    });\n}\nfunction parse(state) {\n    const { tokens, stack } = state;\n    let { cursor } = state;\n    const len = tokens.length;\n    let nodes = stack[stack.length - 1].children;\n    while (cursor < len) {\n        const token = tokens[cursor];\n        if (token.type !== 'tag-start') {\n            // comment or text\n            nodes.push(token);\n            cursor++;\n            continue;\n        }\n        const tagToken = tokens[++cursor];\n        cursor++;\n        const tagName = tagToken.content.toLowerCase();\n        if (token.close) {\n            let index = stack.length;\n            let shouldRewind = false;\n            while (--index > -1) {\n                if (stack[index].tagName === tagName) {\n                    shouldRewind = true;\n                    break;\n                }\n            }\n            while (cursor < len) {\n                const endToken = tokens[cursor];\n                if (endToken.type !== 'tag-end')\n                    break;\n                cursor++;\n            }\n            if (shouldRewind) {\n                stack.splice(index);\n                break;\n            }\n            else {\n                continue;\n            }\n        }\n        const isClosingTag = options.html.closingElements.has(tagName);\n        let shouldRewindToAutoClose = isClosingTag;\n        if (shouldRewindToAutoClose) {\n            shouldRewindToAutoClose = !hasTerminalParent(tagName, stack);\n        }\n        if (shouldRewindToAutoClose) {\n            let currentIndex = stack.length - 1;\n            while (currentIndex > 0) {\n                if (tagName === stack[currentIndex].tagName) {\n                    stack.splice(currentIndex);\n                    const previousIndex = currentIndex - 1;\n                    nodes = stack[previousIndex].children;\n                    break;\n                }\n                currentIndex = currentIndex - 1;\n            }\n        }\n        const attributes = [];\n        let attrToken;\n        while (cursor < len) {\n            attrToken = tokens[cursor];\n            if (attrToken.type === 'tag-end')\n                break;\n            attributes.push(attrToken.content);\n            cursor++;\n        }\n        cursor++;\n        const children = [];\n        const element = {\n            type: 'element',\n            tagName: tagToken.content,\n            attributes,\n            children\n        };\n        nodes.push(element);\n        const hasChildren = !(attrToken.close || options.html.voidElements.has(tagName));\n        if (hasChildren) {\n            stack.push({ tagName, children });\n            const innerState = { tokens, cursor, stack };\n            parse(innerState);\n            cursor = innerState.cursor;\n        }\n    }\n    state.cursor = cursor;\n}\n\noptions.html = {\n    skipElements: new Set(['style', 'script']),\n    voidElements: new Set([\n        '!doctype', 'area', 'base', 'br', 'col', 'command',\n        'embed', 'hr', 'img', 'input', 'keygen', 'link',\n        'meta', 'param', 'source', 'track', 'wbr'\n    ]),\n    closingElements: new Set([\n        'html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option',\n        'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'\n    ]),\n    renderHTMLTag: false\n};\nfunction setInnerHTML(element, html) {\n    while (element.firstChild) {\n        element.removeChild(element.firstChild);\n    }\n    const children = parser(html, element.ownerDocument);\n    for (let i = 0; i < children.length; i++) {\n        element.appendChild(children[i]);\n    }\n}\n\nfunction getBoundingClientRectImpl() {\n    if (!options.miniGlobal)\n        return Promise.resolve(null);\n    return new Promise(resolve => {\n        const query = options.miniGlobal.createSelectorQuery();\n        query.select(`#${this.uid}`).boundingClientRect(res => {\n            resolve(res);\n        }).exec();\n    });\n}\nfunction getTemplateContent(ctx) {\n    if (ctx.nodeName === 'template') {\n        const document = ctx.ownerDocument;\n        const content = document.createElement(DOCUMENT_FRAGMENT);\n        content.childNodes = ctx.childNodes;\n        ctx.childNodes = [content];\n        content.parentNode = ctx;\n        content.childNodes.forEach(nodes => {\n            nodes.parentNode = content;\n        });\n        return content;\n    }\n}\n\n/**\n * An implementation of `Element.insertAdjacentHTML()`\n * to support Vue 3 with a version of or greater than `vue@3.1.2`\n */\nfunction insertAdjacentHTML(position, html) {\n    var _a, _b;\n    const parsedNodes = parser(html, this.ownerDocument);\n    for (let i = 0; i < parsedNodes.length; i++) {\n        const n = parsedNodes[i];\n        switch (position) {\n            case 'beforebegin':\n                (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(n, this);\n                break;\n            case 'afterbegin':\n                if (this.hasChildNodes()) {\n                    this.insertBefore(n, this.childNodes[0]);\n                }\n                else {\n                    this.appendChild(n);\n                }\n                break;\n            case 'beforeend':\n                this.appendChild(n);\n                break;\n            case 'afterend':\n                (_b = this.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(n);\n                break;\n        }\n    }\n}\nfunction cloneNode(isDeep = false) {\n    const document = this.ownerDocument;\n    let newNode;\n    if (this.nodeType === 1 /* NodeType.ELEMENT_NODE */) {\n        newNode = document.createElement(this.nodeName);\n    }\n    else if (this.nodeType === 3 /* NodeType.TEXT_NODE */) {\n        newNode = document.createTextNode('');\n    }\n    for (const key in this) {\n        const value = this[key];\n        // eslint-disable-next-line valid-typeof\n        if ([PROPS, DATASET].includes(key) && typeof value === OBJECT) {\n            newNode[key] = Object.assign({}, value);\n        }\n        else if (key === '_value') {\n            newNode[key] = value;\n        }\n        else if (key === STYLE) {\n            newNode.style._value = Object.assign({}, value._value);\n            newNode.style._usedStyleProp = new Set(Array.from(value._usedStyleProp));\n        }\n    }\n    if (isDeep) {\n        newNode.childNodes = this.childNodes.map(node => node.cloneNode(true));\n    }\n    return newNode;\n}\nfunction contains(node) {\n    let isContains = false;\n    this.childNodes.some(childNode => {\n        const { uid } = childNode;\n        if (uid === node.uid || uid === node.id || childNode.contains(node)) {\n            isContains = true;\n            return true;\n        }\n    });\n    return isContains;\n}\n\nif (process.env.TARO_PLATFORM !== 'web') {\n    if (ENABLE_INNER_HTML) {\n        TaroNode.extend('innerHTML', {\n            set(html) {\n                setInnerHTML.call(this, this, html);\n            },\n            get() {\n                return '';\n            }\n        });\n        if (ENABLE_ADJACENT_HTML) {\n            TaroNode.extend('insertAdjacentHTML', insertAdjacentHTML);\n        }\n    }\n    if (ENABLE_CLONE_NODE) {\n        TaroNode.extend('cloneNode', cloneNode);\n    }\n    if (ENABLE_CONTAINS) {\n        TaroNode.extend('contains', contains);\n    }\n    if (ENABLE_SIZE_APIS) {\n        TaroElement.extend('getBoundingClientRect', getBoundingClientRectImpl);\n    }\n    if (ENABLE_TEMPLATE_CONTENT) {\n        TaroElement.extend('content', {\n            get() {\n                return getTemplateContent(this);\n            }\n        });\n    }\n}\n\n// Taro 事件对象。以 Web 标准的事件对象为基础，加入小程序事件对象中携带的部分信息，并模拟实现事件冒泡。\nclass TaroEvent {\n    constructor(type, opts, event) {\n        this._stop = false;\n        this._end = false;\n        this.defaultPrevented = false;\n        // Mouse Event botton property, it's used in 3rd lib, like react-router. default 0 in general\n        this.button = 0;\n        // timestamp can either be hi-res ( relative to page load) or low-res (relative to UNIX epoch)\n        // here use hi-res timestamp\n        this.timeStamp = Date.now();\n        this.type = type.toLowerCase();\n        this.mpEvent = event;\n        this.bubbles = Boolean(opts && opts.bubbles);\n        this.cancelable = Boolean(opts && opts.cancelable);\n    }\n    stopPropagation() {\n        this._stop = true;\n    }\n    stopImmediatePropagation() {\n        this._end = this._stop = true;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n    }\n    get target() {\n        var _a, _b, _c, _d, _e;\n        const cacheTarget = this.cacheTarget;\n        if (!cacheTarget) {\n            const target = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.target) || null);\n            const currentEle = env.document.getElementById(((_b = target.dataset) === null || _b === void 0 ? void 0 : _b.sid) || target.id || null);\n            // Note：优先判断冒泡场景alipay的targetDataset的sid, 不然冒泡场景target属性吐出不对，其余拿取当前绑定id\n            const element = env.document.getElementById(((_c = target.targetDataset) === null || _c === void 0 ? void 0 : _c.sid) || ((_d = target.dataset) === null || _d === void 0 ? void 0 : _d.sid) || target.id || null);\n            target.dataset = Object.assign(Object.assign({}, (currentEle !== null ? currentEle.dataset : EMPTY_OBJ)), (element !== null ? element.dataset : EMPTY_OBJ));\n            for (const key in (_e = this.mpEvent) === null || _e === void 0 ? void 0 : _e.detail) {\n                target[key] = this.mpEvent.detail[key];\n            }\n            this.cacheTarget = target;\n            return target;\n        }\n        else {\n            return cacheTarget;\n        }\n    }\n    get currentTarget() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const cacheCurrentTarget = this.cacheCurrentTarget;\n        if (!cacheCurrentTarget) {\n            const doc = env.document;\n            const currentTarget = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.currentTarget) || null);\n            const element = doc.getElementById(((_b = currentTarget.dataset) === null || _b === void 0 ? void 0 : _b.sid) || currentTarget.id || null);\n            const targetElement = doc.getElementById(((_e = (_d = (_c = this.mpEvent) === null || _c === void 0 ? void 0 : _c.target) === null || _d === void 0 ? void 0 : _d.dataset) === null || _e === void 0 ? void 0 : _e.sid) || ((_g = (_f = this.mpEvent) === null || _f === void 0 ? void 0 : _f.target) === null || _g === void 0 ? void 0 : _g.id) || null);\n            if (element === null || (element && element === targetElement)) {\n                this.cacheCurrentTarget = this.target;\n                return this.target;\n            }\n            currentTarget.dataset = element.dataset;\n            for (const key in (_h = this.mpEvent) === null || _h === void 0 ? void 0 : _h.detail) {\n                currentTarget[key] = this.mpEvent.detail[key];\n            }\n            this.cacheCurrentTarget = currentTarget;\n            return currentTarget;\n        }\n        else {\n            return cacheCurrentTarget;\n        }\n    }\n}\nfunction createEvent(event, node) {\n    if (typeof event === 'string') {\n        // For Vue3 using document.createEvent\n        return new TaroEvent(event, { bubbles: true, cancelable: true });\n    }\n    const domEv = new TaroEvent(event.type, { bubbles: true, cancelable: true }, event);\n    for (const key in event) {\n        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {\n            continue;\n        }\n        else {\n            domEv[key] = event[key];\n        }\n    }\n    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {\n        // eslint-disable-next-line dot-notation\n        domEv[KEY_CODE] = 13;\n    }\n    return domEv;\n}\nconst eventsBatch = {};\nfunction getEventCBResult(event) {\n    const result = event[EVENT_CALLBACK_RESULT];\n    if (!isUndefined(result)) {\n        delete event[EVENT_CALLBACK_RESULT];\n    }\n    return result;\n}\n// 小程序的事件代理回调函数\nfunction eventHandler(event) {\n    var _a, _b;\n    // Note: ohos 上事件没有设置 type、detail 类型 setter 方法，且部分事件（例如 load 等）缺失 target 导致事件错误\n    event.type === undefined && Object.defineProperty(event, 'type', {\n        value: event._type // ohos only\n    });\n    event.detail === undefined && Object.defineProperty(event, 'detail', {\n        value: event._detail || Object.assign({}, event) // ohos only\n    });\n    event.currentTarget = event.currentTarget || event.target || Object.assign({}, event);\n    hooks.call('modifyMpEventImpl', event);\n    const currentTarget = event.currentTarget;\n    const id = ((_a = currentTarget.dataset) === null || _a === void 0 ? void 0 : _a.sid /** sid */) || currentTarget.id /** uid */ || ((_b = event.detail) === null || _b === void 0 ? void 0 : _b.id) || '';\n    const node = env.document.getElementById(id);\n    if (node) {\n        const dispatch = () => {\n            const e = createEvent(event, node);\n            hooks.call('modifyTaroEvent', e, node);\n            hooks.call('dispatchTaroEvent', e, node);\n            hooks.call('dispatchTaroEventFinish', e, node);\n        };\n        if (hooks.isExist('batchedEventUpdates')) {\n            const type = event.type;\n            if (!hooks.call('isBubbleEvents', type) ||\n                !isParentBinded(node, type) ||\n                (type === TOUCHMOVE && !!node.props.catchMove)) {\n                // 最上层组件统一 batchUpdate\n                hooks.call('batchedEventUpdates', () => {\n                    if (eventsBatch[type]) {\n                        eventsBatch[type].forEach(fn => fn());\n                        delete eventsBatch[type];\n                    }\n                    dispatch();\n                });\n                return getEventCBResult(event);\n            }\n            else {\n                // 如果上层组件也有绑定同类型的组件，委托给上层组件调用事件回调\n                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);\n            }\n        }\n        else {\n            dispatch();\n            return getEventCBResult(event);\n        }\n    }\n}\n\nclass FormElement extends TaroElement {\n    get type() {\n        var _a;\n        return (_a = this.props[TYPE]) !== null && _a !== void 0 ? _a : '';\n    }\n    set type(val) {\n        this.setAttribute(TYPE, val);\n    }\n    get value() {\n        // eslint-disable-next-line dot-notation\n        const val = this.props[VALUE];\n        return val == null ? '' : val;\n    }\n    set value(val) {\n        this.setAttribute(VALUE, val);\n    }\n    dispatchEvent(event) {\n        if (event.mpEvent) {\n            const val = event.mpEvent.detail.value;\n            if (event.type === CHANGE) {\n                this.props.value = val;\n            }\n            else if (event.type === INPUT) {\n                // Web 规范中表单组件的 value 应该跟着输入改变\n                // 只是改 this.props.value 的话不会进行 setData，因此这里修改 this.value。\n                // 只测试了 React、Vue、Vue3 input 组件的 onInput 事件，onChange 事件不确定有没有副作用，所以暂不修改。\n                this.value = val;\n            }\n        }\n        return super.dispatchEvent(event);\n    }\n}\n\nclass Performance {\n    constructor() {\n        this.recorder = new Map();\n    }\n    start(id) {\n        if (!options.debug) {\n            return;\n        }\n        this.recorder.set(id, Date.now());\n    }\n    stop(id) {\n        if (!options.debug) {\n            return;\n        }\n        const now = Date.now();\n        const prev = this.recorder.get(id);\n        this.recorder.delete(id);\n        const time = now - prev;\n        // eslint-disable-next-line no-console\n        console.log(`${id} 时长： ${time}ms`);\n    }\n}\nconst perf = new Performance();\n\nfunction findCustomWrapper(root, dataPathArr) {\n    // ['root', 'cn', '[0]'] remove 'root' => ['cn', '[0]']\n    const list = dataPathArr.slice(1);\n    let currentData = root;\n    let customWrapper;\n    let splitedPath = '';\n    list.some((item, i) => {\n        const key = item\n            // '[0]' => '0'\n            .replace(/^\\[(.+)\\]$/, '$1')\n            // 'cn' => 'childNodes'\n            .replace(/\\bcn\\b/g, 'childNodes');\n        currentData = currentData[key];\n        if (isArray(currentData)) {\n            currentData = currentData.filter(el => !isComment(el));\n        }\n        if (isUndefined(currentData))\n            return true;\n        if (currentData.nodeName === CUSTOM_WRAPPER) {\n            const res = customWrapperCache.get(currentData.sid);\n            if (res) {\n                customWrapper = res;\n                splitedPath = dataPathArr.slice(i + 2).join('.');\n            }\n        }\n    });\n    if (customWrapper) {\n        return {\n            customWrapper,\n            splitedPath\n        };\n    }\n}\nclass TaroRootElement extends TaroElement {\n    constructor() {\n        super();\n        this.updatePayloads = [];\n        this.updateCallbacks = [];\n        this.pendingUpdate = false;\n        this.ctx = null;\n        this.nodeName = ROOT_STR;\n        this.tagName = ROOT_STR.toUpperCase();\n    }\n    get _path() {\n        return ROOT_STR;\n    }\n    get _root() {\n        return this;\n    }\n    enqueueUpdate(payload) {\n        this.updatePayloads.push(payload);\n        if (!this.pendingUpdate && this.ctx) {\n            this.performUpdate();\n        }\n    }\n    performUpdate(initRender = false, prerender) {\n        this.pendingUpdate = true;\n        const ctx = hooks.call('proxyToRaw', this.ctx);\n        setTimeout(() => {\n            const setDataMark = `${SET_DATA} 开始时间戳 ${Date.now()}`;\n            perf.start(setDataMark);\n            const data = Object.create(null);\n            const resetPaths = new Set(initRender\n                ? ['root.cn.[0]', 'root.cn[0]']\n                : []);\n            while (this.updatePayloads.length > 0) {\n                const { path, value } = this.updatePayloads.shift();\n                if (path.endsWith(\"cn\" /* Shortcuts.Childnodes */)) {\n                    resetPaths.add(path);\n                }\n                data[path] = value;\n            }\n            for (const path in data) {\n                resetPaths.forEach(p => {\n                    // 已经重置了数组，就不需要分别再设置了\n                    if (path.includes(p) && path !== p) {\n                        delete data[path];\n                    }\n                });\n                const value = data[path];\n                if (isFunction(value)) {\n                    data[path] = value();\n                }\n            }\n            // 预渲染\n            if (isFunction(prerender))\n                return prerender(data);\n            // 正常渲染\n            this.pendingUpdate = false;\n            let normalUpdate = {};\n            const customWrapperMap = new Map();\n            if (initRender) {\n                // 初次渲染，使用页面级别的 setData\n                normalUpdate = data;\n            }\n            else {\n                // 更新渲染，区分 CustomWrapper 与页面级别的 setData\n                for (const p in data) {\n                    const dataPathArr = p.split('.');\n                    const found = findCustomWrapper(this, dataPathArr);\n                    if (found) {\n                        // 此项数据使用 CustomWrapper 去更新\n                        const { customWrapper, splitedPath } = found;\n                        // 合并同一个 customWrapper 的相关更新到一次 setData 中\n                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, (customWrapperMap.get(customWrapper) || {})), { [`i.${splitedPath}`]: data[p] }));\n                    }\n                    else {\n                        // 此项数据使用页面去更新\n                        normalUpdate[p] = data[p];\n                    }\n                }\n            }\n            const customWrapperCount = customWrapperMap.size;\n            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;\n            const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);\n            let executeTime = 0;\n            const cb = () => {\n                if (++executeTime === updateArrLen) {\n                    perf.stop(setDataMark);\n                    this.flushUpdateCallback();\n                    initRender && perf.stop(PAGE_INIT);\n                }\n            };\n            // custom-wrapper setData\n            if (customWrapperCount) {\n                customWrapperMap.forEach((data, ctx) => {\n                    if (process.env.NODE_ENV !== 'production' && options.debug) {\n                        // eslint-disable-next-line no-console\n                        console.log('custom wrapper setData: ', data);\n                    }\n                    ctx.setData(data, cb);\n                });\n            }\n            // page setData\n            if (isNeedNormalUpdate) {\n                if (process.env.NODE_ENV !== 'production' && options.debug) {\n                    // eslint-disable-next-line no-console\n                    console.log('page setData:', normalUpdate);\n                }\n                ctx.setData(normalUpdate, cb);\n            }\n        }, 0);\n    }\n    enqueueUpdateCallback(cb, ctx) {\n        this.updateCallbacks.push(() => {\n            ctx ? cb.call(ctx) : cb();\n        });\n    }\n    flushUpdateCallback() {\n        const updateCallbacks = this.updateCallbacks;\n        if (!updateCallbacks.length)\n            return;\n        const copies = updateCallbacks.slice(0);\n        this.updateCallbacks.length = 0;\n        for (let i = 0; i < copies.length; i++) {\n            copies[i]();\n        }\n    }\n}\n\nclass TaroText extends TaroNode {\n    constructor(value) {\n        super();\n        this.nodeType = 3 /* NodeType.TEXT_NODE */;\n        this.nodeName = '#text';\n        this._value = value;\n    }\n    set textContent(text) {\n        MutationObserver$1.record({\n            target: this,\n            type: \"characterData\" /* MutationRecordType.CHARACTER_DATA */,\n            oldValue: this._value\n        });\n        this._value = text;\n        this.enqueueUpdate({\n            path: `${this._path}.${\"v\" /* Shortcuts.Text */}`,\n            value: text\n        });\n    }\n    get textContent() {\n        return this._value;\n    }\n    set nodeValue(text) {\n        this.textContent = text;\n    }\n    get nodeValue() {\n        return this._value;\n    }\n    set data(text) {\n        this.textContent = text;\n    }\n    get data() {\n        return this._value;\n    }\n}\n\nvar _dict, _a;\nconst findReg = /[!'()~]|%20|%00/g;\nconst plusReg = /\\+/g;\nconst replaceCharMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00',\n};\nfunction replacer(match) {\n    return replaceCharMap[match];\n}\nfunction appendTo(dict, name, value) {\n    const res = isArray(value) ? value.join(',') : value;\n    if (name in dict)\n        dict[name].push(res);\n    else\n        dict[name] = [res];\n}\nfunction addEach(value, key) {\n    appendTo(this, key, value);\n}\nfunction decode(str) {\n    return decodeURIComponent(str.replace(plusReg, ' '));\n}\nfunction encode(str) {\n    return encodeURIComponent(str).replace(findReg, replacer);\n}\nconst URLSearchParams = process.env.TARO_PLATFORM === 'web' ? env.window.URLSearchParams : (_a = class {\n        constructor(query) {\n            _dict.set(this, Object.create(null));\n            query !== null && query !== void 0 ? query : (query = '');\n            const dict = __classPrivateFieldGet(this, _dict, \"f\");\n            if (typeof query === 'string') {\n                if (query.charAt(0) === '?') {\n                    query = query.slice(1);\n                }\n                for (let pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {\n                    const value = pairs[i];\n                    const index = value.indexOf('=');\n                    // 针对不规范的 url 参数做容错处理，如：word=你%好\n                    try {\n                        if (index > -1) {\n                            appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n                        }\n                        else if (value.length) {\n                            appendTo(dict, decode(value), '');\n                        }\n                    }\n                    catch (err) {\n                        if (process.env.NODE_ENV !== 'production') {\n                            console.warn(`[Taro warn] URL 参数 ${value} decode 异常`);\n                        }\n                    }\n                }\n            }\n            else {\n                if (isArray(query)) {\n                    for (let i = 0, length = query.length; i < length; i++) {\n                        const value = query[i];\n                        appendTo(dict, value[0], value[1]);\n                    }\n                }\n                else if (query.forEach) {\n                    query.forEach(addEach, dict);\n                }\n                else {\n                    for (const key in query) {\n                        appendTo(dict, key, query[key]);\n                    }\n                }\n            }\n        }\n        append(name, value) {\n            appendTo(__classPrivateFieldGet(this, _dict, \"f\"), name, value);\n        }\n        delete(name) {\n            delete __classPrivateFieldGet(this, _dict, \"f\")[name];\n        }\n        get(name) {\n            const dict = __classPrivateFieldGet(this, _dict, \"f\");\n            return name in dict ? dict[name][0] : null;\n        }\n        getAll(name) {\n            const dict = __classPrivateFieldGet(this, _dict, \"f\");\n            return name in dict ? dict[name].slice(0) : [];\n        }\n        has(name) {\n            return name in __classPrivateFieldGet(this, _dict, \"f\");\n        }\n        keys() {\n            return Object.keys(__classPrivateFieldGet(this, _dict, \"f\"));\n        }\n        set(name, value) {\n            __classPrivateFieldGet(this, _dict, \"f\")[name] = ['' + value];\n        }\n        forEach(callback, thisArg) {\n            const dict = __classPrivateFieldGet(this, _dict, \"f\");\n            Object.getOwnPropertyNames(dict).forEach(function (name) {\n                dict[name].forEach(function (value) {\n                    callback.call(thisArg, value, name, this);\n                }, this);\n            }, this);\n        }\n        toJSON() {\n            return {};\n        }\n        toString() {\n            const dict = __classPrivateFieldGet(this, _dict, \"f\");\n            const query = [];\n            for (const key in dict) {\n                const name = encode(key);\n                for (let i = 0, value = dict[key]; i < value.length; i++) {\n                    query.push(name + '=' + encode(value[i]));\n                }\n            }\n            return query.join('&');\n        }\n    },\n    _dict = new WeakMap(),\n    _a);\n\nvar _TaroURL_hash, _TaroURL_hostname, _TaroURL_pathname, _TaroURL_port, _TaroURL_protocol, _TaroURL_search;\nclass TaroURL {\n    static createObjectURL() {\n        throw new Error('Oops, not support URL.createObjectURL() in miniprogram.');\n    }\n    static revokeObjectURL() {\n        throw new Error('Oops, not support URL.revokeObjectURL() in miniprogram.');\n    }\n    constructor(url, base) {\n        /* private property */\n        _TaroURL_hash.set(this, '');\n        _TaroURL_hostname.set(this, '');\n        _TaroURL_pathname.set(this, '');\n        _TaroURL_port.set(this, '');\n        _TaroURL_protocol.set(this, '');\n        _TaroURL_search.set(this, void 0);\n        if (!isString(url))\n            url = String(url);\n        const parseResult = parseUrlBase(url, base);\n        const { hash, hostname, pathname, port, protocol, search } = parseResult;\n        __classPrivateFieldSet(this, _TaroURL_hash, hash, \"f\");\n        __classPrivateFieldSet(this, _TaroURL_hostname, hostname, \"f\");\n        __classPrivateFieldSet(this, _TaroURL_pathname, pathname || '/', \"f\");\n        __classPrivateFieldSet(this, _TaroURL_port, port, \"f\");\n        __classPrivateFieldSet(this, _TaroURL_protocol, protocol, \"f\");\n        __classPrivateFieldSet(this, _TaroURL_search, new URLSearchParams(search), \"f\");\n    }\n    /* public property */\n    get protocol() {\n        return __classPrivateFieldGet(this, _TaroURL_protocol, \"f\");\n    }\n    set protocol(val) {\n        isString(val) && (__classPrivateFieldSet(this, _TaroURL_protocol, val.trim(), \"f\"));\n    }\n    get host() {\n        return this.hostname + (this.port ? ':' + this.port : '');\n    }\n    set host(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { hostname, port } = parseUrl(`//${val}`);\n            this.hostname = hostname;\n            this.port = port;\n        }\n    }\n    get hostname() {\n        return __classPrivateFieldGet(this, _TaroURL_hostname, \"f\");\n    }\n    set hostname(val) {\n        val && isString(val) && (__classPrivateFieldSet(this, _TaroURL_hostname, val.trim(), \"f\"));\n    }\n    get port() {\n        return __classPrivateFieldGet(this, _TaroURL_port, \"f\");\n    }\n    set port(val) {\n        isString(val) && (__classPrivateFieldSet(this, _TaroURL_port, val.trim(), \"f\"));\n    }\n    get pathname() {\n        return __classPrivateFieldGet(this, _TaroURL_pathname, \"f\");\n    }\n    set pathname(val) {\n        if (isString(val)) {\n            val = val.trim();\n            const HEAD_REG = /^(\\/|\\.\\/|\\.\\.\\/)/;\n            let temp = val;\n            while (HEAD_REG.test(temp)) {\n                temp = temp.replace(HEAD_REG, '');\n            }\n            if (temp)\n                __classPrivateFieldSet(this, _TaroURL_pathname, '/' + temp, \"f\");\n            else\n                __classPrivateFieldSet(this, _TaroURL_pathname, '/', \"f\");\n        }\n    }\n    get search() {\n        const val = __classPrivateFieldGet(this, _TaroURL_search, \"f\").toString();\n        return (val.length === 0 || val.startsWith('?')) ? val : `?${val}`;\n    }\n    set search(val) {\n        if (isString(val)) {\n            val = val.trim();\n            __classPrivateFieldSet(this, _TaroURL_search, new URLSearchParams(val), \"f\");\n        }\n    }\n    get hash() {\n        return __classPrivateFieldGet(this, _TaroURL_hash, \"f\");\n    }\n    set hash(val) {\n        if (isString(val)) {\n            val = val.trim();\n            if (val)\n                __classPrivateFieldSet(this, _TaroURL_hash, val.startsWith('#') ? val : `#${val}`, \"f\");\n            else\n                __classPrivateFieldSet(this, _TaroURL_hash, '', \"f\");\n        }\n    }\n    get href() {\n        return `${this.protocol}//${this.host}${this.pathname}${this.search}${this.hash}`;\n    }\n    set href(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { protocol, hostname, port, hash, search, pathname } = parseUrl(val);\n            this.protocol = protocol;\n            this.hostname = hostname;\n            this.pathname = pathname;\n            this.port = port;\n            this.hash = hash;\n            this.search = search;\n        }\n    }\n    get origin() {\n        return `${this.protocol}//${this.host}`;\n    }\n    set origin(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { protocol, hostname, port } = parseUrl(val);\n            this.protocol = protocol;\n            this.hostname = hostname;\n            this.port = port;\n        }\n    }\n    get searchParams() {\n        return __classPrivateFieldGet(this, _TaroURL_search, \"f\");\n    }\n    // public method\n    toString() {\n        return this.href;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    // convenient for deconstructor\n    _toRaw() {\n        return {\n            protocol: this.protocol,\n            port: this.port,\n            host: this.host,\n            hostname: this.hostname,\n            pathname: this.pathname,\n            hash: this.hash,\n            search: this.search,\n            origin: this.origin,\n            href: this.href,\n        };\n    }\n}\n_TaroURL_hash = new WeakMap(), _TaroURL_hostname = new WeakMap(), _TaroURL_pathname = new WeakMap(), _TaroURL_port = new WeakMap(), _TaroURL_protocol = new WeakMap(), _TaroURL_search = new WeakMap();\nconst URL = process.env.TARO_PLATFORM === 'web' ? env.window.URL : TaroURL;\nfunction parseUrl(url = '') {\n    const result = {\n        href: '',\n        origin: '',\n        protocol: '',\n        hostname: '',\n        host: '',\n        port: '',\n        pathname: '',\n        search: '',\n        hash: ''\n    };\n    if (!url || !isString(url))\n        return result;\n    url = url.trim();\n    const PATTERN = /^(([^:/?#]+):)?\\/\\/(([^/?#]+):(.+)@)?([^/?#:]*)(:(\\d+))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    const matches = url.match(PATTERN);\n    if (!matches)\n        return result;\n    // TODO: username & password ?\n    result.protocol = matches[1] || 'https:';\n    result.hostname = matches[6] || 'taro.com';\n    result.port = matches[8] || '';\n    result.pathname = matches[9] || '/';\n    result.search = matches[10] || '';\n    result.hash = matches[12] || '';\n    result.href = url;\n    result.origin = result.protocol + '//' + result.hostname;\n    result.host = result.hostname + (result.port ? `:${result.port}` : '');\n    return result;\n}\nfunction parseUrlBase(url, base) {\n    const VALID_URL = /^(https?:)\\/\\//i;\n    let fullUrl = '';\n    let parsedBase = null;\n    if (!isUndefined(base)) {\n        base = String(base).trim();\n        if (!VALID_URL.test(base))\n            throw new TypeError(`Failed to construct 'URL': Invalid base URL`);\n        parsedBase = parseUrl(base);\n    }\n    url = String(url).trim();\n    if (VALID_URL.test(url)) {\n        fullUrl = url;\n    }\n    else if (parsedBase) {\n        if (url) {\n            if (url.startsWith('//')) {\n                fullUrl = parsedBase.protocol + url;\n            }\n            else {\n                fullUrl = parsedBase.origin + (url.startsWith('/') ? url : `/${url}`);\n            }\n        }\n        else {\n            fullUrl = parsedBase.href;\n        }\n    }\n    else {\n        throw new TypeError(`Failed to construct 'URL': Invalid URL`);\n    }\n    return parseUrl(fullUrl);\n}\n\nclass AnchorElement extends TaroElement {\n    get href() {\n        var _a;\n        return (_a = this.props[\"href\" /* AnchorElementAttrs.HREF */]) !== null && _a !== void 0 ? _a : '';\n    }\n    set href(val) {\n        this.setAttribute(\"href\" /* AnchorElementAttrs.HREF */, val);\n    }\n    get protocol() {\n        var _a;\n        return (_a = this.props[\"protocol\" /* AnchorElementAttrs.PROTOCOL */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get host() {\n        var _a;\n        return (_a = this.props[\"host\" /* AnchorElementAttrs.HOST */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get search() {\n        var _a;\n        return (_a = this.props[\"search\" /* AnchorElementAttrs.SEARCH */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get hash() {\n        var _a;\n        return (_a = this.props[\"hash\" /* AnchorElementAttrs.HASH */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get hostname() {\n        var _a;\n        return (_a = this.props[\"hostname\" /* AnchorElementAttrs.HOSTNAME */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get port() {\n        var _a;\n        return (_a = this.props[\"port\" /* AnchorElementAttrs.PORT */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get pathname() {\n        var _a;\n        return (_a = this.props[\"pathname\" /* AnchorElementAttrs.PATHNAME */]) !== null && _a !== void 0 ? _a : '';\n    }\n    setAttribute(qualifiedName, value) {\n        if (qualifiedName === \"href\" /* AnchorElementAttrs.HREF */) {\n            const willSetAttr = parseUrl(value);\n            for (const k in willSetAttr) {\n                super.setAttribute(k, willSetAttr[k]);\n            }\n        }\n        else {\n            super.setAttribute(qualifiedName, value);\n        }\n    }\n}\n\nclass TransferElement extends TaroElement {\n    constructor(dataName) {\n        super();\n        this.dataName = dataName;\n        this.isTransferElement = true;\n    }\n    get _path() {\n        return this.dataName;\n    }\n}\n\nclass TaroDocument extends TaroElement {\n    constructor() {\n        super();\n        this.createEvent = createEvent;\n        this.nodeType = 9 /* NodeType.DOCUMENT_NODE */;\n        this.nodeName = DOCUMENT_ELEMENT_NAME;\n    }\n    createElement(type) {\n        const nodeName = type.toLowerCase();\n        let element;\n        switch (true) {\n            case nodeName === ROOT_STR:\n                element = new TaroRootElement();\n                return element;\n            case controlledComponent.has(nodeName):\n                element = new FormElement();\n                break;\n            case nodeName === A:\n                element = new AnchorElement();\n                break;\n            case nodeName === 'page-meta':\n            case nodeName === 'navigation-bar':\n                element = new TransferElement(toCamelCase(nodeName));\n                break;\n            default:\n                element = new TaroElement();\n                break;\n        }\n        element.nodeName = nodeName;\n        element.tagName = type.toUpperCase();\n        return element;\n    }\n    // an ugly fake createElementNS to deal with @vue/runtime-dom's\n    // support mounting app to svg container since vue@3.0.8\n    createElementNS(_svgNS, type) {\n        return this.createElement(type);\n    }\n    createTextNode(text) {\n        return new TaroText(text);\n    }\n    getElementById(id) {\n        const el = eventSource.get(id);\n        return isUndefined(el) ? null : el;\n    }\n    querySelector(query) {\n        // 为了 Vue3 的乞丐版实现\n        if (/^#/.test(query)) {\n            return this.getElementById(query.slice(1));\n        }\n        return null;\n    }\n    querySelectorAll() {\n        // fake hack\n        return [];\n    }\n    // @TODO: @PERF: 在 hydrate 移除掉空的 node\n    createComment() {\n        const textnode = new TaroText('');\n        textnode.nodeName = COMMENT;\n        return textnode;\n    }\n    get defaultView() {\n        return env.window;\n    }\n}\n\nfunction createDocument() {\n    /**\n       * <document>\n       *   <html>\n       *     <head></head>\n       *     <body>\n       *       <container>\n       *         <app id=\"app\" />\n       *       </container>\n       *     </body>\n       *   </html>\n       * </document>\n       */\n    const doc = new TaroDocument();\n    const documentCreateElement = doc.createElement.bind(doc);\n    const html = documentCreateElement(HTML);\n    const head = documentCreateElement(HEAD);\n    const body = documentCreateElement(BODY);\n    const app = documentCreateElement(APP);\n    app.id = APP;\n    const container = documentCreateElement(CONTAINER); // 多包一层主要为了兼容 vue\n    doc.appendChild(html);\n    html.appendChild(head);\n    html.appendChild(body);\n    body.appendChild(container);\n    container.appendChild(app);\n    doc.documentElement = html;\n    doc.head = head;\n    doc.body = body;\n    return doc;\n}\nconst document$1 = process.env.TARO_PLATFORM === 'web' ? env.document : (env.document = createDocument());\n\nconst getComputedStyle = process.env.TARO_PLATFORM === 'web' ? env.window.getComputedStyle : function (element) {\n    return element.style;\n};\n\nconst eventCenter = hooks.call('getEventCenter', Events);\n\n/**\n * 一个小型缓存池，用于在切换页面时，存储一些上下文信息\n */\nclass RuntimeCache {\n    constructor(name) {\n        this.cache = new Map();\n        this.name = name;\n    }\n    has(identifier) {\n        return this.cache.has(identifier);\n    }\n    set(identifier, ctx) {\n        if (identifier && ctx) {\n            this.cache.set(identifier, ctx);\n        }\n    }\n    get(identifier) {\n        if (this.has(identifier))\n            return this.cache.get(identifier);\n    }\n    delete(identifier) {\n        this.cache.delete(identifier);\n    }\n}\n\nvar _TaroHistory_instances, _TaroHistory_location, _TaroHistory_stack, _TaroHistory_cur, _TaroHistory_window, _TaroHistory_reset;\nconst cache$1 = new RuntimeCache('history');\nclass TaroHistory extends Events {\n    constructor(location, options) {\n        super();\n        _TaroHistory_instances.add(this);\n        /* private property */\n        _TaroHistory_location.set(this, void 0);\n        _TaroHistory_stack.set(this, []);\n        _TaroHistory_cur.set(this, 0);\n        _TaroHistory_window.set(this, void 0);\n        __classPrivateFieldSet(this, _TaroHistory_window, options.window, \"f\");\n        __classPrivateFieldSet(this, _TaroHistory_location, location, \"f\");\n        __classPrivateFieldGet(this, _TaroHistory_location, \"f\").on('__record_history__', (href) => {\n            var _a;\n            __classPrivateFieldSet(this, _TaroHistory_cur, (_a = __classPrivateFieldGet(this, _TaroHistory_cur, \"f\"), _a++, _a), \"f\");\n            __classPrivateFieldSet(this, _TaroHistory_stack, __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").slice(0, __classPrivateFieldGet(this, _TaroHistory_cur, \"f\")), \"f\");\n            __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").push({\n                state: null,\n                title: '',\n                url: href\n            });\n        }, null);\n        __classPrivateFieldGet(this, _TaroHistory_location, \"f\").on('__reset_history__', (href) => {\n            __classPrivateFieldGet(this, _TaroHistory_instances, \"m\", _TaroHistory_reset).call(this, href);\n        }, null);\n        // 切换上下文行为\n        this.on(CONTEXT_ACTIONS.INIT, () => {\n            __classPrivateFieldGet(this, _TaroHistory_instances, \"m\", _TaroHistory_reset).call(this);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n            cache$1.set(pageId, {\n                location: __classPrivateFieldGet(this, _TaroHistory_location, \"f\"),\n                stack: __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").slice(),\n                cur: __classPrivateFieldGet(this, _TaroHistory_cur, \"f\")\n            });\n        }, null);\n        this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n            if (cache$1.has(pageId)) {\n                const ctx = cache$1.get(pageId);\n                __classPrivateFieldSet(this, _TaroHistory_location, ctx.location, \"f\");\n                __classPrivateFieldSet(this, _TaroHistory_stack, ctx.stack, \"f\");\n                __classPrivateFieldSet(this, _TaroHistory_cur, ctx.cur, \"f\");\n            }\n        }, null);\n        this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n            cache$1.delete(pageId);\n        }, null);\n        __classPrivateFieldGet(this, _TaroHistory_instances, \"m\", _TaroHistory_reset).call(this);\n    }\n    /* public property */\n    get length() {\n        return __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").length;\n    }\n    get state() {\n        return __classPrivateFieldGet(this, _TaroHistory_stack, \"f\")[__classPrivateFieldGet(this, _TaroHistory_cur, \"f\")].state;\n    }\n    /* public method */\n    go(delta) {\n        if (!isNumber(delta) || isNaN(delta))\n            return;\n        let targetIdx = __classPrivateFieldGet(this, _TaroHistory_cur, \"f\") + delta;\n        targetIdx = Math.min(Math.max(targetIdx, 0), this.length - 1);\n        __classPrivateFieldSet(this, _TaroHistory_cur, targetIdx, \"f\");\n        __classPrivateFieldGet(this, _TaroHistory_location, \"f\").trigger('__set_href_without_history__', __classPrivateFieldGet(this, _TaroHistory_stack, \"f\")[__classPrivateFieldGet(this, _TaroHistory_cur, \"f\")].url);\n        __classPrivateFieldGet(this, _TaroHistory_window, \"f\").trigger('popstate', __classPrivateFieldGet(this, _TaroHistory_stack, \"f\")[__classPrivateFieldGet(this, _TaroHistory_cur, \"f\")]);\n    }\n    back() {\n        this.go(-1);\n    }\n    forward() {\n        this.go(1);\n    }\n    pushState(state, title, url) {\n        if (!url || !isString(url))\n            return;\n        __classPrivateFieldSet(this, _TaroHistory_stack, __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").slice(0, __classPrivateFieldGet(this, _TaroHistory_cur, \"f\") + 1), \"f\");\n        __classPrivateFieldGet(this, _TaroHistory_stack, \"f\").push({\n            state,\n            title,\n            url\n        });\n        __classPrivateFieldSet(this, _TaroHistory_cur, this.length - 1, \"f\");\n        __classPrivateFieldGet(this, _TaroHistory_location, \"f\").trigger('__set_href_without_history__', url);\n    }\n    replaceState(state, title, url) {\n        if (!url || !isString(url))\n            return;\n        __classPrivateFieldGet(this, _TaroHistory_stack, \"f\")[__classPrivateFieldGet(this, _TaroHistory_cur, \"f\")] = {\n            state,\n            title,\n            url\n        };\n        __classPrivateFieldGet(this, _TaroHistory_location, \"f\").trigger('__set_href_without_history__', url);\n    }\n    // For debug\n    get cache() {\n        return cache$1;\n    }\n}\n_TaroHistory_location = new WeakMap(), _TaroHistory_stack = new WeakMap(), _TaroHistory_cur = new WeakMap(), _TaroHistory_window = new WeakMap(), _TaroHistory_instances = new WeakSet(), _TaroHistory_reset = function _TaroHistory_reset(href = '') {\n    __classPrivateFieldSet(this, _TaroHistory_stack, [\n        {\n            state: null,\n            title: '',\n            url: href || __classPrivateFieldGet(this, _TaroHistory_location, \"f\").href\n        }\n    ], \"f\");\n    __classPrivateFieldSet(this, _TaroHistory_cur, 0, \"f\");\n};\nconst History = process.env.TARO_PLATFORM === 'web' ? env.window.History : TaroHistory;\n\nconst Current = {\n    app: null,\n    router: null,\n    page: null\n};\nconst getCurrentInstance = () => Current;\n\nvar _TaroLocation_instances, _TaroLocation_url, _TaroLocation_noCheckUrl, _TaroLocation_window, _TaroLocation_reset, _TaroLocation_getPreValue, _TaroLocation_rollBack, _TaroLocation_recordHistory, _TaroLocation_checkUrlChange;\nconst INIT_URL = 'https://taro.com';\nconst cache = new RuntimeCache('location');\nclass TaroLocation extends Events {\n    constructor(options) {\n        super();\n        _TaroLocation_instances.add(this);\n        /* private property */\n        _TaroLocation_url.set(this, new URL(INIT_URL));\n        _TaroLocation_noCheckUrl.set(this, false);\n        _TaroLocation_window.set(this, void 0);\n        __classPrivateFieldSet(this, _TaroLocation_window, options.window, \"f\");\n        __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_reset).call(this);\n        this.on('__set_href_without_history__', (href) => {\n            __classPrivateFieldSet(this, _TaroLocation_noCheckUrl, true, \"f\");\n            const lastHash = __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hash;\n            __classPrivateFieldGet(this, _TaroLocation_url, \"f\").href = generateFullUrl(href);\n            if (lastHash !== __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hash) {\n                __classPrivateFieldGet(this, _TaroLocation_window, \"f\").trigger('hashchange');\n            }\n            __classPrivateFieldSet(this, _TaroLocation_noCheckUrl, false, \"f\");\n        }, null);\n        // 切换上下文行为\n        this.on(CONTEXT_ACTIONS.INIT, () => {\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_reset).call(this);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n            cache.set(pageId, {\n                lastHref: this.href,\n            });\n        }, null);\n        this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n            // 数据恢复时，不需要执行跳转\n            if (cache.has(pageId)) {\n                const ctx = cache.get(pageId);\n                __classPrivateFieldSet(this, _TaroLocation_noCheckUrl, true, \"f\");\n                __classPrivateFieldGet(this, _TaroLocation_url, \"f\").href = ctx.lastHref;\n                __classPrivateFieldSet(this, _TaroLocation_noCheckUrl, false, \"f\");\n            }\n        }, null);\n        this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n            cache.delete(pageId);\n        }, null);\n    }\n    /* public property */\n    get protocol() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").protocol;\n    }\n    set protocol(val) {\n        const REG = /^(http|https):$/i;\n        if (!val || !isString(val) || !REG.test(val.trim()))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").protocol = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get host() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").host;\n    }\n    set host(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").host = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get hostname() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hostname;\n    }\n    set hostname(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hostname = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get port() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").port;\n    }\n    set port(val) {\n        const xVal = Number((val = val.trim()));\n        if (!isNumber(xVal) || xVal <= 0)\n            return;\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").port = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get pathname() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").pathname;\n    }\n    set pathname(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").pathname = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get search() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").search;\n    }\n    set search(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        val = val.startsWith('?') ? val : `?${val}`;\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").search = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get hash() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hash;\n    }\n    // 小程序的navigateTo存在截断hash字符串的问题\n    set hash(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        val = val.startsWith('#') ? val : `#${val}`;\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").hash = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get href() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").href;\n    }\n    set href(val) {\n        const REG = /^(http:|https:)?\\/\\/.+/;\n        if (!val || !isString(val) || !REG.test((val = val.trim())))\n            return;\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").href = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    get origin() {\n        return __classPrivateFieldGet(this, _TaroLocation_url, \"f\").origin;\n    }\n    set origin(val) {\n        const REG = /^(http:|https:)?\\/\\/.+/;\n        if (!val || !isString(val) || !REG.test((val = val.trim())))\n            return;\n        const preValue = __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_getPreValue).call(this);\n        __classPrivateFieldGet(this, _TaroLocation_url, \"f\").origin = val;\n        if (__classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_recordHistory).call(this);\n    }\n    /* public method */\n    assign() {\n        warn(true, '小程序环境中调用location.assign()无效.');\n    }\n    reload() {\n        warn(true, '小程序环境中调用location.reload()无效.');\n    }\n    replace(url) {\n        this.trigger('__set_href_without_history__', url);\n    }\n    toString() {\n        return this.href;\n    }\n    // For debug\n    get cache() {\n        return cache;\n    }\n}\n_TaroLocation_url = new WeakMap(), _TaroLocation_noCheckUrl = new WeakMap(), _TaroLocation_window = new WeakMap(), _TaroLocation_instances = new WeakSet(), _TaroLocation_reset = function _TaroLocation_reset() {\n    const Current = getCurrentInstance();\n    const router = Current.router;\n    if (router) {\n        const { path, params } = router;\n        const searchArr = Object.keys(params).map((key) => {\n            return `${key}=${params[key]}`;\n        });\n        const searchStr = searchArr.length > 0 ? '?' + searchArr.join('&') : '';\n        const url = `${INIT_URL}${path.startsWith('/') ? path : '/' + path}${searchStr}`;\n        __classPrivateFieldSet(this, _TaroLocation_url, new URL(url), \"f\");\n        this.trigger('__reset_history__', this.href);\n    }\n}, _TaroLocation_getPreValue = function _TaroLocation_getPreValue() {\n    return __classPrivateFieldGet(this, _TaroLocation_url, \"f\")._toRaw();\n}, _TaroLocation_rollBack = function _TaroLocation_rollBack(href) {\n    __classPrivateFieldGet(this, _TaroLocation_url, \"f\").href = href;\n}, _TaroLocation_recordHistory = function _TaroLocation_recordHistory() {\n    this.trigger('__record_history__', this.href);\n}, _TaroLocation_checkUrlChange = function _TaroLocation_checkUrlChange(preValue) {\n    if (__classPrivateFieldGet(this, _TaroLocation_noCheckUrl, \"f\")) {\n        return false;\n    }\n    const { protocol, hostname, port, pathname, search, hash } = __classPrivateFieldGet(this, _TaroLocation_url, \"f\")._toRaw();\n    // 跨域三要素不允许修改\n    if (protocol !== preValue.protocol || hostname !== preValue.hostname || port !== preValue.port) {\n        __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_rollBack).call(this, preValue.href);\n        return false;\n    }\n    // pathname\n    if (pathname !== preValue.pathname) {\n        return true;\n    }\n    // search\n    if (search !== preValue.search) {\n        return true;\n    }\n    // hashchange\n    if (hash !== preValue.hash) {\n        __classPrivateFieldGet(this, _TaroLocation_window, \"f\").trigger('hashchange');\n        return true;\n    }\n    __classPrivateFieldGet(this, _TaroLocation_instances, \"m\", _TaroLocation_rollBack).call(this, preValue.href);\n    return false;\n};\nconst Location = process.env.TARO_PLATFORM === 'web' ? env.window.Location : TaroLocation;\nfunction generateFullUrl(val = '') {\n    const origin = INIT_URL;\n    if (/^[/?#]/.test(val)) {\n        return origin + val;\n    }\n    return val;\n}\n\nconst machine = 'Macintosh';\nconst arch = 'Intel Mac OS X 10_14_5';\nconst engine = 'AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36';\nconst msg = '(' + machine + '; ' + arch + ') ' + engine;\nconst nav = process.env.TARO_PLATFORM === 'web' ? env.window.navigator : {\n    appCodeName: 'Mozilla',\n    appName: 'Netscape',\n    appVersion: '5.0 ' + msg,\n    cookieEnabled: true,\n    mimeTypes: [],\n    onLine: true,\n    platform: 'MacIntel',\n    plugins: [],\n    product: 'Taro',\n    productSub: '20030107',\n    userAgent: 'Mozilla/5.0 ' + msg,\n    vendor: 'Joyent',\n    vendorSub: ''\n};\n\n// https://github.com/myrne/performance-now\nlet now;\n(function () {\n    let loadTime;\n    if ((typeof performance !== 'undefined' && performance !== null) && performance.now) {\n        now = () => performance.now();\n    }\n    else if (Date.now) {\n        loadTime = Date.now();\n        now = () => Date.now() - loadTime;\n    }\n    else {\n        loadTime = new Date().getTime();\n        now = () => new Date().getTime() - loadTime;\n    }\n})();\nlet lastTime = 0;\n// https://gist.github.com/paulirish/1579671\n// https://gist.github.com/jalbam/5fe05443270fa6d8136238ec72accbc0\nconst _raf = typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame !== null ? requestAnimationFrame : function (callback) {\n    const _now = now();\n    const nextTime = Math.max(lastTime + 16, _now); // First time will execute it immediately but barely noticeable and performance is gained.\n    return setTimeout(function () { callback(lastTime = nextTime); }, nextTime - _now);\n};\nconst _caf = typeof cancelAnimationFrame !== 'undefined' && cancelAnimationFrame !== null\n    ? cancelAnimationFrame\n    : function (seed) {\n        // fix https://github.com/NervJS/taro/issues/7749\n        clearTimeout(seed);\n    };\n\nclass TaroWindow extends Events {\n    constructor() {\n        super();\n        this.navigator = nav;\n        this.requestAnimationFrame = _raf;\n        this.cancelAnimationFrame = _caf;\n        this.getComputedStyle = getComputedStyle;\n        const globalProperties = [\n            ...Object.getOwnPropertyNames(global || {}),\n            ...Object.getOwnPropertySymbols(global || {})\n        ];\n        globalProperties.forEach(property => {\n            if (property === 'atob' || property === 'document')\n                return;\n            if (!Object.prototype.hasOwnProperty.call(this, property)) {\n                // 防止小程序环境下，window 上的某些 get 属性在赋值时报错\n                try {\n                    this[property] = global[property];\n                }\n                catch (e) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`[Taro warn] window.${String(property)} 在赋值到 window 时报错`);\n                    }\n                }\n            }\n        });\n        this.Date || (this.Date = Date);\n        // 应用启动时，提供给需要读取历史信息的库使用\n        this.location = new Location({ window: this });\n        // @ts-ignore\n        this.history = new History(this.location, { window: this });\n        this.initEvent();\n    }\n    initEvent() {\n        const _location = this.location;\n        const _history = this.history;\n        this.on(CONTEXT_ACTIONS.INIT, (pageId) => {\n            // 页面onload，为该页面建立新的上下文信息\n            _location.trigger(CONTEXT_ACTIONS.INIT, pageId);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n            // 页面onshow，恢复当前页面的上下文信息\n            _location.trigger(CONTEXT_ACTIONS.RECOVER, pageId);\n            _history.trigger(CONTEXT_ACTIONS.RECOVER, pageId);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n            // 页面onhide，缓存当前页面的上下文信息\n            _location.trigger(CONTEXT_ACTIONS.RESTORE, pageId);\n            _history.trigger(CONTEXT_ACTIONS.RESTORE, pageId);\n        }, null);\n        this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n            // 页面onunload，清除当前页面的上下文信息\n            _location.trigger(CONTEXT_ACTIONS.DESTORY, pageId);\n            _history.trigger(CONTEXT_ACTIONS.DESTORY, pageId);\n        }, null);\n    }\n    get document() {\n        return env.document;\n    }\n    addEventListener(event, callback) {\n        if (!isString(event))\n            return;\n        this.on(event, callback, null);\n    }\n    removeEventListener(event, callback) {\n        if (!isString(event))\n            return;\n        this.off(event, callback, null);\n    }\n    setTimeout(...args) {\n        return setTimeout(...args);\n    }\n    clearTimeout(...args) {\n        return clearTimeout(...args);\n    }\n}\nconst window$1 = process.env.TARO_PLATFORM === 'web' ? env.window : (env.window = new TaroWindow());\nconst location = window$1.location;\nconst history = window$1.history;\n\n// for Vue3\nclass SVGElement extends TaroElement {\n}\n\n// export const removeLeadingSlash = (str = '') => str.replace(/^\\.?\\//, '')\n// export const removeTrailingSearch = (str = '') => str.replace(/\\?[\\s\\S]*$/, '')\nconst addLeadingSlash = (url = '') => (url.charAt(0) === '/' ? url : '/' + url);\nconst hasBasename = (path = '', prefix = '') => new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path) || path === prefix;\nconst stripBasename = (path = '', prefix = '') => hasBasename(path, prefix) ? path.substring(prefix.length) : path;\nconst stripTrailing = (str = '') => str.replace(/[?#][\\s\\S]*$/, '');\nconst stripSuffix = (path = '', suffix = '') => path.includes(suffix) ? path.substring(0, path.length - suffix.length) : path;\nconst getHomePage = (path = '', basename = '', customRoutes = {}, entryPagePath = '') => {\n    var _a;\n    const routePath = addLeadingSlash(stripBasename(path, basename));\n    const alias = ((_a = Object.entries(customRoutes).find(([key]) => key === routePath)) === null || _a === void 0 ? void 0 : _a[1]) || routePath;\n    return entryPagePath || (typeof alias === 'string' ? alias : alias[0]) || basename;\n};\nconst getCurrentPage = (routerMode = 'hash', basename = '/') => {\n    const pagePath = routerMode === 'hash'\n        ? location.hash.slice(1).split('?')[0]\n        : location.pathname;\n    return addLeadingSlash(stripBasename(pagePath, basename));\n};\n\n/* eslint-disable dot-notation */\nconst instances = new Map();\nconst pageId = incrementId();\nfunction injectPageInstance(inst, id) {\n    hooks.call('mergePageInstance', instances.get(id), inst);\n    instances.set(id, inst);\n}\nfunction getPageInstance(id) {\n    return instances.get(id);\n}\nfunction removePageInstance(id) {\n    instances.delete(id);\n}\nfunction safeExecute(path, lifecycle, ...args) {\n    const instance = instances.get(path);\n    if (instance == null) {\n        return;\n    }\n    const func = hooks.call('getLifecycle', instance, lifecycle);\n    if (isArray(func)) {\n        const res = func.map(fn => fn.apply(instance, args));\n        return res[0];\n    }\n    if (!isFunction(func)) {\n        return;\n    }\n    return func.apply(instance, args);\n}\nfunction stringify(obj) {\n    if (obj == null) {\n        return '';\n    }\n    const path = Object.keys(obj).map((key) => {\n        return key + '=' + obj[key];\n    }).join('&');\n    return path === '' ? path : '?' + path;\n}\nfunction getPath(id, options) {\n    const idx = id.indexOf('?');\n    if (process.env.TARO_PLATFORM === 'web') {\n        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options === null || options === void 0 ? void 0 : options.stamp) ? { stamp: options.stamp } : {})}`;\n    }\n    else {\n        return `${idx > -1 ? id.substring(0, idx) : id}${stringify(options)}`;\n    }\n}\nfunction getOnReadyEventKey(path) {\n    return path + '.' + ON_READY;\n}\nfunction getOnShowEventKey(path) {\n    return path + '.' + ON_SHOW;\n}\nfunction getOnHideEventKey(path) {\n    return path + '.' + ON_HIDE;\n}\nfunction createPageConfig(component, pageName, data, pageConfig) {\n    // 小程序 Page 构造器是一个傲娇小公主，不能把复杂的对象挂载到参数上\n    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;\n    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES,] = hooks.call('getMiniLifecycleImpl').page;\n    let pageElement = null;\n    let unmounting = false;\n    let prepareMountList = [];\n    function setCurrentRouter(page) {\n        const router = process.env.TARO_PLATFORM === 'web' ? page.$taroPath : page.route || page.__route__ || page.$taroPath;\n        Current.router = {\n            params: page.$taroParams,\n            path: addLeadingSlash(router),\n            $taroPath: page.$taroPath,\n            onReady: getOnReadyEventKey(id),\n            onShow: getOnShowEventKey(id),\n            onHide: getOnHideEventKey(id)\n        };\n        if (!isUndefined(page.exitState)) {\n            Current.router.exitState = page.exitState;\n        }\n    }\n    let loadResolver;\n    let hasLoaded;\n    const config = {\n        [ONLOAD](options = {}, cb) {\n            hasLoaded = new Promise(resolve => { loadResolver = resolve; });\n            perf.start(PAGE_INIT);\n            Current.page = this;\n            this.config = pageConfig || {};\n            // this.$taroPath 是页面唯一标识\n            const uniqueOptions = Object.assign({}, options, { $taroTimestamp: Date.now() });\n            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);\n            if (process.env.TARO_PLATFORM === 'web') {\n                config.path = $taroPath;\n            }\n            // this.$taroParams 作为暴露给开发者的页面参数对象，可以被随意修改\n            if (this.$taroParams == null) {\n                this.$taroParams = uniqueOptions;\n            }\n            setCurrentRouter(this);\n            // 初始化当前页面的上下文信息\n            if (process.env.TARO_PLATFORM !== 'web') {\n                window$1.trigger(CONTEXT_ACTIONS.INIT, $taroPath);\n            }\n            const mount = () => {\n                Current.app.mount(component, $taroPath, () => {\n                    pageElement = env.document.getElementById($taroPath);\n                    ensure(pageElement !== null, '没有找到页面实例。');\n                    safeExecute($taroPath, ON_LOAD, this.$taroParams);\n                    loadResolver();\n                    if (process.env.TARO_PLATFORM !== 'web') {\n                        pageElement.ctx = this;\n                        pageElement.performUpdate(true, cb);\n                    }\n                    else {\n                        isFunction(cb) && cb();\n                    }\n                });\n            };\n            if (unmounting) {\n                prepareMountList.push(mount);\n            }\n            else {\n                mount();\n            }\n        },\n        [ONUNLOAD]() {\n            const $taroPath = this.$taroPath;\n            // 销毁当前页面的上下文信息\n            if (process.env.TARO_PLATFORM !== 'web') {\n                window$1.trigger(CONTEXT_ACTIONS.DESTORY, $taroPath);\n            }\n            // 触发onUnload生命周期\n            safeExecute($taroPath, ONUNLOAD);\n            unmounting = true;\n            Current.app.unmount($taroPath, () => {\n                unmounting = false;\n                instances.delete($taroPath);\n                if (pageElement) {\n                    pageElement.ctx = null;\n                    pageElement = null;\n                }\n                if (prepareMountList.length) {\n                    prepareMountList.forEach(fn => fn());\n                    prepareMountList = [];\n                }\n            });\n        },\n        [ONREADY]() {\n            hasLoaded.then(() => {\n                // 触发生命周期\n                safeExecute(this.$taroPath, ON_READY);\n                // 通过事件触发子组件的生命周期\n                _raf(() => eventCenter.trigger(getOnReadyEventKey(id)));\n                this.onReady.called = true;\n            });\n        },\n        [ONSHOW](options = {}) {\n            hasLoaded.then(() => {\n                // 设置 Current 的 page 和 router\n                Current.page = this;\n                setCurrentRouter(this);\n                // 恢复上下文信息\n                if (process.env.TARO_PLATFORM !== 'web') {\n                    window$1.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);\n                }\n                // 触发生命周期\n                safeExecute(this.$taroPath, ON_SHOW, options);\n                // 通过事件触发子组件的生命周期\n                _raf(() => eventCenter.trigger(getOnShowEventKey(id)));\n            });\n        },\n        [ONHIDE]() {\n            // 缓存当前页面上下文信息\n            if (process.env.TARO_PLATFORM !== 'web') {\n                window$1.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);\n            }\n            // 设置 Current 的 page 和 router\n            if (Current.page === this) {\n                Current.page = null;\n                Current.router = null;\n            }\n            // 触发生命周期\n            safeExecute(this.$taroPath, ON_HIDE);\n            // 通过事件触发子组件的生命周期\n            eventCenter.trigger(getOnHideEventKey(id));\n        }\n    };\n    if (process.env.TARO_PLATFORM === 'web') {\n        config.getOpenerEventChannel = () => {\n            return EventChannel.pageChannel;\n        };\n    }\n    LIFECYCLES.forEach((lifecycle) => {\n        let isDefer = false;\n        lifecycle = lifecycle.replace(/^defer:/, () => {\n            isDefer = true;\n            return '';\n        });\n        config[lifecycle] = function () {\n            const exec = () => safeExecute(this.$taroPath, lifecycle, ...arguments);\n            if (isDefer) {\n                hasLoaded.then(exec);\n            }\n            else {\n                return exec();\n            }\n        };\n    });\n    // onShareAppMessage 和 onShareTimeline 一样，会影响小程序右上方按钮的选项，因此不能默认注册。\n    SIDE_EFFECT_LIFECYCLES.forEach(lifecycle => {\n        var _a;\n        if (component[lifecycle] ||\n            ((_a = component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) ||\n            component[lifecycle.replace(/^on/, 'enable')] ||\n            (pageConfig === null || pageConfig === void 0 ? void 0 : pageConfig[lifecycle.replace(/^on/, 'enable')])) {\n            config[lifecycle] = function (...args) {\n                var _a;\n                const target = (_a = args[0]) === null || _a === void 0 ? void 0 : _a.target;\n                if (target === null || target === void 0 ? void 0 : target.id) {\n                    const id = target.id;\n                    const element = env.document.getElementById(id);\n                    if (element) {\n                        target.dataset = element.dataset;\n                    }\n                }\n                return safeExecute(this.$taroPath, lifecycle, ...args);\n            };\n        }\n    });\n    config.eh = eventHandler;\n    if (!isUndefined(data)) {\n        config.data = data;\n    }\n    hooks.call('modifyPageObject', config);\n    return config;\n}\nfunction createComponentConfig(component, componentName, data) {\n    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;\n    let componentElement = null;\n    const [ATTACHED, DETACHED] = hooks.call('getMiniLifecycleImpl').component;\n    const config = {\n        [ATTACHED]() {\n            var _a;\n            perf.start(PAGE_INIT);\n            this.pageIdCache = ((_a = this.getPageId) === null || _a === void 0 ? void 0 : _a.call(this)) || pageId();\n            const path = getPath(id, { id: this.pageIdCache });\n            Current.app.mount(component, path, () => {\n                componentElement = env.document.getElementById(path);\n                ensure(componentElement !== null, '没有找到组件实例。');\n                this.$taroInstances = instances.get(path);\n                safeExecute(path, ON_LOAD);\n                if (process.env.TARO_PLATFORM !== 'web') {\n                    componentElement.ctx = this;\n                    componentElement.performUpdate(true);\n                }\n            });\n        },\n        [DETACHED]() {\n            const path = getPath(id, { id: this.pageIdCache });\n            Current.app.unmount(path, () => {\n                instances.delete(path);\n                if (componentElement) {\n                    componentElement.ctx = null;\n                }\n            });\n        },\n        methods: {\n            eh: eventHandler\n        }\n    };\n    if (!isUndefined(data)) {\n        config.data = data;\n    }\n    [OPTIONS, EXTERNAL_CLASSES, BEHAVIORS].forEach(key => {\n        var _a;\n        config[key] = (_a = component[key]) !== null && _a !== void 0 ? _a : EMPTY_OBJ;\n    });\n    return config;\n}\nfunction createRecursiveComponentConfig(componentName) {\n    const isCustomWrapper = componentName === CUSTOM_WRAPPER;\n    const [ATTACHED, DETACHED] = hooks.call('getMiniLifecycleImpl').component;\n    const lifeCycles = isCustomWrapper\n        ? {\n            [ATTACHED]() {\n                var _a, _b;\n                const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);\n                if (isString(componentId)) {\n                    customWrapperCache.set(componentId, this);\n                    const el = env.document.getElementById(componentId);\n                    if (el) {\n                        el.ctx = this;\n                    }\n                }\n            },\n            [DETACHED]() {\n                var _a, _b;\n                const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);\n                if (isString(componentId)) {\n                    customWrapperCache.delete(componentId);\n                    const el = env.document.getElementById(componentId);\n                    if (el) {\n                        el.ctx = null;\n                    }\n                }\n            }\n        }\n        : EMPTY_OBJ;\n    return hooks.call('modifyRecursiveComponentConfig', Object.assign({ properties: {\n            i: {\n                type: Object,\n                value: {\n                    [\"nn\" /* Shortcuts.NodeName */]: getComponentsAlias$1(internalComponents)[VIEW]._num\n                }\n            },\n            l: {\n                type: String,\n                value: ''\n            }\n        }, options: {\n            addGlobalClass: true,\n            virtualHost: !isCustomWrapper\n        }, methods: {\n            eh: eventHandler\n        } }, lifeCycles), { isCustomWrapper });\n}\n\nconst TIMEOUT = 100;\nconst nextTick = (cb, ctx) => {\n    const beginTime = Date.now();\n    const router = Current.router;\n    const timerFunc = () => {\n        setTimeout(function () {\n            ctx ? cb.call(ctx) : cb();\n        }, 1);\n    };\n    if (router === null)\n        return timerFunc();\n    const path = router.$taroPath;\n    /**\n     * 三种情况\n     *   1. 调用 nextTick 时，pendingUpdate 已经从 true 变为 false（即已更新完成），那么需要光等 100ms\n     *   2. 调用 nextTick 时，pendingUpdate 为 true，那么刚好可以搭上便车\n     *   3. 调用 nextTick 时，pendingUpdate 还是 false，框架仍未启动更新逻辑，这时最多轮询 100ms，等待 pendingUpdate 变为 true。\n     */\n    function next() {\n        var _a, _b, _c;\n        const pageElement = env.document.getElementById(path);\n        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {\n            if (process.env.TARO_PLATFORM === 'web') {\n                // eslint-disable-next-line dot-notation\n                (_c = (_b = (_a = pageElement.firstChild) === null || _a === void 0 ? void 0 : _a['componentOnReady']) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => {\n                    timerFunc();\n                })) !== null && _c !== void 0 ? _c : timerFunc();\n            }\n            else {\n                pageElement.enqueueUpdateCallback(cb, ctx);\n            }\n        }\n        else if (Date.now() - beginTime > TIMEOUT) {\n            timerFunc();\n        }\n        else {\n            setTimeout(() => next(), 20);\n        }\n    }\n    next();\n};\n\nfunction handleArrayFindPolyfill() {\n    if (!isFunction(Array.prototype.find)) {\n        Object.defineProperty(Array.prototype, 'find', {\n            value(predicate) {\n                if (this == null) {\n                    throw new TypeError('\"this\" is null or not defined');\n                }\n                const o = Object(this);\n                const len = o.length >>> 0;\n                if (!isFunction(predicate)) {\n                    throw new TypeError('predicate must be a function');\n                }\n                const thisArg = arguments[1];\n                let k = 0;\n                while (k < len) {\n                    const kValue = o[k];\n                    if (predicate.call(thisArg, kValue, k, o)) {\n                        return kValue;\n                    }\n                    k++;\n                }\n                return undefined;\n            }\n        });\n    }\n}\nfunction handleArrayIncludesPolyfill() {\n    if (!isFunction(Array.prototype.includes)) {\n        Object.defineProperty(Array.prototype, 'includes', {\n            value(searchElement, fromIndex) {\n                if (this == null) {\n                    throw new TypeError('\"this\" is null or not defined');\n                }\n                const o = Object(this);\n                const len = o.length >>> 0;\n                if (len === 0) {\n                    return false;\n                }\n                const n = fromIndex | 0;\n                let k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n                while (k < len) {\n                    if (o[k] === searchElement) {\n                        return true;\n                    }\n                    k++;\n                }\n                return false;\n            }\n        });\n    }\n}\n\n/* eslint-disable eqeqeq */\nfunction handleIntersectionObserverPolyfill() {\n    // Exit early if all IntersectionObserver and IntersectionObserverEntry\n    // features are natively supported.\n    if ('IntersectionObserver' in window &&\n        'IntersectionObserverEntry' in window &&\n        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n        if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n            // Minimal polyfill for Edge 15's lack of `isIntersecting`\n            // See: https://github.com/w3c/IntersectionObserver/issues/211\n            Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {\n                get: function () {\n                    return this.intersectionRatio > 0;\n                }\n            });\n        }\n    }\n    else {\n        handleIntersectionObserverObjectPolyfill();\n    }\n}\nfunction handleIntersectionObserverObjectPolyfill() {\n    const document = window.document;\n    /**\n     * Creates the global IntersectionObserverEntry constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n     * @param {Object} entry A dictionary of instance properties.\n     * @constructor\n     */\n    function IntersectionObserverEntry(entry) {\n        this.time = entry.time;\n        this.target = entry.target;\n        this.rootBounds = entry.rootBounds;\n        this.boundingClientRect = entry.boundingClientRect;\n        this.intersectionRect = entry.intersectionRect || getEmptyRect();\n        this.isIntersecting = !!entry.intersectionRect;\n        // Calculates the intersection ratio.\n        const targetRect = this.boundingClientRect;\n        const targetArea = targetRect.width * targetRect.height;\n        const intersectionRect = this.intersectionRect;\n        const intersectionArea = intersectionRect.width * intersectionRect.height;\n        // Sets intersection ratio.\n        if (targetArea) {\n            // Round the intersection ratio to avoid floating point math issues:\n            // https://github.com/w3c/IntersectionObserver/issues/324\n            this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n        }\n        else {\n            // If area is zero and is intersecting, sets to 1, otherwise to 0\n            this.intersectionRatio = this.isIntersecting ? 1 : 0;\n        }\n    }\n    /**\n     * Creates the global IntersectionObserver constructor.\n     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n     * @param {Function} callback The function to be invoked after intersection\n     *     changes have queued. The function is not invoked if the queue has\n     *     been emptied by calling the `takeRecords` method.\n     * @param {Object=} opt_options Optional configuration options.\n     * @constructor\n     */\n    function IntersectionObserver(callback, options = {}) {\n        if (!isFunction(callback)) {\n            throw new Error('callback must be a function');\n        }\n        if (options.root && options.root.nodeType != 1) {\n            throw new Error('root must be an Element');\n        }\n        // Binds and throttles `this._checkForIntersections`.\n        this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n        // Private properties.\n        this._callback = callback;\n        this._observationTargets = [];\n        this._queuedEntries = [];\n        this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n        // Public properties.\n        this.thresholds = this._initThresholds(options.threshold);\n        this.root = options.root || null;\n        this.rootMargin = this._rootMarginValues.map(function (margin) {\n            return margin.value + margin.unit;\n        }).join(' ');\n    }\n    /**\n     * The minimum interval within which the document will be checked for\n     * intersection changes.\n     */\n    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n    /**\n     * The frequency in which the polyfill polls for intersection changes.\n     * this can be updated on a per instance basis and must be set prior to\n     * calling `observe` on the first target.\n     */\n    IntersectionObserver.prototype.POLL_INTERVAL = null;\n    /**\n     * Use a mutation observer on the root element\n     * to detect intersection changes.\n     */\n    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n    /**\n     * Starts observing a target element for intersection changes based on\n     * the thresholds values.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.observe = function (target) {\n        const isTargetAlreadyObserved = this._observationTargets.some(function (item) {\n            return item.element == target;\n        });\n        if (isTargetAlreadyObserved)\n            return;\n        if (!(target && target.nodeType == 1)) {\n            throw new Error('target must be an Element');\n        }\n        this._registerInstance();\n        this._observationTargets.push({ element: target, entry: null });\n        this._monitorIntersections();\n        this._checkForIntersections();\n    };\n    /**\n     * Stops observing a target element for intersection changes.\n     * @param {Element} target The DOM element to observe.\n     */\n    IntersectionObserver.prototype.unobserve = function (target) {\n        this._observationTargets =\n            this._observationTargets.filter(function (item) {\n                return item.element != target;\n            });\n        if (!this._observationTargets.length) {\n            this._unmonitorIntersections();\n            this._unregisterInstance();\n        }\n    };\n    /**\n     * Stops observing all target elements for intersection changes.\n     */\n    IntersectionObserver.prototype.disconnect = function () {\n        this._observationTargets = [];\n        this._unmonitorIntersections();\n        this._unregisterInstance();\n    };\n    /**\n     * Returns any queue entries that have not yet been reported to the\n     * callback and clears the queue. This can be used in conjunction with the\n     * callback to obtain the absolute most up-to-date intersection information.\n     * @return {Array} The currently queued entries.\n     */\n    IntersectionObserver.prototype.takeRecords = function () {\n        const records = this._queuedEntries.slice();\n        this._queuedEntries = [];\n        return records;\n    };\n    /**\n     * Accepts the threshold value from the user configuration object and\n     * returns a sorted array of unique threshold values. If a value is not\n     * between 0 and 1 and error is thrown.\n     * @private\n     * @param {Array|number=} opt_threshold An optional threshold value or\n     *     a list of threshold values, defaulting to [0].\n     * @return {Array} A sorted list of unique and valid threshold values.\n     */\n    IntersectionObserver.prototype._initThresholds = function (opt_threshold) {\n        let threshold = opt_threshold || [0];\n        if (!Array.isArray(threshold))\n            threshold = [threshold];\n        return threshold.sort().filter(function (t, i, a) {\n            if (!isNumber(t) || isNaN(t) || t < 0 || t > 1) {\n                throw new Error('threshold must be a number between 0 and 1 inclusively');\n            }\n            return t !== a[i - 1];\n        });\n    };\n    /**\n     * Accepts the rootMargin value from the user configuration object\n     * and returns an array of the four margin values as an object containing\n     * the value and unit properties. If any of the values are not properly\n     * formatted or use a unit other than px or %, and error is thrown.\n     * @private\n     * @param {string=} opt_rootMargin An optional rootMargin value,\n     *     defaulting to '0px'.\n     * @return {Array<Object>} An array of margin objects with the keys\n     *     value and unit.\n     */\n    IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {\n        const marginString = opt_rootMargin || '0px';\n        const margins = marginString.split(/\\s+/).map(function (margin) {\n            const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n            if (!parts) {\n                throw new Error('rootMargin must be specified in pixels or percent');\n            }\n            return { value: parseFloat(parts[1]), unit: parts[2] };\n        });\n        // Handles shorthand.\n        margins[1] = margins[1] || margins[0];\n        margins[2] = margins[2] || margins[0];\n        margins[3] = margins[3] || margins[1];\n        return margins;\n    };\n    /**\n     * Starts polling for intersection changes if the polling is not already\n     * happening, and if the page's visibility state is visible.\n     * @private\n     */\n    IntersectionObserver.prototype._monitorIntersections = function () {\n        if (!this._monitoringIntersections) {\n            this._monitoringIntersections = true;\n            // If a poll interval is set, use polling instead of listening to\n            // resize and scroll events or DOM mutations.\n            if (this.POLL_INTERVAL) {\n                this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);\n            }\n            else {\n                addEvent(window, 'resize', this._checkForIntersections, true);\n                addEvent(document, 'scroll', this._checkForIntersections, true);\n                if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n                    this._domObserver = new MutationObserver(this._checkForIntersections);\n                    this._domObserver.observe(document, {\n                        attributes: true,\n                        childList: true,\n                        characterData: true,\n                        subtree: true\n                    });\n                }\n            }\n        }\n    };\n    /**\n     * Stops polling for intersection changes.\n     * @private\n     */\n    IntersectionObserver.prototype._unmonitorIntersections = function () {\n        if (this._monitoringIntersections) {\n            this._monitoringIntersections = false;\n            clearInterval(this._monitoringInterval);\n            this._monitoringInterval = null;\n            removeEvent(window, 'resize', this._checkForIntersections, true);\n            removeEvent(document, 'scroll', this._checkForIntersections, true);\n            if (this._domObserver) {\n                this._domObserver.disconnect();\n                this._domObserver = null;\n            }\n        }\n    };\n    /**\n     * Scans each observation target for intersection changes and adds them\n     * to the internal entries queue. If new entries are found, it\n     * schedules the callback to be invoked.\n     * @private\n     */\n    IntersectionObserver.prototype._checkForIntersections = function () {\n        const rootIsInDom = this._rootIsInDom();\n        const rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n        this._observationTargets.forEach(function (item) {\n            const target = item.element;\n            const targetRect = getBoundingClientRect(target);\n            const rootContainsTarget = this._rootContainsTarget(target);\n            const oldEntry = item.entry;\n            const intersectionRect = rootIsInDom && rootContainsTarget &&\n                this._computeTargetAndRootIntersection(target, rootRect);\n            const newEntry = item.entry = new IntersectionObserverEntry({\n                time: now(),\n                target: target,\n                boundingClientRect: targetRect,\n                rootBounds: rootRect,\n                intersectionRect: intersectionRect,\n                intersectionRatio: -1,\n                isIntersecting: false,\n            });\n            if (!oldEntry) {\n                this._queuedEntries.push(newEntry);\n            }\n            else if (rootIsInDom && rootContainsTarget) {\n                // If the new entry intersection ratio has crossed any of the\n                // thresholds, add a new entry.\n                if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n                    this._queuedEntries.push(newEntry);\n                }\n            }\n            else {\n                // If the root is not in the DOM or target is not contained within\n                // root but the previous entry for this target had an intersection,\n                // add a new record indicating removal.\n                if (oldEntry && oldEntry.isIntersecting) {\n                    this._queuedEntries.push(newEntry);\n                }\n            }\n        }, this);\n        if (this._queuedEntries.length) {\n            this._callback(this.takeRecords(), this);\n        }\n    };\n    /**\n     * Accepts a target and root rect computes the intersection between then\n     * following the algorithm in the spec.\n     * TODO(philipwalton): at this time clip-path is not considered.\n     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n     * @param {Element} target The target DOM element\n     * @param {Object} rootRect The bounding rect of the root after being\n     *     expanded by the rootMargin value.\n     * @return {?Object} The final intersection rect object or undefined if no\n     *     intersection is found.\n     * @private\n     */\n    IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, rootRect) {\n        // If the element isn't displayed, an intersection can't happen.\n        if (window.getComputedStyle(target).display === 'none')\n            return;\n        const targetRect = getBoundingClientRect(target);\n        let intersectionRect = targetRect;\n        let parent = getParentNode(target);\n        let atRoot = false;\n        while (!atRoot) {\n            let parentRect = null;\n            const parentComputedStyle = parent.nodeType == 1 ?\n                window.getComputedStyle(parent) : {};\n            // If the parent isn't displayed, an intersection can't happen.\n            if (parentComputedStyle.display === 'none')\n                return;\n            if (parent == this.root || parent == document) {\n                atRoot = true;\n                parentRect = rootRect;\n            }\n            else {\n                // If the element has a non-visible overflow, and it's not the <body>\n                // or <html> element, update the intersection rect.\n                // Note: <body> and <html> cannot be clipped to a rect that's not also\n                // the document rect, so no need to compute a new intersection.\n                if (parent != document.body &&\n                    parent != document.documentElement &&\n                    parentComputedStyle.overflow != 'visible') {\n                    parentRect = getBoundingClientRect(parent);\n                }\n            }\n            // If either of the above conditionals set a new parentRect,\n            // calculate new intersection data.\n            if (parentRect) {\n                intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n                if (!intersectionRect)\n                    break;\n            }\n            parent = getParentNode(parent);\n        }\n        return intersectionRect;\n    };\n    /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n    IntersectionObserver.prototype._getRootRect = function () {\n        let rootRect;\n        if (this.root) {\n            rootRect = getBoundingClientRect(this.root);\n        }\n        else {\n            // Use <html>/<body> instead of window since scroll bars affect size.\n            const html = document.documentElement;\n            const body = document.body;\n            rootRect = {\n                top: 0,\n                left: 0,\n                right: html.clientWidth || body.clientWidth,\n                width: html.clientWidth || body.clientWidth,\n                bottom: html.clientHeight || body.clientHeight,\n                height: html.clientHeight || body.clientHeight\n            };\n        }\n        return this._expandRectByRootMargin(rootRect);\n    };\n    /**\n     * Accepts a rect and expands it by the rootMargin value.\n     * @param {Object} rect The rect object to expand.\n     * @return {Object} The expanded rect.\n     * @private\n     */\n    IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {\n        const margins = this._rootMarginValues.map(function (margin, i) {\n            return margin.unit === 'px' ? margin.value :\n                margin.value * (i % 2 ? rect.width : rect.height) / 100;\n        });\n        const newRect = {\n            top: rect.top - margins[0],\n            right: rect.right + margins[1],\n            bottom: rect.bottom + margins[2],\n            left: rect.left - margins[3]\n        };\n        newRect.width = newRect.right - newRect.left;\n        newRect.height = newRect.bottom - newRect.top;\n        return newRect;\n    };\n    /**\n     * Accepts an old and new entry and returns true if at least one of the\n     * threshold values has been crossed.\n     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n     *    particular target element or null if no previous entry exists.\n     * @param {IntersectionObserverEntry} newEntry The current entry for a\n     *    particular target element.\n     * @return {boolean} Returns true if a any threshold has been crossed.\n     * @private\n     */\n    IntersectionObserver.prototype._hasCrossedThreshold =\n        function (oldEntry, newEntry) {\n            // To make comparing easier, an entry that has a ratio of 0\n            // but does not actually intersect is given a value of -1\n            const oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;\n            const newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;\n            // Ignore unchanged ratios\n            if (oldRatio === newRatio)\n                return;\n            for (let i = 0; i < this.thresholds.length; i++) {\n                const threshold = this.thresholds[i];\n                // Return true if an entry matches a threshold or if the new ratio\n                // and the old ratio are on the opposite sides of a threshold.\n                if (threshold == oldRatio || threshold == newRatio ||\n                    threshold < oldRatio !== threshold < newRatio) {\n                    return true;\n                }\n            }\n        };\n    /**\n     * Returns whether or not the root element is an element and is in the DOM.\n     * @return {boolean} True if the root element is an element and is in the DOM.\n     * @private\n     */\n    IntersectionObserver.prototype._rootIsInDom = function () {\n        return !this.root || containsDeep(document, this.root);\n    };\n    /**\n     * Returns whether or not the target element is a child of root.\n     * @param {Element} target The target element to check.\n     * @return {boolean} True if the target element is a child of root.\n     * @private\n     */\n    IntersectionObserver.prototype._rootContainsTarget = function (target) {\n        return containsDeep(this.root || document, target);\n    };\n    /**\n     * Adds the instance to the global IntersectionObserver registry if it isn't\n     * already present.\n     * @private\n     */\n    IntersectionObserver.prototype._registerInstance = function () {\n    };\n    /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n    IntersectionObserver.prototype._unregisterInstance = function () {\n    };\n    /**\n     * Returns the result of the performance.now() method or null in browsers\n     * that don't support the API.\n     * @return {number} The elapsed time since the page was requested.\n     */\n    function now() {\n        return window.performance && performance.now && performance.now();\n    }\n    /**\n     * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n     * @param {Node} node The DOM node to add the event handler to.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to add.\n     * @param {boolean} opt_useCapture Optionally adds the even to the capture\n     *     phase. Note: this only works in modern browsers.\n     */\n    function addEvent(node, event, fn, opt_useCapture) {\n        if (isFunction(node.addEventListener)) {\n            node.addEventListener(event, fn, opt_useCapture || false);\n        }\n        else if (isFunction(node.attachEvent)) {\n            node.attachEvent('on' + event, fn);\n        }\n    }\n    /**\n     * Removes a previously added event handler from a DOM node.\n     * @param {Node} node The DOM node to remove the event handler from.\n     * @param {string} event The event name.\n     * @param {Function} fn The event handler to remove.\n     * @param {boolean} opt_useCapture If the event handler was added with this\n     *     flag set to true, it should be set to true here in order to remove it.\n     */\n    function removeEvent(node, event, fn, opt_useCapture) {\n        if (isFunction(node.removeEventListener)) {\n            node.removeEventListener(event, fn, opt_useCapture || false);\n        }\n        else if (isFunction(node.detatchEvent)) {\n            node.detatchEvent('on' + event, fn);\n        }\n    }\n    /**\n     * Returns the intersection between two rect objects.\n     * @param {Object} rect1 The first rect.\n     * @param {Object} rect2 The second rect.\n     * @return {?Object} The intersection rect or undefined if no intersection\n     *     is found.\n     */\n    function computeRectIntersection(rect1, rect2) {\n        const top = Math.max(rect1.top, rect2.top);\n        const bottom = Math.min(rect1.bottom, rect2.bottom);\n        const left = Math.max(rect1.left, rect2.left);\n        const right = Math.min(rect1.right, rect2.right);\n        const width = right - left;\n        const height = bottom - top;\n        return (width >= 0 && height >= 0) && {\n            top: top,\n            bottom: bottom,\n            left: left,\n            right: right,\n            width: width,\n            height: height\n        };\n    }\n    /**\n     * Shims the native getBoundingClientRect for compatibility with older IE.\n     * @param {Element} el The element whose bounding rect to get.\n     * @return {Object} The (possibly shimmed) rect of the element.\n     */\n    function getBoundingClientRect(el) {\n        let rect;\n        try {\n            rect = el.getBoundingClientRect();\n        }\n        catch (err) {\n            // Ignore Windows 7 IE11 \"Unspecified error\"\n            // https://github.com/w3c/IntersectionObserver/pull/205\n        }\n        if (!rect)\n            return getEmptyRect();\n        // Older IE\n        if (!(rect.width && rect.height)) {\n            rect = {\n                top: rect.top,\n                right: rect.right,\n                bottom: rect.bottom,\n                left: rect.left,\n                width: rect.right - rect.left,\n                height: rect.bottom - rect.top\n            };\n        }\n        return rect;\n    }\n    /**\n     * Returns an empty rect object. An empty rect is returned when an element\n     * is not in the DOM.\n     * @return {Object} The empty rect.\n     */\n    function getEmptyRect() {\n        return {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    /**\n     * Checks to see if a parent element contains a child element (including inside\n     * shadow DOM).\n     * @param {Node} parent The parent element.\n     * @param {Node} child The child element.\n     * @return {boolean} True if the parent node contains the child node.\n     */\n    function containsDeep(parent, child) {\n        let node = child;\n        while (node) {\n            if (node == parent)\n                return true;\n            node = getParentNode(node);\n        }\n        return false;\n    }\n    /**\n     * Gets the parent node of an element or its host element if the parent node\n     * is a shadow root.\n     * @param {Node} node The node whose parent to get.\n     * @return {Node|null} The parent node or null if no parent exists.\n     */\n    function getParentNode(node) {\n        const parent = node.parentNode;\n        if (parent && parent.nodeType == 11 && parent.host) {\n            // If the parent is a shadow root, return the host element.\n            return parent.host;\n        }\n        if (parent && parent.assignedSlot) {\n            // If the parent is distributed in a <slot>, return the parent of a slot.\n            return parent.assignedSlot.parentNode;\n        }\n        return parent;\n    }\n    // Exposes the constructors globally.\n    window.IntersectionObserver = IntersectionObserver;\n    window.IntersectionObserverEntry = IntersectionObserverEntry;\n}\n\nfunction handleObjectAssignPolyfill() {\n    if (!isFunction(Object.assign)) {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.assign = function (target) {\n            if (target == null) { // TypeError if undefined or null\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n            const to = Object(target);\n            for (let index = 1; index < arguments.length; index++) {\n                const nextSource = arguments[index];\n                if (nextSource != null) { // Skip over if undefined or null\n                    for (const nextKey in nextSource) {\n                        // Avoid bugs when hasOwnProperty is shadowed\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n            }\n            return to;\n        };\n    }\n}\nfunction handleObjectEntriesPolyfill() {\n    if (!isFunction(Object.entries)) {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.entries = function (obj) {\n            if (obj == null) { // TypeError if undefined or null\n                throw new TypeError('Cannot convert undefined or null to object');\n            }\n            const to = [];\n            if (obj != null) { // Skip over if undefined or null\n                for (const key in obj) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        to.push([key, obj[key]]);\n                    }\n                }\n            }\n            return to;\n        };\n    }\n}\nfunction handleObjectDefinePropertyPolyfill() {\n    if (!isFunction(Object.defineProperties)) {\n        Object.defineProperties = function (obj, properties) {\n            function convertToDescriptor(desc) {\n                function hasProperty(obj, prop) {\n                    return Object.prototype.hasOwnProperty.call(obj, prop);\n                }\n                if (!isObject(desc)) {\n                    throw new TypeError('bad desc');\n                }\n                const d = {};\n                if (hasProperty(desc, 'enumerable'))\n                    d.enumerable = !!desc.enumerable;\n                if (hasProperty(desc, 'configurable')) {\n                    d.configurable = !!desc.configurable;\n                }\n                if (hasProperty(desc, 'value'))\n                    d.value = desc.value;\n                if (hasProperty(desc, 'writable'))\n                    d.writable = !!desc.writable;\n                if (hasProperty(desc, 'get')) {\n                    const g = desc.get;\n                    if (!isFunction(g) && !isUndefined(g)) {\n                        throw new TypeError('bad get');\n                    }\n                    d.get = g;\n                }\n                if (hasProperty(desc, 'set')) {\n                    const s = desc.set;\n                    if (!isFunction(s) && !isUndefined(s)) {\n                        throw new TypeError('bad set');\n                    }\n                    d.set = s;\n                }\n                if (('get' in d || 'set' in d) && ('value' in d || 'writable' in d)) {\n                    throw new TypeError('identity-confused descriptor');\n                }\n                return d;\n            }\n            if (!isObject(obj))\n                throw new TypeError('bad obj');\n            properties = Object(properties);\n            const keys = Object.keys(properties);\n            const descs = [];\n            for (let i = 0; i < keys.length; i++) {\n                descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n            }\n            for (let i = 0; i < descs.length; i++) {\n                Object.defineProperty(obj, descs[i][0], descs[i][1]);\n            }\n            return obj;\n        };\n    }\n}\n\nfunction handlePolyfill() {\n    if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'Object' || process.env.SUPPORT_TARO_POLYFILL === 'Object.assign') {\n        handleObjectAssignPolyfill();\n    }\n    if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'Object' || process.env.SUPPORT_TARO_POLYFILL === 'Object.entries') {\n        handleObjectEntriesPolyfill();\n    }\n    if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'Object' || process.env.SUPPORT_TARO_POLYFILL === 'Object.defineProperty') {\n        handleObjectDefinePropertyPolyfill();\n    }\n    if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'Array' || process.env.SUPPORT_TARO_POLYFILL === 'Array.find') {\n        handleArrayFindPolyfill();\n    }\n    if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'Array' || process.env.SUPPORT_TARO_POLYFILL === 'Array.includes') {\n        handleArrayIncludesPolyfill();\n    }\n    // Exit early if we're not running in a browser.\n    if (process.env.TARO_PLATFORM === 'web' && isObject(window)) {\n        if (process.env.SUPPORT_TARO_POLYFILL === 'enabled' || process.env.SUPPORT_TARO_POLYFILL === 'IntersectionObserver') {\n            handleIntersectionObserverPolyfill();\n        }\n    }\n}\nif (process.env.SUPPORT_TARO_POLYFILL !== 'disabled' && process.env.TARO_PLATFORM !== 'web') {\n    handlePolyfill();\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'A', { enumerable: true, configurable: true, get: function() { return A; } });Object.defineProperty(exports, 'APP', { enumerable: true, configurable: true, get: function() { return APP; } });Object.defineProperty(exports, 'BEHAVIORS', { enumerable: true, configurable: true, get: function() { return BEHAVIORS; } });Object.defineProperty(exports, 'BODY', { enumerable: true, configurable: true, get: function() { return BODY; } });Object.defineProperty(exports, 'CATCHMOVE', { enumerable: true, configurable: true, get: function() { return CATCHMOVE; } });Object.defineProperty(exports, 'CATCH_VIEW', { enumerable: true, configurable: true, get: function() { return CATCH_VIEW; } });Object.defineProperty(exports, 'CHANGE', { enumerable: true, configurable: true, get: function() { return CHANGE; } });Object.defineProperty(exports, 'CLASS', { enumerable: true, configurable: true, get: function() { return CLASS; } });Object.defineProperty(exports, 'COMMENT', { enumerable: true, configurable: true, get: function() { return COMMENT; } });Object.defineProperty(exports, 'COMPILE_MODE', { enumerable: true, configurable: true, get: function() { return COMPILE_MODE; } });Object.defineProperty(exports, 'CONFIRM', { enumerable: true, configurable: true, get: function() { return CONFIRM; } });Object.defineProperty(exports, 'CONTAINER', { enumerable: true, configurable: true, get: function() { return CONTAINER; } });Object.defineProperty(exports, 'CONTEXT_ACTIONS', { enumerable: true, configurable: true, get: function() { return CONTEXT_ACTIONS; } });Object.defineProperty(exports, 'CURRENT_TARGET', { enumerable: true, configurable: true, get: function() { return CURRENT_TARGET; } });Object.defineProperty(exports, 'CUSTOM_WRAPPER', { enumerable: true, configurable: true, get: function() { return CUSTOM_WRAPPER; } });Object.defineProperty(exports, 'Current', { enumerable: true, configurable: true, get: function() { return Current; } });Object.defineProperty(exports, 'DATASET', { enumerable: true, configurable: true, get: function() { return DATASET; } });Object.defineProperty(exports, 'DATE', { enumerable: true, configurable: true, get: function() { return DATE; } });Object.defineProperty(exports, 'DOCUMENT_ELEMENT_NAME', { enumerable: true, configurable: true, get: function() { return DOCUMENT_ELEMENT_NAME; } });Object.defineProperty(exports, 'DOCUMENT_FRAGMENT', { enumerable: true, configurable: true, get: function() { return DOCUMENT_FRAGMENT; } });Object.defineProperty(exports, 'EVENT_CALLBACK_RESULT', { enumerable: true, configurable: true, get: function() { return EVENT_CALLBACK_RESULT; } });Object.defineProperty(exports, 'EXTERNAL_CLASSES', { enumerable: true, configurable: true, get: function() { return EXTERNAL_CLASSES; } });Object.defineProperty(exports, 'FOCUS', { enumerable: true, configurable: true, get: function() { return FOCUS; } });Object.defineProperty(exports, 'FormElement', { enumerable: true, configurable: true, get: function() { return FormElement; } });Object.defineProperty(exports, 'HEAD', { enumerable: true, configurable: true, get: function() { return HEAD; } });Object.defineProperty(exports, 'HOOKS_APP_ID', { enumerable: true, configurable: true, get: function() { return HOOKS_APP_ID; } });Object.defineProperty(exports, 'HTML', { enumerable: true, configurable: true, get: function() { return HTML; } });Object.defineProperty(exports, 'History', { enumerable: true, configurable: true, get: function() { return History; } });Object.defineProperty(exports, 'ID', { enumerable: true, configurable: true, get: function() { return ID; } });Object.defineProperty(exports, 'INPUT', { enumerable: true, configurable: true, get: function() { return INPUT; } });Object.defineProperty(exports, 'KEY_CODE', { enumerable: true, configurable: true, get: function() { return KEY_CODE; } });Object.defineProperty(exports, 'Location', { enumerable: true, configurable: true, get: function() { return Location; } });Object.defineProperty(exports, 'MutationObserver', { enumerable: true, configurable: true, get: function() { return MutationObserver$1; } });Object.defineProperty(exports, 'OBJECT', { enumerable: true, configurable: true, get: function() { return OBJECT; } });Object.defineProperty(exports, 'ON_HIDE', { enumerable: true, configurable: true, get: function() { return ON_HIDE; } });Object.defineProperty(exports, 'ON_LOAD', { enumerable: true, configurable: true, get: function() { return ON_LOAD; } });Object.defineProperty(exports, 'ON_READY', { enumerable: true, configurable: true, get: function() { return ON_READY; } });Object.defineProperty(exports, 'ON_SHOW', { enumerable: true, configurable: true, get: function() { return ON_SHOW; } });Object.defineProperty(exports, 'OPTIONS', { enumerable: true, configurable: true, get: function() { return OPTIONS; } });Object.defineProperty(exports, 'PAGE_INIT', { enumerable: true, configurable: true, get: function() { return PAGE_INIT; } });Object.defineProperty(exports, 'PROPERTY_THRESHOLD', { enumerable: true, configurable: true, get: function() { return PROPERTY_THRESHOLD; } });Object.defineProperty(exports, 'PROPS', { enumerable: true, configurable: true, get: function() { return PROPS; } });Object.defineProperty(exports, 'PURE_VIEW', { enumerable: true, configurable: true, get: function() { return PURE_VIEW; } });Object.defineProperty(exports, 'ROOT_STR', { enumerable: true, configurable: true, get: function() { return ROOT_STR; } });Object.defineProperty(exports, 'SET_DATA', { enumerable: true, configurable: true, get: function() { return SET_DATA; } });Object.defineProperty(exports, 'SET_TIMEOUT', { enumerable: true, configurable: true, get: function() { return SET_TIMEOUT; } });Object.defineProperty(exports, 'STATIC_VIEW', { enumerable: true, configurable: true, get: function() { return STATIC_VIEW; } });Object.defineProperty(exports, 'STYLE', { enumerable: true, configurable: true, get: function() { return STYLE; } });Object.defineProperty(exports, 'SVGElement', { enumerable: true, configurable: true, get: function() { return SVGElement; } });Object.defineProperty(exports, 'Style', { enumerable: true, configurable: true, get: function() { return Style; } });Object.defineProperty(exports, 'TARGET', { enumerable: true, configurable: true, get: function() { return TARGET; } });Object.defineProperty(exports, 'TARO_RUNTIME', { enumerable: true, configurable: true, get: function() { return TARO_RUNTIME; } });Object.defineProperty(exports, 'TIME_STAMP', { enumerable: true, configurable: true, get: function() { return TIME_STAMP; } });Object.defineProperty(exports, 'TOUCHMOVE', { enumerable: true, configurable: true, get: function() { return TOUCHMOVE; } });Object.defineProperty(exports, 'TYPE', { enumerable: true, configurable: true, get: function() { return TYPE; } });Object.defineProperty(exports, 'TaroElement', { enumerable: true, configurable: true, get: function() { return TaroElement; } });Object.defineProperty(exports, 'TaroEvent', { enumerable: true, configurable: true, get: function() { return TaroEvent; } });Object.defineProperty(exports, 'TaroNode', { enumerable: true, configurable: true, get: function() { return TaroNode; } });Object.defineProperty(exports, 'TaroRootElement', { enumerable: true, configurable: true, get: function() { return TaroRootElement; } });Object.defineProperty(exports, 'TaroText', { enumerable: true, configurable: true, get: function() { return TaroText; } });Object.defineProperty(exports, 'UID', { enumerable: true, configurable: true, get: function() { return UID; } });Object.defineProperty(exports, 'URL', { enumerable: true, configurable: true, get: function() { return URL; } });Object.defineProperty(exports, 'URLSearchParams', { enumerable: true, configurable: true, get: function() { return URLSearchParams; } });Object.defineProperty(exports, 'VALUE', { enumerable: true, configurable: true, get: function() { return VALUE; } });Object.defineProperty(exports, 'VIEW', { enumerable: true, configurable: true, get: function() { return VIEW; } });Object.defineProperty(exports, 'addLeadingSlash', { enumerable: true, configurable: true, get: function() { return addLeadingSlash; } });Object.defineProperty(exports, 'cancelAnimationFrame', { enumerable: true, configurable: true, get: function() { return _caf; } });Object.defineProperty(exports, 'createComponentConfig', { enumerable: true, configurable: true, get: function() { return createComponentConfig; } });Object.defineProperty(exports, 'createEvent', { enumerable: true, configurable: true, get: function() { return createEvent; } });Object.defineProperty(exports, 'createPageConfig', { enumerable: true, configurable: true, get: function() { return createPageConfig; } });Object.defineProperty(exports, 'createRecursiveComponentConfig', { enumerable: true, configurable: true, get: function() { return createRecursiveComponentConfig; } });Object.defineProperty(exports, 'document', { enumerable: true, configurable: true, get: function() { return document$1; } });Object.defineProperty(exports, 'env', { enumerable: true, configurable: true, get: function() { return env; } });Object.defineProperty(exports, 'eventCenter', { enumerable: true, configurable: true, get: function() { return eventCenter; } });Object.defineProperty(exports, 'eventHandler', { enumerable: true, configurable: true, get: function() { return eventHandler; } });Object.defineProperty(exports, 'eventSource', { enumerable: true, configurable: true, get: function() { return eventSource; } });Object.defineProperty(exports, 'getComputedStyle', { enumerable: true, configurable: true, get: function() { return getComputedStyle; } });Object.defineProperty(exports, 'getCurrentInstance', { enumerable: true, configurable: true, get: function() { return getCurrentInstance; } });Object.defineProperty(exports, 'getCurrentPage', { enumerable: true, configurable: true, get: function() { return getCurrentPage; } });Object.defineProperty(exports, 'getHomePage', { enumerable: true, configurable: true, get: function() { return getHomePage; } });Object.defineProperty(exports, 'getOnHideEventKey', { enumerable: true, configurable: true, get: function() { return getOnHideEventKey; } });Object.defineProperty(exports, 'getOnReadyEventKey', { enumerable: true, configurable: true, get: function() { return getOnReadyEventKey; } });Object.defineProperty(exports, 'getOnShowEventKey', { enumerable: true, configurable: true, get: function() { return getOnShowEventKey; } });Object.defineProperty(exports, 'getPageInstance', { enumerable: true, configurable: true, get: function() { return getPageInstance; } });Object.defineProperty(exports, 'getPath', { enumerable: true, configurable: true, get: function() { return getPath; } });Object.defineProperty(exports, 'handlePolyfill', { enumerable: true, configurable: true, get: function() { return handlePolyfill; } });Object.defineProperty(exports, 'hasBasename', { enumerable: true, configurable: true, get: function() { return hasBasename; } });Object.defineProperty(exports, 'history', { enumerable: true, configurable: true, get: function() { return history; } });Object.defineProperty(exports, 'hydrate', { enumerable: true, configurable: true, get: function() { return hydrate; } });Object.defineProperty(exports, 'incrementId', { enumerable: true, configurable: true, get: function() { return incrementId; } });Object.defineProperty(exports, 'injectPageInstance', { enumerable: true, configurable: true, get: function() { return injectPageInstance; } });Object.defineProperty(exports, 'isHasExtractProp', { enumerable: true, configurable: true, get: function() { return isHasExtractProp; } });Object.defineProperty(exports, 'location', { enumerable: true, configurable: true, get: function() { return location; } });Object.defineProperty(exports, 'navigator', { enumerable: true, configurable: true, get: function() { return nav; } });Object.defineProperty(exports, 'nextTick', { enumerable: true, configurable: true, get: function() { return nextTick; } });Object.defineProperty(exports, 'now', { enumerable: true, configurable: true, get: function() { return now; } });Object.defineProperty(exports, 'options', { enumerable: true, configurable: true, get: function() { return options; } });Object.defineProperty(exports, 'parseUrl', { enumerable: true, configurable: true, get: function() { return parseUrl; } });Object.defineProperty(exports, 'removePageInstance', { enumerable: true, configurable: true, get: function() { return removePageInstance; } });Object.defineProperty(exports, 'requestAnimationFrame', { enumerable: true, configurable: true, get: function() { return _raf; } });Object.defineProperty(exports, 'safeExecute', { enumerable: true, configurable: true, get: function() { return safeExecute; } });Object.defineProperty(exports, 'stringify', { enumerable: true, configurable: true, get: function() { return stringify; } });Object.defineProperty(exports, 'stripBasename', { enumerable: true, configurable: true, get: function() { return stripBasename; } });Object.defineProperty(exports, 'stripSuffix', { enumerable: true, configurable: true, get: function() { return stripSuffix; } });Object.defineProperty(exports, 'stripTrailing', { enumerable: true, configurable: true, get: function() { return stripTrailing; } });Object.defineProperty(exports, 'window', { enumerable: true, configurable: true, get: function() { return window$1; } });\n//# sourceMappingURL=runtime.esm.js.map\n"]}