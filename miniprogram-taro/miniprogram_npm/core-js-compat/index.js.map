{"version":3,"sources":["index.js","compat.js","helpers.js","get-modules-list-for-target-version.js","targets-parser.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst compat = require('./compat');\nconst data = require('./data');\nconst entries = require('./entries');\nconst getModulesListForTargetVersion = require('./get-modules-list-for-target-version');\nconst modules = require('./modules');\n\nmodule.exports = Object.assign(compat, {\n  compat,\n  data,\n  entries,\n  getModulesListForTargetVersion,\n  modules,\n});\n","\nconst { compare, filterOutStabilizedProposals, has, intersection } = require('./helpers');\nconst data = require('./data');\nconst entries = require('./entries');\nconst getModulesListForTargetVersion = require('./get-modules-list-for-target-version');\nconst allModules = require('./modules');\nconst targetsParser = require('./targets-parser');\n\nfunction throwInvalidFilter(filter) {\n  throw new TypeError(`Specified invalid module name or pattern: ${ filter }`);\n}\n\nfunction atLeastSomeModules(modules, filter) {\n  if (!modules.length) throwInvalidFilter(filter);\n  return modules;\n}\n\nfunction getModules(filter) {\n  if (typeof filter == 'string') {\n    if (has(entries, filter)) return entries[filter];\n    return atLeastSomeModules(allModules.filter(it => it.startsWith(filter)), filter);\n  }\n  if (filter instanceof RegExp) return atLeastSomeModules(allModules.filter(it => filter.test(it)), filter);\n  throwInvalidFilter(filter);\n}\n\nfunction normalizeModules(option) {\n  // TODO: use `.flatMap` in core-js@4\n  return new Set(Array.isArray(option) ? [].concat(...option.map(getModules)) : getModules(option));\n}\n\nfunction checkModule(name, targets) {\n  const result = {\n    required: !targets,\n    targets: {},\n  };\n\n  if (!targets) return result;\n\n  const requirements = data[name];\n\n  for (const [engine, version] of targets) {\n    if (!has(requirements, engine) || compare(version, '<', requirements[engine])) {\n      result.required = true;\n      result.targets[engine] = version;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = function ({\n  filter = null, // TODO: Obsolete, remove from `core-js@4`\n  modules = null,\n  exclude = [],\n  targets = null,\n  version = null,\n  inverse = false,\n} = {}) {\n  if (modules === null || modules === undefined) modules = filter;\n  inverse = !!inverse;\n\n  const parsedTargets = targets ? targetsParser(targets) : null;\n\n  const result = {\n    list: [],\n    targets: {},\n  };\n\n  exclude = normalizeModules(exclude);\n\n  modules = modules ? [...normalizeModules(modules)] : allModules;\n\n  if (exclude.size) modules = modules.filter(it => !exclude.has(it));\n\n  modules = intersection(modules, version ? getModulesListForTargetVersion(version) : allModules);\n\n  if (!inverse) modules = filterOutStabilizedProposals(modules);\n\n  for (const key of modules) {\n    const check = checkModule(key, parsedTargets);\n\n    if (check.required ^ inverse) {\n      result.list.push(key);\n      result.targets[key] = check.targets;\n    }\n  }\n\n  return result;\n};\n","\n// eslint-disable-next-line es/no-object-hasown -- safe\nconst has = Object.hasOwn || Function.call.bind({}.hasOwnProperty);\n\nconst VERSION_PATTERN = /(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?/;\n\nclass SemVer {\n  constructor(input) {\n    const match = VERSION_PATTERN.exec(input);\n    if (!match) throw new TypeError(`Invalid version: ${ input }`);\n    const [, $major, $minor, $patch] = match;\n    this.major = +$major;\n    this.minor = $minor ? +$minor : 0;\n    this.patch = $patch ? +$patch : 0;\n  }\n  toString() {\n    return `${ this.major }.${ this.minor }.${ this.patch }`;\n  }\n}\n\nfunction semver(input) {\n  return input instanceof SemVer ? input : new SemVer(input);\n}\n\nfunction compare($a, operator, $b) {\n  const a = semver($a);\n  const b = semver($b);\n  for (const component of ['major', 'minor', 'patch']) {\n    if (a[component] < b[component]) return operator === '<' || operator === '<=' || operator === '!=';\n    if (a[component] > b[component]) return operator === '>' || operator === '>=' || operator === '!=';\n  } return operator === '==' || operator === '<=' || operator === '>=';\n}\n\nfunction filterOutStabilizedProposals(modules) {\n  const modulesSet = new Set(modules);\n\n  for (const $module of modulesSet) {\n    if ($module.startsWith('esnext.') && modulesSet.has($module.replace(/^esnext\\./, 'es.'))) {\n      modulesSet.delete($module);\n    }\n  }\n\n  return [...modulesSet];\n}\n\nfunction intersection(list, order) {\n  const set = list instanceof Set ? list : new Set(list);\n  return order.filter(name => set.has(name));\n}\n\nfunction sortObjectByKey(object, fn) {\n  return Object.keys(object).sort(fn).reduce((memo, key) => {\n    memo[key] = object[key];\n    return memo;\n  }, {});\n}\n\nmodule.exports = {\n  compare,\n  filterOutStabilizedProposals,\n  has,\n  intersection,\n  semver,\n  sortObjectByKey,\n};\n","\nconst { compare, intersection, semver } = require('./helpers');\nconst modulesByVersions = require('./modules-by-versions');\nconst modules = require('./modules');\n\nmodule.exports = function (raw) {\n  const corejs = semver(raw);\n  if (corejs.major !== 3) {\n    throw new RangeError('This version of `core-js-compat` works only with `core-js@3`.');\n  }\n  const result = [];\n  for (const version of Object.keys(modulesByVersions)) {\n    if (compare(version, '<=', corejs)) {\n      result.push(...modulesByVersions[version]);\n    }\n  }\n  return intersection(result, modules);\n};\n","\nconst browserslist = require('browserslist');\nconst { compare, has } = require('./helpers');\nconst external = require('./external');\n\nconst aliases = new Map([\n  ['and_chr', 'chrome-android'],\n  ['and_ff', 'firefox-android'],\n  ['ie_mob', 'ie'],\n  ['ios_saf', 'ios'],\n  ['oculus', 'quest'],\n  ['op_mob', 'opera-android'],\n  // TODO: Remove from `core-js@4`\n  ['opera_mobile', 'opera-android'],\n  ['react', 'react-native'],\n  ['reactnative', 'react-native'],\n]);\n\nconst validTargets = new Set([\n  'android',\n  'bun',\n  'chrome',\n  'chrome-android',\n  'deno',\n  'edge',\n  'electron',\n  'firefox',\n  'firefox-android',\n  'hermes',\n  'ie',\n  'ios',\n  'node',\n  'opera',\n  'opera-android',\n  'phantom',\n  'quest',\n  'react-native',\n  'rhino',\n  'safari',\n  'samsung',\n]);\n\nconst toLowerKeys = function (object) {\n  return Object.entries(object).reduce((accumulator, [key, value]) => {\n    accumulator[key.toLowerCase()] = value;\n    return accumulator;\n  }, {});\n};\n\nmodule.exports = function (targets) {\n  const { browsers, esmodules, node, ...rest } = (typeof targets != 'object' || Array.isArray(targets))\n    ? { browsers: targets } : toLowerKeys(targets);\n\n  const list = Object.entries(rest);\n\n  const normalizedESModules = esmodules === 'intersect' ? 'intersect' : !!esmodules;\n\n  if (browsers && normalizedESModules !== true) {\n    if (typeof browsers == 'string' || Array.isArray(browsers)) {\n      list.push(...browserslist(browsers).map(it => it.split(' ')));\n    } else {\n      list.push(...Object.entries(browsers));\n    }\n  }\n  if (normalizedESModules === true) {\n    list.push(...Object.entries(external.modules));\n  }\n  if (node) {\n    list.push(['node', node === 'current' ? process.versions.node : node]);\n  }\n\n  const normalized = list.map(([engine, version]) => {\n    if (has(browserslist.aliases, engine)) {\n      engine = browserslist.aliases[engine];\n    }\n    if (aliases.has(engine)) {\n      engine = aliases.get(engine);\n    }\n    return [engine, String(version)];\n  }).filter(([engine]) => {\n    return validTargets.has(engine);\n  }).sort(([a], [b]) => {\n    return a < b ? -1 : a > b ? 1 : 0;\n  });\n\n  const reduced = new Map();\n  const operator = normalizedESModules === 'intersect' ? '>' : '<=';\n  for (const [engine, version] of normalized) {\n    if (!reduced.has(engine) || compare(version, operator, reduced.get(engine))) {\n      reduced.set(engine, version);\n    }\n  }\n\n  return reduced;\n};\n"]}