{"version":3,"sources":["index.js","fields.js","typescript.js","decorators.js","misc.js","decorators-2018-09.js","features.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;AGRA,AFMA,AFMA,ADGA,AIZA,AFMA;AGRA,AFMA,AFMA,ADGA,AIZA,AFMA;AGRA,AFMA,AFMA,ADGA,AIZA,AFMA;AGRA,AFMA,AGTA,ALeA,ADGA,AIZA,AFMA;AGRA,AFMA,AGTA,ALeA,ADGA,AIZA,AFMA;AGRA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ACFA,AFMA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA,AIZA;ADIA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AGTA,ALeA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\nObject.defineProperty(exports, \"buildCheckInRHS\", {\n  enumerable: true,\n  get: function () {\n    return _fields.buildCheckInRHS;\n  }\n});\nObject.defineProperty(exports, \"buildNamedEvaluationVisitor\", {\n  enumerable: true,\n  get: function () {\n    return _decorators.buildNamedEvaluationVisitor;\n  }\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"enableFeature\", {\n  enumerable: true,\n  get: function () {\n    return _features.enableFeature;\n  }\n});\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nvar _core = require(\"@babel/core\");\nvar _semver = require(\"semver\");\nvar _fields = require(\"./fields.js\");\nvar _decorators = require(\"./decorators.js\");\nvar _decorators2 = require(\"./decorators-2018-09.js\");\nvar _misc = require(\"./misc.js\");\nvar _features = require(\"./features.js\");\nvar _typescript = require(\"./typescript.js\");\nconst versionKey = \"@babel/plugin-class-features/version\";\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api,\n  inherits,\n  decoratorVersion\n}) {\n  var _api$assumption;\n  if (feature & _features.FEATURES.decorators) {\n    if (decoratorVersion === \"2023-11\" || decoratorVersion === \"2023-05\" || decoratorVersion === \"2023-01\" || decoratorVersion === \"2022-03\" || decoratorVersion === \"2021-12\") {\n      return (0, _decorators.default)(api, {\n        loose\n      }, decoratorVersion, inherits);\n    }\n  }\n  api != null ? api : api = {\n    assumption: () => void 0\n  };\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const noUninitializedPrivateFieldAccess = (_api$assumption = api.assumption(\"noUninitializedPrivateFieldAccess\")) != null ? _api$assumption : false;\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(`Cannot enable both the \"privateFieldsAsProperties\" and ` + `\"privateFieldsAsSymbols\" assumptions as the same time.`);\n  }\n  const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;\n  if (loose === true) {\n    const explicit = [];\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(`[${name}]: You are using the \"loose: true\" option and you are` + ` explicitly setting a value for the ${explicit.join(\" and \")}` + ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\\n` + `\\t\"assumptions\": {\\n` + `\\t\\t\"setPublicClassFields\": true,\\n` + `\\t\\t\"privateFieldsAsSymbols\": true\\n` + `\\t}`);\n    }\n  }\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n    pre(file) {\n      (0, _features.enableFeature)(file, feature, loose);\n      if (typeof file.get(versionKey) === \"number\") {\n        file.set(versionKey, \"7.28.6\");\n        return;\n      }\n      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), \"7.28.6\")) {\n        file.set(versionKey, \"7.28.6\");\n      }\n    },\n    visitor: {\n      Class(path, {\n        file\n      }) {\n        if (file.get(versionKey) !== \"7.28.6\") return;\n        if (!(0, _features.shouldTransform)(path, file)) return;\n        const pathIsClassDeclaration = path.isClassDeclaration();\n        if (pathIsClassDeclaration) (0, _typescript.assertFieldTransformed)(path);\n        const loose = (0, _features.isLoose)(file, feature);\n        let constructor;\n        const isDecorated = (0, _decorators.hasDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n        for (const path of body.get(\"body\")) {\n          if ((path.isClassProperty() || path.isClassMethod()) && path.node.computed) {\n            computedPaths.push(path);\n          }\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n              privateNames.add(name);\n            }\n          }\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (path.isProperty() || path.isPrivate() || path.isStaticBlock != null && path.isStaticBlock()) {\n              props.push(path);\n            }\n          }\n        }\n        if (!props.length && !isDecorated) return;\n        const innerBinding = path.node.id;\n        let ref;\n        if (!innerBinding || !pathIsClassDeclaration) {\n          var _path$ensureFunctionN;\n          (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          path.ensureFunctionName(false);\n          ref = path.scope.generateUidIdentifier((innerBinding == null ? void 0 : innerBinding.name) || \"Class\");\n        }\n        const classRefForDefine = ref != null ? ref : _core.types.cloneNode(innerBinding);\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(classRefForDefine.name, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, props, file);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);\n        (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path, privateNamesMap, {\n          privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,\n          noUninitializedPrivateFieldAccess,\n          noDocumentAll,\n          innerBinding\n        }, file);\n        let keysNodes, staticNodes, instanceNodes, lastInstanceNodeReturnsThis, pureStaticNodes, classBindingNode, wrapClass;\n        if (isDecorated) {\n          staticNodes = pureStaticNodes = keysNodes = [];\n          ({\n            instanceNodes,\n            wrapClass\n          } = (0, _decorators2.buildDecoratedClass)(classRefForDefine, path, elements, file));\n        } else {\n          keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);\n          ({\n            staticNodes,\n            pureStaticNodes,\n            instanceNodes,\n            lastInstanceNodeReturnsThis,\n            classBindingNode,\n            wrapClass\n          } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, noUninitializedPrivateFieldAccess, constantSuper != null ? constantSuper : loose, innerBinding));\n        }\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            if (isDecorated) return;\n            for (const prop of props) {\n              if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          }, lastInstanceNodeReturnsThis);\n        }\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);\n        }\n        if (classBindingNode != null && pathIsClassDeclaration) {\n          wrappedPath.insertAfter(classBindingNode);\n        }\n      },\n      ExportDefaultDeclaration(path, {\n        file\n      }) {\n        if (file.get(versionKey) !== \"7.28.6\") return;\n        const decl = path.get(\"declaration\");\n        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n          if (decl.node.id) {\n            var _path$splitExportDecl;\n            (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n            path.splitExportDeclaration();\n          } else {\n            decl.node.type = \"ClassExpression\";\n          }\n        }\n      }\n    }\n  };\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildCheckInRHS = buildCheckInRHS;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.privateNameVisitorFactory = privateNameVisitorFactory;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nvar _core = require(\"@babel/core\");\nvar _traverse = require(\"@babel/traverse\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\nvar ts = require(\"./typescript.js\");\nvar newHelpers = file => {\n  return file.availableHelper(\"classPrivateFieldGet2\");\n};\nfunction buildPrivateNamesMap(className, privateFieldsAsSymbolsOrProperties, props, file) {\n  const privateNamesMap = new Map();\n  let classBrandId;\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const {\n        name\n      } = prop.node.key.id;\n      let update = privateNamesMap.get(name);\n      if (!update) {\n        const isMethod = !prop.isProperty();\n        const isStatic = prop.node.static;\n        let initAdded = false;\n        let id;\n        if (!privateFieldsAsSymbolsOrProperties && newHelpers(file) && isMethod && !isStatic) {\n          initAdded = !!classBrandId;\n          classBrandId != null ? classBrandId : classBrandId = prop.scope.generateUidIdentifier(`${className}_brand`);\n          id = classBrandId;\n        } else {\n          id = prop.scope.generateUidIdentifier(name);\n        }\n        update = {\n          id,\n          static: isStatic,\n          method: isMethod,\n          initAdded\n        };\n        privateNamesMap.set(name, update);\n      }\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          const {\n            body\n          } = prop.node.body;\n          let $;\n          if (body.length === 1 && _core.types.isReturnStatement($ = body[0]) && _core.types.isCallExpression($ = $.argument) && $.arguments.length === 1 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($ = $.callee)) {\n            update.getId = _core.types.cloneNode($);\n            update.getterDeclared = true;\n          } else {\n            update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n          }\n        } else if (prop.node.kind === \"set\") {\n          const {\n            params\n          } = prop.node;\n          const {\n            body\n          } = prop.node.body;\n          let $;\n          if (body.length === 1 && _core.types.isExpressionStatement($ = body[0]) && _core.types.isCallExpression($ = $.expression) && $.arguments.length === 2 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($.arguments[1], {\n            name: params[0].name\n          }) && _core.types.isIdentifier($ = $.callee)) {\n            update.setId = _core.types.cloneNode($);\n            update.setterDeclared = true;\n          } else {\n            update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n          }\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\nfunction buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {\n  const initNodes = [];\n  const injectedIds = new Set();\n  for (const [name, value] of privateNamesMap) {\n    const {\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isGetterOrSetter = getId || setId;\n    const id = _core.types.cloneNode(value.id);\n    let init;\n    if (privateFieldsAsProperties) {\n      init = _core.types.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [_core.types.stringLiteral(name)]);\n    } else if (privateFieldsAsSymbols) {\n      init = _core.types.callExpression(_core.types.identifier(\"Symbol\"), [_core.types.stringLiteral(name)]);\n    } else if (!isStatic) {\n      if (injectedIds.has(id.name)) continue;\n      injectedIds.add(id.name);\n      init = _core.types.newExpression(_core.types.identifier(isMethod && (!isGetterOrSetter || newHelpers(state)) ? \"WeakSet\" : \"WeakMap\"), []);\n    }\n    if (init) {\n      if (!privateFieldsAsSymbols) {\n        (0, _helperAnnotateAsPure.default)(init);\n      }\n      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n  return initNodes;\n}\nfunction privateNameVisitorFactory(visitor) {\n  const nestedVisitor = _traverse.visitors.environmentVisitor(Object.assign({}, visitor));\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n      if (!redeclared.length) {\n        return;\n      }\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n  });\n  return privateNameVisitor;\n}\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path, {\n    noDocumentAll\n  }) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared != null && redeclared.includes(name)) return;\n    this.handle(parentPath, noDocumentAll);\n  }\n});\nfunction unshadow(name, scope, innerBinding) {\n  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {\n    var _scope;\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\nfunction buildCheckInRHS(rhs, file, inRHSIsObject) {\n  if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper(\"checkInRHS\"))) return rhs;\n  return _core.types.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path, {\n    file\n  }) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!_core.types.isPrivateName(left)) return;\n    const {\n      privateFieldsAsProperties,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared != null && redeclared.includes(name)) return;\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n    if (privateFieldsAsProperties) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id)})\n      `);\n      return;\n    }\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`);\n      return;\n    }\n    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);\n  }\n});\nfunction readOnlyError(file, name) {\n  return _core.types.callExpression(file.addHelper(\"readOnlyError\"), [_core.types.stringLiteral(`#${name}`)]);\n}\nfunction writeOnlyError(file, name) {\n  if (!file.availableHelper(\"writeOnlyError\")) {\n    console.warn(`@babel/helpers is outdated, update it to silence this warning.`);\n    return _core.types.buildUndefinedNode();\n  }\n  return _core.types.callExpression(file.addHelper(\"writeOnlyError\"), [_core.types.stringLiteral(`#${name}`)]);\n}\nfunction buildStaticPrivateFieldAccess(expr, noUninitializedPrivateFieldAccess) {\n  if (noUninitializedPrivateFieldAccess) return expr;\n  return _core.types.memberExpression(expr, _core.types.identifier(\"_\"));\n}\nfunction autoInherits(fn) {\n  return function (member) {\n    return _core.types.inherits(fn.apply(this, arguments), member.node);\n  };\n}\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n    if (!memo) {\n      return;\n    }\n    this.memoiser.set(object, memo, count);\n  },\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n    return _core.types.cloneNode(object);\n  },\n  get: autoInherits(function (member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      innerBinding,\n      noUninitializedPrivateFieldAccess\n    } = this;\n    const privateName = member.node.property;\n    const {\n      name\n    } = privateName.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isGetterOrSetter = getId || setId;\n    const cloneId = id => _core.types.inherits(_core.types.cloneNode(id), privateName);\n    if (isStatic) {\n      unshadow(classRef.name, member.scope, innerBinding);\n      if (!newHelpers(file)) {\n        const helperName = isMethod && !isGetterOrSetter ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]);\n      }\n      const receiver = this.receiver(member);\n      const skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;\n      if (!isMethod) {\n        if (skipCheck) {\n          return buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess);\n        }\n        return buildStaticPrivateFieldAccess(_core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]), noUninitializedPrivateFieldAccess);\n      }\n      if (getId) {\n        if (skipCheck) {\n          return _core.types.callExpression(cloneId(getId), [receiver]);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateGetter\"), [_core.types.cloneNode(classRef), receiver, cloneId(getId)]);\n      }\n      if (setId) {\n        const err = _core.types.buildUndefinedNode();\n        if (skipCheck) return err;\n        return _core.types.sequenceExpression([_core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(classRef), receiver]), err]);\n      }\n      if (skipCheck) return cloneId(id);\n      return _core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]);\n    }\n    if (isMethod) {\n      if (isGetterOrSetter) {\n        if (!getId) {\n          return _core.types.sequenceExpression([this.receiver(member), writeOnlyError(file, name)]);\n        }\n        if (!newHelpers(file)) {\n          return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), cloneId(id)]);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateGetter\"), [_core.types.cloneNode(id), this.receiver(member), cloneId(getId)]);\n      }\n      if (!newHelpers(file)) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), cloneId(methodId)]);\n      }\n      return _core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(id), this.receiver(member), cloneId(methodId)]);\n    }\n    if (newHelpers(file)) {\n      return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet2\"), [cloneId(id), this.receiver(member)]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), cloneId(id)]);\n  }),\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n  set: autoInherits(function (member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      noUninitializedPrivateFieldAccess\n    } = this;\n    const privateName = member.node.property;\n    const {\n      name\n    } = privateName.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isGetterOrSetter = getId || setId;\n    const cloneId = id => _core.types.inherits(_core.types.cloneNode(id), privateName);\n    if (isStatic) {\n      if (!newHelpers(file)) {\n        const helperName = isMethod && !isGetterOrSetter ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n        return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id), value]);\n      }\n      const receiver = this.receiver(member);\n      const skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;\n      if (isMethod && !setId) {\n        const err = readOnlyError(file, name);\n        if (skipCheck) return _core.types.sequenceExpression([value, err]);\n        return _core.types.sequenceExpression([value, _core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(classRef), receiver]), readOnlyError(file, name)]);\n      }\n      if (setId) {\n        if (skipCheck) {\n          return _core.types.callExpression(_core.types.cloneNode(setId), [receiver, value]);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateSetter\"), [_core.types.cloneNode(classRef), cloneId(setId), receiver, value]);\n      }\n      return _core.types.assignmentExpression(\"=\", buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess), skipCheck ? value : _core.types.callExpression(file.addHelper(\"assertClassBrand\"), [_core.types.cloneNode(classRef), receiver, value]));\n    }\n    if (isMethod) {\n      if (setId) {\n        if (!newHelpers(file)) {\n          return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), cloneId(id), value]);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateSetter\"), [_core.types.cloneNode(id), cloneId(setId), this.receiver(member), value]);\n      }\n      return _core.types.sequenceExpression([this.receiver(member), value, readOnlyError(file, name)]);\n    }\n    if (newHelpers(file)) {\n      return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet2\"), [cloneId(id), this.receiver(member), value]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), cloneId(id), value]);\n  }),\n  destructureSet(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      noUninitializedPrivateFieldAccess\n    } = this;\n    const privateName = member.node.property;\n    const {\n      name\n    } = privateName.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId\n    } = privateNamesMap.get(name);\n    const cloneId = id => _core.types.inherits(_core.types.cloneNode(id), privateName);\n    if (!newHelpers(file)) {\n      if (isStatic) {\n        try {\n          var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n        } catch (_unused) {\n          throw new Error(\"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" + \"please update @babel/helpers to the latest version.\");\n        }\n        return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]), _core.types.identifier(\"value\"));\n      }\n      return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), cloneId(id)]), _core.types.identifier(\"value\"));\n    }\n    if (isMethod && !setId) {\n      return _core.types.memberExpression(_core.types.sequenceExpression([member.node.object, readOnlyError(file, name)]), _core.types.identifier(\"_\"));\n    }\n    if (isStatic && !isMethod) {\n      const getCall = this.get(member);\n      if (!noUninitializedPrivateFieldAccess || !_core.types.isCallExpression(getCall)) {\n        return getCall;\n      }\n      const ref = getCall.arguments.pop();\n      getCall.arguments.push(_core.template.expression.ast`(_) => ${ref} = _`);\n      return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"toSetter\"), [getCall]), _core.types.identifier(\"_\"));\n    }\n    const setCall = this.set(member, _core.types.identifier(\"_\"));\n    if (!_core.types.isCallExpression(setCall) || !_core.types.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {\n      name: \"_\"\n    })) {\n      throw member.buildCodeFrameError(\"Internal Babel error while compiling this code. This is a Babel bug. \" + \"Please report it at https://github.com/babel/babel/issues.\");\n    }\n    let args;\n    if (_core.types.isMemberExpression(setCall.callee, {\n      computed: false\n    }) && _core.types.isIdentifier(setCall.callee.property) && setCall.callee.property.name === \"call\") {\n      args = [setCall.callee.object, _core.types.arrayExpression(setCall.arguments.slice(1, -1)), setCall.arguments[0]];\n    } else {\n      args = [setCall.callee, _core.types.arrayExpression(setCall.arguments.slice(0, -1))];\n    }\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"toSetter\"), args), _core.types.identifier(\"_\"));\n  },\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  },\n  delete() {\n    throw new Error(\"Internal Babel error: deleting private elements is a parsing error.\");\n  }\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: _core.types.cloneNode(object),\n      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)\n    });\n  },\n  set() {\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n  simpleSet(member) {\n    return this.get(member);\n  },\n  destructureSet(member) {\n    return this.get(member);\n  },\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  },\n  delete() {\n    throw new Error(\"Internal Babel error: deleting private elements is a parsing error.\");\n  }\n};\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, {\n  privateFieldsAsProperties,\n  noUninitializedPrivateFieldAccess,\n  noDocumentAll,\n  innerBinding\n}, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler, {\n    noDocumentAll,\n    noUninitializedPrivateFieldAccess,\n    innerBinding\n  }));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding\n  });\n}\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    `, prop);\n}\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n    return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })`, prop);\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritLoc(inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(helper, [_core.types.thisExpression(), inheritLoc(_core.types.cloneNode(id), prop.node.key), newHelpers(state) ? value : _core.template.expression.ast`{ writable: true, value: ${value} }`])), prop), prop.node);\n}\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const value = noUninitializedPrivateFieldAccess ? prop.node.value : _core.template.expression.ast`{\n        _: ${prop.node.value || _core.types.buildUndefinedNode()}\n      }`;\n  return inheritPropComments(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.cloneNode(privateName.id), value)]), prop);\n}\nvar buildPrivateStaticFieldInitSpecOld = function (prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isGetterOrSetter = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isGetterOrSetter)) return;\n  if (isGetterOrSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n          var ${_core.types.cloneNode(id)} = {\n            // configurable is false by default\n            // enumerable is false by default\n            // writable is false by default\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          }\n        `, prop);\n  }\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n        var ${_core.types.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          writable: true,\n          value: ${value}\n        };\n      `, prop);\n};\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  if (methodId) {\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `, prop);\n  }\n  const isGetterOrSetter = getId || setId;\n  if (isGetterOrSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      `, prop);\n  }\n}\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  if (privateName.initAdded) return;\n  if (!newHelpers(state)) {\n    const isGetterOrSetter = privateName.getId || privateName.setId;\n    if (isGetterOrSetter) {\n      return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);\n    }\n  }\n  return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);\n}\nfunction buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId\n  } = privateName;\n  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n    initAdded: true\n  }));\n  if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n    return inheritPropComments(_core.template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        `, prop);\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritLoc(inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )`, prop), prop.node);\n}\nfunction buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id\n  } = privateName;\n  if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n    return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);\n  }\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)}\n    )`, prop);\n}\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);\n}\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);\n}\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isGetterOrSetter = getId || setId;\n  if (isGetterOrSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `, prop);\n  }\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `, prop);\n}\nfunction buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n  const isGetter = getId && params.length === 0;\n  const isSetter = setId && params.length > 0;\n  if (isGetter && getterDeclared || isSetter && setterDeclared) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return null;\n  }\n  if (newHelpers(file) && (isGetter || isSetter) && !privateFieldsAsSymbolsOrProperties) {\n    const scope = prop.get(\"body\").scope;\n    const thisArg = scope.generateUidIdentifier(\"this\");\n    const state = {\n      thisRef: thisArg,\n      argumentsPath: []\n    };\n    prop.traverse(thisContextVisitor, state);\n    if (state.argumentsPath.length) {\n      const argumentsId = scope.generateUidIdentifier(\"arguments\");\n      scope.push({\n        id: argumentsId,\n        init: _core.template.expression.ast`[].slice.call(arguments, 1)`\n      });\n      for (const path of state.argumentsPath) {\n        path.replaceWith(_core.types.cloneNode(argumentsId));\n      }\n    }\n    params.unshift(_core.types.cloneNode(thisArg));\n  }\n  let declId = methodId;\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true,\n      initAdded: true\n    }));\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true,\n      initAdded: true\n    }));\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsSymbolsOrProperties) {\n    declId = id;\n  }\n  return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);\n}\nconst thisContextVisitor = _traverse.visitors.environmentVisitor({\n  Identifier(path, state) {\n    if (state.argumentsPath && path.node.name === \"arguments\") {\n      state.argumentsPath.push(path);\n    }\n  },\n  UnaryExpression(path) {\n    const {\n      node\n    } = path;\n    if (node.operator === \"delete\") {\n      const argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);\n      if (_core.types.isThisExpression(argument)) {\n        path.replaceWith(_core.types.booleanLiteral(true));\n      }\n    }\n  },\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.thisRef));\n  },\n  MetaProperty(path) {\n    const {\n      node,\n      scope\n    } = path;\n    if (node.meta.name === \"new\" && node.property.name === \"target\") {\n      path.replaceWith(scope.buildUndefinedNode());\n    }\n  }\n});\nconst innerReferencesVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {\n      state.needsClassRef = true;\n      path.node.name = state.thisRef.name;\n    }\n  }\n};\nfunction replaceThisContext(path, ref, innerBindingRef) {\n  var _state$thisRef;\n  const state = {\n    thisRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef\n  };\n  if (!path.isMethod()) {\n    path.traverse(thisContextVisitor, state);\n  }\n  if (innerBindingRef != null && (_state$thisRef = state.thisRef) != null && _state$thisRef.name && state.thisRef.name !== innerBindingRef.name) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n  return state.needsClassRef;\n}\nfunction isNameOrLength({\n  key,\n  computed\n}) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\nfunction inheritPropComments(node, prop) {\n  _core.types.inheritLeadingComments(node, prop.node);\n  _core.types.inheritInnerComments(node, prop.node);\n  return node;\n}\nfunction inheritLoc(node, original) {\n  node.start = original.start;\n  node.end = original.end;\n  node.loc = original.loc;\n  return node;\n}\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, file, setPublicClassFields, privateFieldsAsSymbolsOrProperties, noUninitializedPrivateFieldAccess, constantSuper, innerBindingRef) {\n  let classRefFlags = 0;\n  let injectSuperRef;\n  const staticNodes = [];\n  const instanceNodes = [];\n  let lastInstanceNodeReturnsThis = false;\n  const pureStaticNodes = [];\n  let classBindingNode = null;\n  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {\n    injectSuperRef != null ? injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n    return injectSuperRef;\n  };\n  const classRefForInnerBinding = ref != null ? ref : props[0].scope.generateUidIdentifier((innerBindingRef == null ? void 0 : innerBindingRef.name) || \"Class\");\n  ref != null ? ref : ref = _core.types.cloneNode(innerBindingRef);\n  for (const prop of props) {\n    if (prop.isClassProperty()) {\n      ts.assertFieldTransformed(prop);\n    }\n    const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();\n    if (isStatic) classRefFlags |= 1;\n    if (isStatic || isMethod && isPrivate || isStaticBlock) {\n      new _helperReplaceSupers.default({\n        methodPath: prop,\n        constantSuper,\n        file: file,\n        refToPreserve: innerBindingRef,\n        getSuperRef,\n        getObjectRef() {\n          classRefFlags |= 2;\n          if (isStatic || isStaticBlock) {\n            return classRefForInnerBinding;\n          } else {\n            return _core.types.memberExpression(classRefForInnerBinding, _core.types.identifier(\"prototype\"));\n          }\n        }\n      }).replace();\n      const replaced = replaceThisContext(prop, classRefForInnerBinding, innerBindingRef);\n      if (replaced) {\n        classRefFlags |= 2;\n      }\n    }\n    lastInstanceNodeReturnsThis = false;\n    switch (true) {\n      case isStaticBlock:\n        {\n          const blockBody = prop.node.body;\n          if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {\n            staticNodes.push(inheritPropComments(blockBody[0], prop));\n          } else {\n            staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));\n          }\n          break;\n        }\n      case isStatic && isPrivate && isField && privateFieldsAsSymbolsOrProperties:\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n      case isStatic && isPrivate && isField && !privateFieldsAsSymbolsOrProperties:\n        if (!newHelpers(file)) {\n          staticNodes.push(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));\n        } else {\n          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess));\n        }\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        if (!isNameOrLength(prop.node)) {\n          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n          break;\n        }\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, file));\n        break;\n      case isInstance && isPrivate && isField && privateFieldsAsSymbolsOrProperties:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n      case isInstance && isPrivate && isField && !privateFieldsAsSymbolsOrProperties:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));\n        break;\n      case isInstance && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));\n        break;\n      case isInstance && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));\n        break;\n      case isStatic && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties:\n        if (!newHelpers(file)) {\n          staticNodes.unshift(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));\n        }\n        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));\n        break;\n      case isStatic && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties:\n        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, file, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        lastInstanceNodeReturnsThis = true;\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, file));\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n  if (classRefFlags & 2 && innerBindingRef != null) {\n    classBindingNode = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(classRefForInnerBinding), _core.types.cloneNode(innerBindingRef)));\n  }\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    lastInstanceNodeReturnsThis,\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    classBindingNode,\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.node.leadingComments = null;\n        prop.remove();\n      }\n      if (injectSuperRef) {\n        path.scope.push({\n          id: _core.types.cloneNode(injectSuperRef)\n        });\n        path.set(\"superClass\", _core.types.assignmentExpression(\"=\", injectSuperRef, path.node.superClass));\n      }\n      if (classRefFlags !== 0) {\n        if (path.isClassExpression()) {\n          path.scope.push({\n            id: ref\n          });\n          path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n        } else {\n          if (innerBindingRef == null) {\n            path.node.id = ref;\n          }\n          if (classBindingNode != null) {\n            path.scope.push({\n              id: classRefForInnerBinding\n            });\n          }\n        }\n      }\n      return path;\n    }\n  };\n}\n\n//# sourceMappingURL=fields.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertFieldTransformed = assertFieldTransformed;\nfunction assertFieldTransformed(path) {\n  if (path.node.declare || false) {\n    throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by ` + `@babel/plugin-transform-typescript.\\n` + `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` + `that it runs before any plugin related to additional class features:\\n` + ` - @babel/plugin-transform-class-properties\\n` + ` - @babel/plugin-transform-private-methods\\n` + ` - @babel/plugin-proposal-decorators`);\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamedEvaluationVisitor = buildNamedEvaluationVisitor;\nexports.default = _default;\nexports.hasDecorators = hasDecorators;\nexports.hasOwnDecorators = hasOwnDecorators;\nvar _core = require(\"@babel/core\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\nvar _fields = require(\"./fields.js\");\nvar _misc = require(\"./misc.js\");\nfunction hasOwnDecorators(node) {\n  var _node$decorators;\n  return !!((_node$decorators = node.decorators) != null && _node$decorators.length);\n}\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\nfunction incrementId(id, idx = id.length - 1) {\n  if (idx === -1) {\n    id.unshift(65);\n    return;\n  }\n  const current = id[idx];\n  if (current === 90) {\n    id[idx] = 97;\n  } else if (current === 122) {\n    id[idx] = 65;\n    incrementId(id, idx - 1);\n  } else {\n    id[idx] = current + 1;\n  }\n}\nfunction createPrivateUidGeneratorForClass(classPath) {\n  const currentPrivateId = [];\n  const privateNames = new Set();\n  _core.types.traverseFast(classPath.node, node => {\n    if (_core.types.isPrivateName(node)) {\n      privateNames.add(node.id.name);\n    }\n  });\n  return () => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n    return _core.types.privateName(_core.types.identifier(reifiedId));\n  };\n}\nfunction createLazyPrivateUidGeneratorForClass(classPath) {\n  let generator;\n  return () => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n    return generator();\n  };\n}\nfunction replaceClassWithVar(path, className) {\n  const id = path.node.id;\n  const scope = path.scope;\n  if (path.type === \"ClassDeclaration\") {\n    const className = id.name;\n    const varId = scope.generateUidIdentifierBasedOnNode(id);\n    const classId = _core.types.identifier(className);\n    scope.rename(className, varId.name);\n    path.get(\"id\").replaceWith(classId);\n    return {\n      id: _core.types.cloneNode(varId),\n      path\n    };\n  } else {\n    let varId;\n    if (id) {\n      className = id.name;\n      varId = generateLetUidIdentifier(scope.parent, className);\n      scope.rename(className, varId.name);\n    } else {\n      varId = generateLetUidIdentifier(scope.parent, typeof className === \"string\" ? className : \"decorated_class\");\n    }\n    const newClassExpr = _core.types.classExpression(typeof className === \"string\" ? _core.types.identifier(className) : null, path.node.superClass, path.node.body);\n    const [newPath] = path.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));\n    return {\n      id: _core.types.cloneNode(varId),\n      path: newPath.get(\"expressions.0\")\n    };\n  }\n}\nfunction generateClassProperty(key, value, isStatic) {\n  if (key.type === \"PrivateName\") {\n    return _core.types.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return _core.types.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\nfunction assignIdForAnonymousClass(path, className) {\n  if (!path.node.id) {\n    path.node.id = typeof className === \"string\" ? _core.types.identifier(className) : path.scope.generateUidIdentifier(\"Class\");\n  }\n}\nfunction addProxyAccessorsFor(className, element, getterKey, setterKey, targetKey, isComputed, isStatic, version) {\n  const thisArg = (version === \"2023-11\" || version === \"2023-05\") && isStatic ? className : _core.types.thisExpression();\n  const getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]);\n  const setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier(\"v\")))]);\n  let getter, setter;\n  if (getterKey.type === \"PrivateName\") {\n    getter = _core.types.classPrivateMethod(\"get\", getterKey, [], getterBody, isStatic);\n    setter = _core.types.classPrivateMethod(\"set\", setterKey, [_core.types.identifier(\"v\")], setterBody, isStatic);\n  } else {\n    getter = _core.types.classMethod(\"get\", getterKey, [], getterBody, isComputed, isStatic);\n    setter = _core.types.classMethod(\"set\", setterKey, [_core.types.identifier(\"v\")], setterBody, isComputed, isStatic);\n  }\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\nfunction extractProxyAccessorsFor(targetKey, version) {\n  if (version !== \"2023-11\" && version !== \"2023-05\" && version !== \"2023-01\") {\n    return [_core.template.expression.ast`\n        function () {\n          return this.${_core.types.cloneNode(targetKey)};\n        }\n      `, _core.template.expression.ast`\n        function (value) {\n          this.${_core.types.cloneNode(targetKey)} = value;\n        }\n      `];\n  }\n  return [_core.template.expression.ast`\n      o => o.${_core.types.cloneNode(targetKey)}\n    `, _core.template.expression.ast`\n      (o, v) => o.${_core.types.cloneNode(targetKey)} = v\n    `];\n}\nfunction getComputedKeyLastElement(path) {\n  path = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path);\n  if (path.isSequenceExpression()) {\n    const expressions = path.get(\"expressions\");\n    return getComputedKeyLastElement(expressions[expressions.length - 1]);\n  }\n  return path;\n}\nfunction getComputedKeyMemoiser(path) {\n  const element = getComputedKeyLastElement(path);\n  if (element.isConstantExpression()) {\n    return _core.types.cloneNode(path.node);\n  } else if (element.isIdentifier() && path.scope.hasUid(element.node.name)) {\n    return _core.types.cloneNode(path.node);\n  } else if (element.isAssignmentExpression() && element.get(\"left\").isIdentifier()) {\n    return _core.types.cloneNode(element.node.left);\n  } else {\n    throw new Error(`Internal Error: the computed key ${path.toString()} has not yet been memoised.`);\n  }\n}\nfunction prependExpressionsToComputedKey(expressions, fieldPath) {\n  const key = fieldPath.get(\"key\");\n  if (key.isSequenceExpression()) {\n    expressions.push(...key.node.expressions);\n  } else {\n    expressions.push(key.node);\n  }\n  key.replaceWith(maybeSequenceExpression(expressions));\n}\nfunction appendExpressionsToComputedKey(expressions, fieldPath) {\n  const key = fieldPath.get(\"key\");\n  const completion = getComputedKeyLastElement(key);\n  if (completion.isConstantExpression()) {\n    prependExpressionsToComputedKey(expressions, fieldPath);\n  } else {\n    const scopeParent = key.scope.parent;\n    const maybeAssignment = (0, _misc.memoiseComputedKey)(completion.node, scopeParent, scopeParent.generateUid(\"computedKey\"));\n    if (!maybeAssignment) {\n      prependExpressionsToComputedKey(expressions, fieldPath);\n    } else {\n      const expressionSequence = [...expressions, _core.types.cloneNode(maybeAssignment.left)];\n      const completionParent = completion.parentPath;\n      if (completionParent.isSequenceExpression()) {\n        completionParent.pushContainer(\"expressions\", expressionSequence);\n      } else {\n        completion.replaceWith(maybeSequenceExpression([_core.types.cloneNode(maybeAssignment), ...expressionSequence]));\n      }\n    }\n  }\n}\nfunction prependExpressionsToFieldInitializer(expressions, fieldPath) {\n  const initializer = fieldPath.get(\"value\");\n  if (initializer.node) {\n    expressions.push(initializer.node);\n  } else if (expressions.length > 0) {\n    expressions[expressions.length - 1] = _core.types.unaryExpression(\"void\", expressions[expressions.length - 1]);\n  }\n  initializer.replaceWith(maybeSequenceExpression(expressions));\n}\nfunction prependExpressionsToStaticBlock(expressions, blockPath) {\n  blockPath.unshiftContainer(\"body\", _core.types.expressionStatement(maybeSequenceExpression(expressions)));\n}\nfunction prependExpressionsToConstructor(expressions, constructorPath) {\n  constructorPath.node.body.body.unshift(_core.types.expressionStatement(maybeSequenceExpression(expressions)));\n}\nfunction isProtoInitCallExpression(expression, protoInitCall) {\n  return _core.types.isCallExpression(expression) && _core.types.isIdentifier(expression.callee, {\n    name: protoInitCall.name\n  });\n}\nfunction optimizeSuperCallAndExpressions(expressions, protoInitLocal) {\n  if (protoInitLocal) {\n    if (expressions.length >= 2 && isProtoInitCallExpression(expressions[1], protoInitLocal)) {\n      const mergedSuperCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [expressions[0]]);\n      expressions.splice(0, 2, mergedSuperCall);\n    }\n    if (expressions.length >= 2 && _core.types.isThisExpression(expressions[expressions.length - 1]) && isProtoInitCallExpression(expressions[expressions.length - 2], protoInitLocal)) {\n      expressions.splice(expressions.length - 1, 1);\n    }\n  }\n  return maybeSequenceExpression(expressions);\n}\nfunction insertExpressionsAfterSuperCallAndOptimize(expressions, constructorPath, protoInitLocal) {\n  constructorPath.traverse({\n    CallExpression: {\n      exit(path) {\n        if (!path.get(\"callee\").isSuper()) return;\n        const newNodes = [path.node, ...expressions.map(expr => _core.types.cloneNode(expr))];\n        if (path.isCompletionRecord()) {\n          newNodes.push(_core.types.thisExpression());\n        }\n        path.replaceWith(optimizeSuperCallAndExpressions(newNodes, protoInitLocal));\n        path.skip();\n      }\n    },\n    ClassMethod(path) {\n      if (path.node.kind === \"constructor\") {\n        path.skip();\n      }\n    }\n  });\n}\nfunction createConstructorFromExpressions(expressions, isDerivedClass) {\n  const body = [_core.types.expressionStatement(maybeSequenceExpression(expressions))];\n  if (isDerivedClass) {\n    body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier(\"args\"))])));\n  }\n  return _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), isDerivedClass ? [_core.types.restElement(_core.types.identifier(\"args\"))] : [], _core.types.blockStatement(body));\n}\nfunction createStaticBlockFromExpressions(expressions) {\n  return _core.types.staticBlock([_core.types.expressionStatement(maybeSequenceExpression(expressions))]);\n}\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\nconst STATIC_OLD_VERSION = 5;\nconst STATIC = 8;\nconst DECORATORS_HAVE_THIS = 16;\nfunction getElementKind(element) {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\nfunction toSortedDecoratorInfo(info) {\n  return [...info.filter(el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter(el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter(el => el.isStatic && el.kind === FIELD), ...info.filter(el => !el.isStatic && el.kind === FIELD)];\n}\nfunction generateDecorationList(decorators, decoratorsThis, version) {\n  const decsCount = decorators.length;\n  const haveOneThis = decoratorsThis.some(Boolean);\n  const decs = [];\n  for (let i = 0; i < decsCount; i++) {\n    if ((version === \"2023-11\" || version === \"2023-05\") && haveOneThis) {\n      decs.push(decoratorsThis[i] || _core.types.unaryExpression(\"void\", _core.types.numericLiteral(0)));\n    }\n    decs.push(decorators[i].expression);\n  }\n  return {\n    haveThis: haveOneThis,\n    decs\n  };\n}\nfunction generateDecorationExprs(decorationInfo, version) {\n  return _core.types.arrayExpression(decorationInfo.map(el => {\n    let flag = el.kind;\n    if (el.isStatic) {\n      flag += version === \"2023-11\" || version === \"2023-05\" ? STATIC : STATIC_OLD_VERSION;\n    }\n    if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;\n    return _core.types.arrayExpression([el.decoratorsArray, _core.types.numericLiteral(flag), el.name, ...(el.privateMethods || [])]);\n  }));\n}\nfunction extractElementLocalAssignments(decorationInfo) {\n  const localIds = [];\n  for (const el of decorationInfo) {\n    const {\n      locals\n    } = el;\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n  return localIds;\n}\nfunction addCallAccessorsFor(version, element, key, getId, setId, isStatic) {\n  element.insertAfter(_core.types.classPrivateMethod(\"get\", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), version === \"2023-11\" && isStatic ? [] : [_core.types.thisExpression()]))]), isStatic));\n  element.insertAfter(_core.types.classPrivateMethod(\"set\", _core.types.cloneNode(key), [_core.types.identifier(\"v\")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), version === \"2023-11\" && isStatic ? [_core.types.identifier(\"v\")] : [_core.types.thisExpression(), _core.types.identifier(\"v\")]))]), isStatic));\n}\nfunction movePrivateAccessor(element, key, methodLocalVar, isStatic) {\n  let params;\n  let block;\n  if (element.node.kind === \"set\") {\n    params = [_core.types.identifier(\"v\")];\n    block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier(\"v\")]))];\n  } else {\n    params = [];\n    block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];\n  }\n  element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));\n}\nfunction isClassDecoratableElementPath(path) {\n  const {\n    type\n  } = path;\n  return type !== \"TSDeclareMethod\" && type !== \"TSIndexSignature\" && type !== \"StaticBlock\";\n}\nfunction staticBlockToIIFE(block) {\n  return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);\n}\nfunction staticBlockToFunctionClosure(block) {\n  return _core.types.functionExpression(null, [], _core.types.blockStatement(block.body));\n}\nfunction fieldInitializerToClosure(value) {\n  return _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(value)]));\n}\nfunction maybeSequenceExpression(exprs) {\n  if (exprs.length === 0) return _core.types.unaryExpression(\"void\", _core.types.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return _core.types.sequenceExpression(exprs);\n}\nfunction createFunctionExpressionFromPrivateMethod(node) {\n  const {\n    params,\n    body,\n    generator: isGenerator,\n    async: isAsync\n  } = node;\n  return _core.types.functionExpression(undefined, params, body, isGenerator, isAsync);\n}\nfunction createSetFunctionNameCall(state, className) {\n  return _core.types.callExpression(state.addHelper(\"setFunctionName\"), [_core.types.thisExpression(), className]);\n}\nfunction createToPropertyKeyCall(state, propertyKey) {\n  return _core.types.callExpression(state.addHelper(\"toPropertyKey\"), [propertyKey]);\n}\nfunction createPrivateBrandCheckClosure(brandName) {\n  return _core.types.arrowFunctionExpression([_core.types.identifier(\"_\")], _core.types.binaryExpression(\"in\", _core.types.cloneNode(brandName), _core.types.identifier(\"_\")));\n}\nfunction usesPrivateField(expression) {\n  try {\n    _core.types.traverseFast(expression, node => {\n      if (_core.types.isPrivateName(node)) {\n        throw null;\n      }\n    });\n    return false;\n  } catch (_unused) {\n    return true;\n  }\n}\nfunction convertToComputedKey(path) {\n  const {\n    node\n  } = path;\n  node.computed = true;\n  if (_core.types.isIdentifier(node.key)) {\n    node.key = _core.types.stringLiteral(node.key.name);\n  }\n}\nfunction hasInstancePrivateAccess(path, privateNames) {\n  let containsInstancePrivateAccess = false;\n  if (privateNames.length > 0) {\n    const privateNameVisitor = (0, _fields.privateNameVisitorFactory)({\n      PrivateName(path, state) {\n        if (state.privateNamesMap.has(path.node.id.name)) {\n          containsInstancePrivateAccess = true;\n          path.stop();\n        }\n      }\n    });\n    const privateNamesMap = new Map();\n    for (const name of privateNames) {\n      privateNamesMap.set(name, null);\n    }\n    path.traverse(privateNameVisitor, {\n      privateNamesMap: privateNamesMap\n    });\n  }\n  return containsInstancePrivateAccess;\n}\nfunction checkPrivateMethodUpdateError(path, decoratedPrivateMethods) {\n  const privateNameVisitor = (0, _fields.privateNameVisitorFactory)({\n    PrivateName(path, state) {\n      if (!state.privateNamesMap.has(path.node.id.name)) return;\n      const parentPath = path.parentPath;\n      const parentParentPath = parentPath.parentPath;\n      if (parentParentPath.node.type === \"AssignmentExpression\" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === \"UpdateExpression\" || parentParentPath.node.type === \"RestElement\" || parentParentPath.node.type === \"ArrayPattern\" || parentParentPath.node.type === \"ObjectProperty\" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === \"ObjectPattern\" || parentParentPath.node.type === \"ForOfStatement\" && parentParentPath.node.left === parentPath.node) {\n        throw path.buildCodeFrameError(`Decorated private methods are read-only, but \"#${path.node.id.name}\" is updated via this expression.`);\n      }\n    }\n  });\n  const privateNamesMap = new Map();\n  for (const name of decoratedPrivateMethods) {\n    privateNamesMap.set(name, null);\n  }\n  path.traverse(privateNameVisitor, {\n    privateNamesMap: privateNamesMap\n  });\n}\nfunction transformClass(path, state, constantSuper, ignoreFunctionLength, className, propertyVisitor, version) {\n  var _path$node$id;\n  const body = path.get(\"body.body\");\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n  let hasComputedKeysSideEffects = false;\n  let elemDecsUseFnContext = false;\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n  const classAssignments = [];\n  const scopeParent = path.scope.parent;\n  const memoiseExpression = (expression, hint, assignments) => {\n    const localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);\n    assignments.push(_core.types.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return _core.types.cloneNode(localEvaluatedId);\n  };\n  let protoInitLocal;\n  let staticInitLocal;\n  const classIdName = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;\n  const setClassName = typeof className === \"object\" ? className : undefined;\n  const usesFunctionContextOrYieldAwait = decorator => {\n    try {\n      _core.types.traverseFast(decorator, node => {\n        if (_core.types.isThisExpression(node) || _core.types.isSuper(node) || _core.types.isYieldExpression(node) || _core.types.isAwaitExpression(node) || _core.types.isIdentifier(node, {\n          name: \"arguments\"\n        }) || classIdName && _core.types.isIdentifier(node, {\n          name: classIdName\n        }) || _core.types.isMetaProperty(node) && node.meta.name !== \"import\") {\n          throw null;\n        }\n      });\n      return false;\n    } catch (_unused2) {\n      return true;\n    }\n  };\n  const instancePrivateNames = [];\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n    const elementNode = element.node;\n    if (!elementNode.static && _core.types.isPrivateName(elementNode.key)) {\n      instancePrivateNames.push(elementNode.key.id.name);\n    }\n    if (isDecorated(elementNode)) {\n      switch (elementNode.type) {\n        case \"ClassProperty\":\n          propertyVisitor.ClassProperty(element, state);\n          break;\n        case \"ClassPrivateProperty\":\n          propertyVisitor.ClassPrivateProperty(element, state);\n          break;\n        case \"ClassAccessorProperty\":\n          propertyVisitor.ClassAccessorProperty(element, state);\n          if (version === \"2023-11\") {\n            break;\n          }\n        default:\n          if (elementNode.static) {\n            staticInitLocal != null ? staticInitLocal : staticInitLocal = generateLetUidIdentifier(scopeParent, \"initStatic\");\n          } else {\n            protoInitLocal != null ? protoInitLocal : protoInitLocal = generateLetUidIdentifier(scopeParent, \"initProto\");\n          }\n          break;\n      }\n      hasElementDecorators = true;\n      elemDecsUseFnContext || (elemDecsUseFnContext = elementNode.decorators.some(usesFunctionContextOrYieldAwait));\n    } else if (elementNode.type === \"ClassAccessorProperty\") {\n      propertyVisitor.ClassAccessorProperty(element, state);\n      const {\n        key,\n        value,\n        static: isStatic,\n        computed\n      } = elementNode;\n      const newId = generateClassPrivateUid();\n      const newField = generateClassProperty(newId, value, isStatic);\n      const keyPath = element.get(\"key\");\n      const [newPath] = element.replaceWith(newField);\n      let getterKey, setterKey;\n      if (computed && !keyPath.isConstantExpression()) {\n        getterKey = (0, _misc.memoiseComputedKey)(createToPropertyKeyCall(state, key), scopeParent, scopeParent.generateUid(\"computedKey\"));\n        setterKey = _core.types.cloneNode(getterKey.left);\n      } else {\n        getterKey = _core.types.cloneNode(key);\n        setterKey = _core.types.cloneNode(key);\n      }\n      assignIdForAnonymousClass(path, className);\n      addProxyAccessorsFor(path.node.id, newPath, getterKey, setterKey, newId, computed, isStatic, version);\n    }\n    if (\"computed\" in element.node && element.node.computed) {\n      hasComputedKeysSideEffects || (hasComputedKeysSideEffects = !scopeParent.isStatic(element.node.key));\n    }\n  }\n  if (!classDecorators && !hasElementDecorators) {\n    if (!path.node.id && typeof className === \"string\") {\n      path.node.id = _core.types.identifier(className);\n    }\n    if (setClassName) {\n      path.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(state, setClassName)]));\n    }\n    return;\n  }\n  const elementDecoratorInfo = [];\n  let constructorPath;\n  const decoratedPrivateMethods = new Set();\n  let classInitLocal, classIdLocal;\n  let decoratorReceiverId = null;\n  function handleDecorators(decorators) {\n    let hasSideEffects = false;\n    let usesFnContext = false;\n    const decoratorsThis = [];\n    for (const decorator of decorators) {\n      const {\n        expression\n      } = decorator;\n      let object;\n      if ((version === \"2023-11\" || version === \"2023-05\") && _core.types.isMemberExpression(expression)) {\n        if (_core.types.isSuper(expression.object)) {\n          object = _core.types.thisExpression();\n        } else if (scopeParent.isStatic(expression.object)) {\n          object = _core.types.cloneNode(expression.object);\n        } else {\n          decoratorReceiverId != null ? decoratorReceiverId : decoratorReceiverId = generateLetUidIdentifier(scopeParent, \"obj\");\n          object = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(decoratorReceiverId), expression.object);\n          expression.object = _core.types.cloneNode(decoratorReceiverId);\n        }\n      }\n      decoratorsThis.push(object);\n      hasSideEffects || (hasSideEffects = !scopeParent.isStatic(expression));\n      usesFnContext || (usesFnContext = usesFunctionContextOrYieldAwait(decorator));\n    }\n    return {\n      hasSideEffects,\n      usesFnContext,\n      decoratorsThis\n    };\n  }\n  const willExtractSomeElemDecs = hasComputedKeysSideEffects || elemDecsUseFnContext || version !== \"2023-11\";\n  let needsDeclarationForClassBinding = false;\n  let classDecorationsFlag = 0;\n  let classDecorations = [];\n  let classDecorationsId;\n  let computedKeyAssignments = [];\n  if (classDecorators) {\n    classInitLocal = generateLetUidIdentifier(scopeParent, \"initClass\");\n    needsDeclarationForClassBinding = path.isClassDeclaration();\n    ({\n      id: classIdLocal,\n      path\n    } = replaceClassWithVar(path, className));\n    path.node.decorators = null;\n    const classDecsUsePrivateName = classDecorators.some(usesPrivateField);\n    const {\n      hasSideEffects,\n      usesFnContext,\n      decoratorsThis\n    } = handleDecorators(classDecorators);\n    const {\n      haveThis,\n      decs\n    } = generateDecorationList(classDecorators, decoratorsThis, version);\n    classDecorationsFlag = haveThis ? 1 : 0;\n    classDecorations = decs;\n    if (usesFnContext || hasSideEffects && willExtractSomeElemDecs || classDecsUsePrivateName) {\n      classDecorationsId = memoiseExpression(_core.types.arrayExpression(classDecorations), \"classDecs\", classAssignments);\n    }\n    if (!hasElementDecorators) {\n      for (const element of path.get(\"body.body\")) {\n        const {\n          node\n        } = element;\n        const isComputed = \"computed\" in node && node.computed;\n        if (isComputed) {\n          if (element.isClassProperty({\n            static: true\n          })) {\n            if (!element.get(\"key\").isConstantExpression()) {\n              const key = node.key;\n              const maybeAssignment = (0, _misc.memoiseComputedKey)(key, scopeParent, scopeParent.generateUid(\"computedKey\"));\n              if (maybeAssignment != null) {\n                node.key = _core.types.cloneNode(maybeAssignment.left);\n                computedKeyAssignments.push(maybeAssignment);\n              }\n            }\n          } else if (computedKeyAssignments.length > 0) {\n            prependExpressionsToComputedKey(computedKeyAssignments, element);\n            computedKeyAssignments = [];\n          }\n        }\n      }\n    }\n  } else {\n    assignIdForAnonymousClass(path, className);\n    classIdLocal = _core.types.cloneNode(path.node.id);\n  }\n  let lastInstancePrivateName;\n  let needsInstancePrivateBrandCheck = false;\n  let fieldInitializerExpressions = [];\n  let staticFieldInitializerExpressions = [];\n  if (hasElementDecorators) {\n    if (protoInitLocal) {\n      const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);\n      fieldInitializerExpressions.push(protoInitCall);\n    }\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        if (staticFieldInitializerExpressions.length > 0 && element.isStaticBlock()) {\n          prependExpressionsToStaticBlock(staticFieldInitializerExpressions, element);\n          staticFieldInitializerExpressions = [];\n        }\n        continue;\n      }\n      const {\n        node\n      } = element;\n      const decorators = node.decorators;\n      const hasDecorators = !!(decorators != null && decorators.length);\n      const isComputed = \"computed\" in node && node.computed;\n      let name = \"computedKey\";\n      if (node.key.type === \"PrivateName\") {\n        name = node.key.id.name;\n      } else if (!isComputed && node.key.type === \"Identifier\") {\n        name = node.key.name;\n      }\n      let decoratorsArray;\n      let decoratorsHaveThis;\n      if (hasDecorators) {\n        const {\n          hasSideEffects,\n          usesFnContext,\n          decoratorsThis\n        } = handleDecorators(decorators);\n        const {\n          decs,\n          haveThis\n        } = generateDecorationList(decorators, decoratorsThis, version);\n        decoratorsHaveThis = haveThis;\n        decoratorsArray = decs.length === 1 ? decs[0] : _core.types.arrayExpression(decs);\n        if (usesFnContext || hasSideEffects && willExtractSomeElemDecs) {\n          decoratorsArray = memoiseExpression(decoratorsArray, name + \"Decs\", computedKeyAssignments);\n        }\n      }\n      if (isComputed) {\n        if (!element.get(\"key\").isConstantExpression()) {\n          const key = node.key;\n          const maybeAssignment = (0, _misc.memoiseComputedKey)(hasDecorators ? createToPropertyKeyCall(state, key) : key, scopeParent, scopeParent.generateUid(\"computedKey\"));\n          if (maybeAssignment != null) {\n            if (classDecorators && element.isClassProperty({\n              static: true\n            })) {\n              node.key = _core.types.cloneNode(maybeAssignment.left);\n              computedKeyAssignments.push(maybeAssignment);\n            } else {\n              node.key = maybeAssignment;\n            }\n          }\n        }\n      }\n      const {\n        key,\n        static: isStatic\n      } = node;\n      const isPrivate = key.type === \"PrivateName\";\n      const kind = getElementKind(element);\n      if (isPrivate && !isStatic) {\n        if (hasDecorators) {\n          needsInstancePrivateBrandCheck = true;\n        }\n        if (_core.types.isClassPrivateProperty(node) || !lastInstancePrivateName) {\n          lastInstancePrivateName = key;\n        }\n      }\n      if (element.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = element;\n      }\n      let locals;\n      if (hasDecorators) {\n        let privateMethods;\n        let nameExpr;\n        if (isComputed) {\n          nameExpr = getComputedKeyMemoiser(element.get(\"key\"));\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = _core.types.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = _core.types.stringLiteral(key.name);\n        } else {\n          nameExpr = _core.types.cloneNode(key);\n        }\n        if (kind === ACCESSOR) {\n          const {\n            value\n          } = element.node;\n          const params = version === \"2023-11\" && isStatic ? [] : [_core.types.thisExpression()];\n          if (value) {\n            params.push(_core.types.cloneNode(value));\n          }\n          const newId = generateClassPrivateUid();\n          const newFieldInitId = generateLetUidIdentifier(scopeParent, `init_${name}`);\n          const newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId, version);\n            const getId = generateLetUidIdentifier(scopeParent, `get_${name}`);\n            const setId = generateLetUidIdentifier(scopeParent, `set_${name}`);\n            addCallAccessorsFor(version, newPath, key, getId, setId, isStatic);\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            assignIdForAnonymousClass(path, className);\n            addProxyAccessorsFor(path.node.id, newPath, _core.types.cloneNode(key), _core.types.isAssignmentExpression(key) ? _core.types.cloneNode(key.left) : _core.types.cloneNode(key), newId, isComputed, isStatic, version);\n            locals = [newFieldInitId];\n          }\n        } else if (kind === FIELD) {\n          const initId = generateLetUidIdentifier(scopeParent, `init_${name}`);\n          const valuePath = element.get(\"value\");\n          const args = version === \"2023-11\" && isStatic ? [] : [_core.types.thisExpression()];\n          if (valuePath.node) args.push(valuePath.node);\n          valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), args));\n          locals = [initId];\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key, version);\n          }\n        } else if (isPrivate) {\n          const callId = generateLetUidIdentifier(scopeParent, `call_${name}`);\n          locals = [callId];\n          const replaceSupers = new _helperReplaceSupers.default({\n            constantSuper,\n            methodPath: element,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal\n          });\n          replaceSupers.replace();\n          privateMethods = [createFunctionExpressionFromPrivateMethod(element.node)];\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(callId), isStatic);\n          } else {\n            const node = element.node;\n            path.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(callId), [], node.static));\n            decoratedPrivateMethods.add(key.id.name);\n            element.remove();\n          }\n        }\n        elementDecoratorInfo.push({\n          kind,\n          decoratorsArray,\n          decoratorsHaveThis,\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals\n        });\n        if (element.node) {\n          element.node.decorators = null;\n        }\n      }\n      if (isComputed && computedKeyAssignments.length > 0) {\n        if (classDecorators && element.isClassProperty({\n          static: true\n        })) {} else {\n          prependExpressionsToComputedKey(computedKeyAssignments, kind === ACCESSOR ? element.getNextSibling() : element);\n          computedKeyAssignments = [];\n        }\n      }\n      if (fieldInitializerExpressions.length > 0 && !isStatic && (kind === FIELD || kind === ACCESSOR)) {\n        prependExpressionsToFieldInitializer(fieldInitializerExpressions, element);\n        fieldInitializerExpressions = [];\n      }\n      if (staticFieldInitializerExpressions.length > 0 && isStatic && (kind === FIELD || kind === ACCESSOR)) {\n        prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element);\n        staticFieldInitializerExpressions = [];\n      }\n      if (hasDecorators && version === \"2023-11\") {\n        if (kind === FIELD || kind === ACCESSOR) {\n          const initExtraId = generateLetUidIdentifier(scopeParent, `init_extra_${name}`);\n          locals.push(initExtraId);\n          const initExtraCall = _core.types.callExpression(_core.types.cloneNode(initExtraId), isStatic ? [] : [_core.types.thisExpression()]);\n          if (!isStatic) {\n            fieldInitializerExpressions.push(initExtraCall);\n          } else {\n            staticFieldInitializerExpressions.push(initExtraCall);\n          }\n        }\n      }\n    }\n  }\n  if (computedKeyAssignments.length > 0) {\n    const elements = path.get(\"body.body\");\n    let lastComputedElement;\n    for (let i = elements.length - 1; i >= 0; i--) {\n      const path = elements[i];\n      const node = path.node;\n      if (node.computed) {\n        if (classDecorators && _core.types.isClassProperty(node, {\n          static: true\n        })) {\n          continue;\n        }\n        lastComputedElement = path;\n        break;\n      }\n    }\n    if (lastComputedElement != null) {\n      appendExpressionsToComputedKey(computedKeyAssignments, lastComputedElement);\n      computedKeyAssignments = [];\n    } else {}\n  }\n  if (fieldInitializerExpressions.length > 0) {\n    const isDerivedClass = !!path.node.superClass;\n    if (constructorPath) {\n      if (isDerivedClass) {\n        insertExpressionsAfterSuperCallAndOptimize(fieldInitializerExpressions, constructorPath, protoInitLocal);\n      } else {\n        prependExpressionsToConstructor(fieldInitializerExpressions, constructorPath);\n      }\n    } else {\n      path.node.body.body.unshift(createConstructorFromExpressions(fieldInitializerExpressions, isDerivedClass));\n    }\n    fieldInitializerExpressions = [];\n  }\n  if (staticFieldInitializerExpressions.length > 0) {\n    path.node.body.body.push(createStaticBlockFromExpressions(staticFieldInitializerExpressions));\n    staticFieldInitializerExpressions = [];\n  }\n  const sortedElementDecoratorInfo = toSortedDecoratorInfo(elementDecoratorInfo);\n  const elementDecorations = generateDecorationExprs(version === \"2023-11\" ? elementDecoratorInfo : sortedElementDecoratorInfo, version);\n  const elementLocals = extractElementLocalAssignments(sortedElementDecoratorInfo);\n  if (protoInitLocal) {\n    elementLocals.push(protoInitLocal);\n  }\n  if (staticInitLocal) {\n    elementLocals.push(staticInitLocal);\n  }\n  const classLocals = [];\n  let classInitInjected = false;\n  const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);\n  let originalClassPath = path;\n  const originalClass = path.node;\n  const staticClosures = [];\n  if (classDecorators) {\n    classLocals.push(classIdLocal, classInitLocal);\n    const statics = [];\n    path.get(\"body.body\").forEach(element => {\n      if (element.isStaticBlock()) {\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const staticBlockClosureId = memoiseExpression(staticBlockToFunctionClosure(element.node), \"staticBlock\", staticClosures);\n          staticFieldInitializerExpressions.push(_core.types.callExpression(_core.types.memberExpression(staticBlockClosureId, _core.types.identifier(\"call\")), [_core.types.thisExpression()]));\n        } else {\n          staticFieldInitializerExpressions.push(staticBlockToIIFE(element.node));\n        }\n        element.remove();\n        return;\n      }\n      if ((element.isClassProperty() || element.isClassPrivateProperty()) && element.node.static) {\n        const valuePath = element.get(\"value\");\n        if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {\n          const fieldValueClosureId = memoiseExpression(fieldInitializerToClosure(valuePath.node), \"fieldValue\", staticClosures);\n          valuePath.replaceWith(_core.types.callExpression(_core.types.memberExpression(fieldValueClosureId, _core.types.identifier(\"call\")), [_core.types.thisExpression()]));\n        }\n        if (staticFieldInitializerExpressions.length > 0) {\n          prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element);\n          staticFieldInitializerExpressions = [];\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      } else if (element.isClassPrivateMethod({\n        static: true\n      })) {\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const replaceSupers = new _helperReplaceSupers.default({\n            constantSuper,\n            methodPath: element,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal\n          });\n          replaceSupers.replace();\n          const privateMethodDelegateId = memoiseExpression(createFunctionExpressionFromPrivateMethod(element.node), element.get(\"key.id\").node.name, staticClosures);\n          if (ignoreFunctionLength) {\n            element.node.params = [_core.types.restElement(_core.types.identifier(\"arg\"))];\n            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier(\"apply\")), [_core.types.thisExpression(), _core.types.identifier(\"arg\")]))]);\n          } else {\n            element.node.params = element.node.params.map((p, i) => {\n              if (_core.types.isRestElement(p)) {\n                return _core.types.restElement(_core.types.identifier(\"arg\"));\n              } else {\n                return _core.types.identifier(\"_\" + i);\n              }\n            });\n            element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier(\"apply\")), [_core.types.thisExpression(), _core.types.identifier(\"arguments\")]))]);\n          }\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n    if (statics.length > 0 || staticFieldInitializerExpressions.length > 0) {\n      const staticsClass = _core.template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      `;\n      staticsClass.body.body = [_core.types.classProperty(_core.types.toExpression(originalClass), undefined, undefined, undefined, true, true), ...statics];\n      const constructorBody = [];\n      const newExpr = _core.types.newExpression(staticsClass, []);\n      if (staticFieldInitializerExpressions.length > 0) {\n        constructorBody.push(...staticFieldInitializerExpressions);\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classIdLocal)]));\n        staticsClass.body.body.push(createConstructorFromExpressions(constructorBody, false));\n      } else {\n        newExpr.arguments.push(_core.types.cloneNode(classIdLocal));\n      }\n      const [newPath] = path.replaceWith(newExpr);\n      originalClassPath = newPath.get(\"callee\").get(\"body\").get(\"body.0.key\");\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));\n  }\n  let {\n    superClass\n  } = originalClass;\n  if (superClass && (version === \"2023-11\" || version === \"2023-05\")) {\n    const id = path.scope.maybeGenerateMemoised(superClass);\n    if (id) {\n      originalClass.superClass = _core.types.assignmentExpression(\"=\", id, superClass);\n      superClass = id;\n    }\n  }\n  const applyDecoratorWrapper = _core.types.staticBlock([]);\n  originalClass.body.body.unshift(applyDecoratorWrapper);\n  const applyDecsBody = applyDecoratorWrapper.body;\n  if (computedKeyAssignments.length > 0) {\n    const elements = originalClassPath.get(\"body.body\");\n    let firstPublicElement;\n    for (const path of elements) {\n      if ((path.isClassProperty() || path.isClassMethod()) && path.node.kind !== \"constructor\") {\n        firstPublicElement = path;\n        break;\n      }\n    }\n    if (firstPublicElement != null) {\n      convertToComputedKey(firstPublicElement);\n      prependExpressionsToComputedKey(computedKeyAssignments, firstPublicElement);\n    } else {\n      originalClass.body.body.unshift(_core.types.classProperty(_core.types.sequenceExpression([...computedKeyAssignments, _core.types.stringLiteral(\"_\")]), undefined, undefined, undefined, true, true));\n      applyDecsBody.push(_core.types.expressionStatement(_core.types.unaryExpression(\"delete\", _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier(\"_\")))));\n    }\n    computedKeyAssignments = [];\n  }\n  applyDecsBody.push(_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorationsId != null ? classDecorationsId : _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, setClassName, _core.types.cloneNode(superClass), state, version)));\n  if (staticInitLocal) {\n    applyDecsBody.push(_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()])));\n  }\n  if (staticClosures.length > 0) {\n    applyDecsBody.push(...staticClosures.map(expr => _core.types.expressionStatement(expr)));\n  }\n  path.insertBefore(classAssignments.map(expr => _core.types.expressionStatement(expr)));\n  if (needsDeclarationForClassBinding) {\n    const classBindingInfo = scopeParent.getBinding(classIdLocal.name);\n    if (!classBindingInfo.constantViolations.length) {\n      path.insertBefore(_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));\n    } else {\n      const classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier(\"t\" + classIdLocal.name);\n      const classOuterBindingLocal = classIdLocal;\n      path.replaceWithMultiple([_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(_core.types.cloneNode(classOuterBindingLocal)), _core.types.variableDeclarator(classOuterBindingDelegateLocal)]), _core.types.blockStatement([_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]), path.node, _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(classOuterBindingDelegateLocal), _core.types.cloneNode(classIdLocal)))]), _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(classOuterBindingLocal), _core.types.cloneNode(classOuterBindingDelegateLocal)))]);\n    }\n  }\n  if (decoratedPrivateMethods.size > 0) {\n    checkPrivateMethodUpdateError(path, decoratedPrivateMethods);\n  }\n  path.scope.crawl();\n  return path;\n}\nfunction createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBrandName, setClassName, superClass, state, version) {\n  let lhs, rhs;\n  const args = [setClassName ? createSetFunctionNameCall(state, setClassName) : _core.types.thisExpression(), classDecorations, elementDecorations];\n  if (version !== \"2023-11\") {\n    args.splice(1, 2, elementDecorations, classDecorations);\n  }\n  if (version === \"2021-12\" || version === \"2022-03\" && !state.availableHelper(\"applyDecs2203R\")) {\n    lhs = _core.types.arrayPattern([...elementLocals, ...classLocals]);\n    rhs = _core.types.callExpression(state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"), args);\n    return _core.types.assignmentExpression(\"=\", lhs, rhs);\n  } else if (version === \"2022-03\") {\n    rhs = _core.types.callExpression(state.addHelper(\"applyDecs2203R\"), args);\n  } else if (version === \"2023-01\") {\n    if (maybePrivateBrandName) {\n      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n    }\n    rhs = _core.types.callExpression(state.addHelper(\"applyDecs2301\"), args);\n  } else if (version === \"2023-05\") {\n    if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {\n      args.push(classDecorationsFlag);\n    }\n    if (maybePrivateBrandName) {\n      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n    } else if (superClass) {\n      args.push(_core.types.unaryExpression(\"void\", _core.types.numericLiteral(0)));\n    }\n    if (superClass) args.push(superClass);\n    rhs = _core.types.callExpression(state.addHelper(\"applyDecs2305\"), args);\n  }\n  if (version === \"2023-11\") {\n    if (maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) {\n      args.push(classDecorationsFlag);\n    }\n    if (maybePrivateBrandName) {\n      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n    } else if (superClass) {\n      args.push(_core.types.unaryExpression(\"void\", _core.types.numericLiteral(0)));\n    }\n    if (superClass) args.push(superClass);\n    rhs = _core.types.callExpression(state.addHelper(\"applyDecs2311\"), args);\n  }\n  if (elementLocals.length > 0) {\n    if (classLocals.length > 0) {\n      lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier(\"e\"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier(\"c\"), _core.types.arrayPattern(classLocals))]);\n    } else {\n      lhs = _core.types.arrayPattern(elementLocals);\n      rhs = _core.types.memberExpression(rhs, _core.types.identifier(\"e\"), false, false);\n    }\n  } else {\n    lhs = _core.types.arrayPattern(classLocals);\n    rhs = _core.types.memberExpression(rhs, _core.types.identifier(\"c\"), false, false);\n  }\n  return _core.types.assignmentExpression(\"=\", lhs, rhs);\n}\nfunction isProtoKey(node) {\n  return node.type === \"Identifier\" ? node.name === \"__proto__\" : node.value === \"__proto__\";\n}\nfunction isDecorated(node) {\n  return node.decorators && node.decorators.length > 0;\n}\nfunction shouldTransformElement(node) {\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      return true;\n    case \"ClassMethod\":\n    case \"ClassProperty\":\n    case \"ClassPrivateMethod\":\n    case \"ClassPrivateProperty\":\n      return isDecorated(node);\n    default:\n      return false;\n  }\n}\nfunction shouldTransformClass(node) {\n  return isDecorated(node) || node.body.body.some(shouldTransformElement);\n}\nfunction buildNamedEvaluationVisitor(needsName, visitor) {\n  function handleComputedProperty(propertyPath, key, state) {\n    switch (key.type) {\n      case \"StringLiteral\":\n        return _core.types.stringLiteral(key.value);\n      case \"NumericLiteral\":\n      case \"BigIntLiteral\":\n        {\n          const keyValue = key.value + \"\";\n          propertyPath.get(\"key\").replaceWith(_core.types.stringLiteral(keyValue));\n          return _core.types.stringLiteral(keyValue);\n        }\n      default:\n        {\n          const ref = propertyPath.scope.maybeGenerateMemoised(key);\n          propertyPath.get(\"key\").replaceWith(_core.types.assignmentExpression(\"=\", ref, createToPropertyKeyCall(state, key)));\n          return _core.types.cloneNode(ref);\n        }\n    }\n  }\n  return {\n    VariableDeclarator(path, state) {\n      const id = path.node.id;\n      if (id.type === \"Identifier\") {\n        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"init\"));\n        if (needsName(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    AssignmentExpression(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"right\"));\n        if (needsName(initializer)) {\n          switch (path.node.operator) {\n            case \"=\":\n            case \"&&=\":\n            case \"||=\":\n            case \"??=\":\n              visitor(initializer, state, id.name);\n          }\n        }\n      }\n    },\n    AssignmentPattern(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"right\"));\n        if (needsName(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    ObjectExpression(path, state) {\n      for (const propertyPath of path.get(\"properties\")) {\n        if (!propertyPath.isObjectProperty()) continue;\n        const {\n          node\n        } = propertyPath;\n        const id = node.key;\n        const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get(\"value\"));\n        if (needsName(initializer)) {\n          if (!node.computed) {\n            if (!isProtoKey(id)) {\n              if (id.type === \"Identifier\") {\n                visitor(initializer, state, id.name);\n              } else {\n                const className = _core.types.stringLiteral(id.value + \"\");\n                visitor(initializer, state, className);\n              }\n            }\n          } else {\n            const ref = handleComputedProperty(propertyPath, id, state);\n            visitor(initializer, state, ref);\n          }\n        }\n      }\n    },\n    ClassPrivateProperty(path, state) {\n      const {\n        node\n      } = path;\n      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"value\"));\n      if (needsName(initializer)) {\n        const className = _core.types.stringLiteral(\"#\" + node.key.id.name);\n        visitor(initializer, state, className);\n      }\n    },\n    ClassAccessorProperty(path, state) {\n      const {\n        node\n      } = path;\n      const id = node.key;\n      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"value\"));\n      if (needsName(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else if (id.type === \"PrivateName\") {\n            const className = _core.types.stringLiteral(\"#\" + id.id.name);\n            visitor(initializer, state, className);\n          } else {\n            const className = _core.types.stringLiteral(id.value + \"\");\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(path, id, state);\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      const {\n        node\n      } = path;\n      const id = node.key;\n      const initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"value\"));\n      if (needsName(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else {\n            const className = _core.types.stringLiteral(id.value + \"\");\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(path, id, state);\n          visitor(initializer, state, ref);\n        }\n      }\n    }\n  };\n}\nfunction isDecoratedAnonymousClassExpression(path) {\n  return path.isClassExpression({\n    id: null\n  }) && shouldTransformClass(path.node);\n}\nfunction generateLetUidIdentifier(scope, name) {\n  const id = scope.generateUidIdentifier(name);\n  scope.push({\n    id,\n    kind: \"let\"\n  });\n  return _core.types.cloneNode(id);\n}\nfunction _default({\n  assertVersion,\n  assumption\n}, {\n  loose\n}, version, inherits) {\n  var _assumption, _assumption2;\n  if (version === \"2023-11\" || version === \"2023-05\" || version === \"2023-01\") {\n    assertVersion(\"^7.21.0\");\n  } else if (version === \"2021-12\") {\n    assertVersion(\"^7.16.0\");\n  } else {\n    assertVersion(\"^7.19.0\");\n  }\n  const VISITED = new WeakSet();\n  const constantSuper = (_assumption = assumption(\"constantSuper\")) != null ? _assumption : loose;\n  const ignoreFunctionLength = (_assumption2 = assumption(\"ignoreFunctionLength\")) != null ? _assumption2 : loose;\n  const namedEvaluationVisitor = buildNamedEvaluationVisitor(isDecoratedAnonymousClassExpression, visitClass);\n  function visitClass(path, state, className) {\n    var _node$id;\n    if (VISITED.has(path)) return;\n    const {\n      node\n    } = path;\n    className != null ? className : className = (_node$id = node.id) == null ? void 0 : _node$id.name;\n    const newPath = transformClass(path, state, constantSuper, ignoreFunctionLength, className, namedEvaluationVisitor, version);\n    if (newPath) {\n      VISITED.add(newPath);\n      return;\n    }\n    VISITED.add(path);\n  }\n  return {\n    name: \"proposal-decorators\",\n    inherits: inherits,\n    visitor: Object.assign({\n      ExportDefaultDeclaration(path, state) {\n        const {\n          declaration\n        } = path.node;\n        if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && isDecorated(declaration)) {\n          var _path$splitExportDecl;\n          const isAnonymous = !declaration.id;\n          (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n          const updatedVarDeclarationPath = path.splitExportDeclaration();\n          if (isAnonymous) {\n            visitClass(updatedVarDeclarationPath, state, _core.types.stringLiteral(\"default\"));\n          }\n        }\n      },\n      ExportNamedDeclaration(path) {\n        const {\n          declaration\n        } = path.node;\n        if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && isDecorated(declaration)) {\n          var _path$splitExportDecl2;\n          (_path$splitExportDecl2 = path.splitExportDeclaration) != null ? _path$splitExportDecl2 : path.splitExportDeclaration = require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n          path.splitExportDeclaration();\n        }\n      },\n      Class(path, state) {\n        visitClass(path, state, undefined);\n      }\n    }, namedEvaluationVisitor)\n  };\n}\n\n//# sourceMappingURL=decorators.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComputedKeys = extractComputedKeys;\nexports.injectInitialization = injectInitialization;\nexports.memoiseComputedKey = memoiseComputedKey;\nvar _core = require(\"@babel/core\");\nvar _traverse = require(\"@babel/traverse\");\nconst findBareSupers = _traverse.visitors.environmentVisitor({\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n});\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n  ReferencedIdentifier(path, {\n    scope\n  }) {\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n};\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ,\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  }\n};\nfunction injectInitialization(path, constructor, nodes, renamer, lastReturnsThis) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        isFirst = false;\n      } else {\n        nodes = nodes.map(n => _core.types.cloneNode(n));\n      }\n      if (!bareSuper.parentPath.isExpressionStatement()) {\n        const allNodes = [bareSuper.node, ...nodes.map(n => _core.types.toExpression(n))];\n        if (!lastReturnsThis) allNodes.push(_core.types.thisExpression());\n        bareSuper.replaceWith(_core.types.sequenceExpression(allNodes));\n      } else {\n        bareSuper.insertAfter(nodes);\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\nfunction memoiseComputedKey(keyNode, scope, hint) {\n  const isUidReference = _core.types.isIdentifier(keyNode) && scope.hasUid(keyNode.name);\n  if (isUidReference) {\n    return;\n  }\n  const isMemoiseAssignment = _core.types.isAssignmentExpression(keyNode, {\n    operator: \"=\"\n  }) && _core.types.isIdentifier(keyNode.left) && scope.hasUid(keyNode.left.name);\n  if (isMemoiseAssignment) {\n    return _core.types.cloneNode(keyNode);\n  } else {\n    const ident = _core.types.identifier(hint);\n    scope.push({\n      id: ident,\n      kind: \"let\"\n    });\n    return _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), keyNode);\n  }\n}\nfunction extractComputedKeys(path, computedPaths, file) {\n  const {\n    scope\n  } = path;\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && scope.getBinding(path.node.id.name),\n    file\n  };\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n    const computedNode = computedPath.node;\n    if (!computedKey.isConstantExpression()) {\n      const assignment = memoiseComputedKey(computedKey.node, scope, scope.generateUidBasedOnNode(computedKey.node));\n      if (assignment) {\n        declarations.push(_core.types.expressionStatement(assignment));\n        computedNode.key = _core.types.cloneNode(assignment.left);\n      }\n    }\n  }\n  return declarations;\n}\n\n//# sourceMappingURL=misc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildDecoratedClass = buildDecoratedClass;\nvar _core = require(\"@babel/core\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\nfunction takeDecorators(node) {\n  let result;\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n  node.decorators = undefined;\n  return result;\n}\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\nfunction extractElementDescriptor(file, classRef, superRef, path) {\n  const isMethod = path.isClassMethod();\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n  if (path.node.type === \"ClassAccessorProperty\") {\n    throw path.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n  if (path.node.type === \"StaticBlock\") {\n    throw path.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n  const {\n    node,\n    scope\n  } = path;\n  if (!path.isTSDeclareMethod()) {\n    new _helperReplaceSupers.default({\n      methodPath: path,\n      objectRef: classRef,\n      superRef,\n      file,\n      refToPreserve: classRef\n    }).replace();\n  }\n  const properties = [prop(\"kind\", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n  if (isMethod) {\n    var _path$ensureFunctionN;\n    (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n    path.ensureFunctionName(false);\n    properties.push(prop(\"value\", _core.types.toExpression(path.node)));\n  } else if (_core.types.isClassProperty(node) && node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\nfunction addDecorateHelper(file) {\n  return file.addHelper(\"decorate\");\n}\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n  const classDecorators = takeDecorators(node);\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract && element.node.type !== \"TSIndexSignature\").map(path => extractElementDescriptor(file, node.id, superId, path)));\n  const wrapperCall = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n  let replacement = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n  if (isDeclaration) {\n    replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n  return {\n    instanceNodes: [_core.template.statement.ast`\n        ${_core.types.cloneNode(initializeId)}(this)\n      `],\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n  };\n}\n\n//# sourceMappingURL=decorators-2018-09.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FEATURES = void 0;\nexports.enableFeature = enableFeature;\nexports.isLoose = isLoose;\nexports.shouldTransform = shouldTransform;\nvar _decorators = require(\"./decorators.js\");\nconst FEATURES = exports.FEATURES = Object.freeze({\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3,\n  privateIn: 1 << 4,\n  staticBlocks: 1 << 5\n});\nconst featuresSameLoose = new Map([[FEATURES.fields, \"@babel/plugin-transform-class-properties\"], [FEATURES.privateMethods, \"@babel/plugin-transform-private-methods\"], [FEATURES.privateIn, \"@babel/plugin-transform-private-property-in-object\"]]);\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\nvar looseLowPriorityKey = \"@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing\";\nvar canIgnoreLoose = function (file, feature) {\n  return !!(file.get(looseLowPriorityKey) & feature);\n};\nfunction enableFeature(file, feature, loose) {\n  if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n    if (loose === \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, true);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else if (loose === \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, false);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else {\n      setLoose(file, feature, loose);\n    }\n  }\n  let resolvedLoose;\n  for (const [mask, name] of featuresSameLoose) {\n    if (!hasFeature(file, mask)) continue;\n    if (canIgnoreLoose(file, mask)) continue;\n    const loose = isLoose(file, mask);\n    if (resolvedLoose === !loose) {\n      throw new Error(\"'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, \" + \"@babel/plugin-transform-private-methods and \" + \"@babel/plugin-transform-private-property-in-object (when they are enabled).\" + \"\\n\\n\" + getBabelShowConfigForHint(file));\n    } else {\n      resolvedLoose = loose;\n      var higherPriorityPluginName = name;\n    }\n  }\n  if (resolvedLoose !== undefined) {\n    for (const [mask, name] of featuresSameLoose) {\n      if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {\n        setLoose(file, mask, resolvedLoose);\n        console.warn(`Though the \"loose\" option was set to \"${!resolvedLoose}\" in your @babel/preset-env ` + `config, it will not be used for ${name} since the \"loose\" mode option was set to ` + `\"${resolvedLoose}\" for ${higherPriorityPluginName}.\\nThe \"loose\" option must be the ` + `same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods ` + `and @babel/plugin-transform-private-property-in-object (when they are enabled): you can ` + `silence this warning by explicitly adding\\n` + `\\t[\"${name}\", { \"loose\": ${resolvedLoose} }]\\n` + `to the \"plugins\" section of your Babel config.` + \"\\n\\n\" + getBabelShowConfigForHint(file));\n      }\n    }\n  }\n}\nfunction getBabelShowConfigForHint(file) {\n  let {\n    filename\n  } = file.opts;\n  if (!filename || filename === \"unknown\") {\n    filename = \"[name of the input file]\";\n  }\n  return `\\\nIf you already set the same 'loose' mode for these plugins in your config, it's possible that they \\\nare enabled multiple times with different options.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded \\\nconfiguration:\n\\tnpx cross-env BABEL_SHOW_CONFIG_FOR=${filename} <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.`;\n}\nfunction hasFeature(file, feature) {\n  return !!(file.get(featuresKey) & feature);\n}\nfunction isLoose(file, feature) {\n  return !!(file.get(looseKey) & feature);\n}\nfunction setLoose(file, feature, loose) {\n  if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);\n  file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);\n}\nfunction shouldTransform(path, file) {\n  let decoratorPath = null;\n  let publicFieldPath = null;\n  let privateFieldPath = null;\n  let privateMethodPath = null;\n  let staticBlockPath = null;\n  if ((0, _decorators.hasOwnDecorators)(path.node)) {\n    decoratorPath = path.get(\"decorators.0\");\n  }\n  for (const el of path.get(\"body.body\")) {\n    if (!decoratorPath && (0, _decorators.hasOwnDecorators)(el.node)) {\n      decoratorPath = el.get(\"decorators.0\");\n    }\n    if (!publicFieldPath && el.isClassProperty()) {\n      publicFieldPath = el;\n    }\n    if (!privateFieldPath && el.isClassPrivateProperty()) {\n      privateFieldPath = el;\n    }\n    if (!privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod()) {\n      privateMethodPath = el;\n    }\n    if (!staticBlockPath && el.isStaticBlock != null && el.isStaticBlock()) {\n      staticBlockPath = el;\n    }\n  }\n  if (decoratorPath && privateFieldPath) {\n    throw privateFieldPath.buildCodeFrameError(\"Private fields in decorated classes are not supported yet.\");\n  }\n  if (decoratorPath && privateMethodPath) {\n    throw privateMethodPath.buildCodeFrameError(\"Private methods in decorated classes are not supported yet.\");\n  }\n  if (decoratorPath && !hasFeature(file, FEATURES.decorators)) {\n    throw path.buildCodeFrameError(\"Decorators are not enabled.\" + \"\\nIf you are using \" + '[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }], ' + 'make sure it comes *before* \"@babel/plugin-transform-class-properties\" ' + \"and enable loose mode, like so:\\n\" + '\\t[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }]\\n' + '\\t[\"@babel/plugin-transform-class-properties\", { \"loose\": true }]');\n  }\n  if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) {\n    throw privateMethodPath.buildCodeFrameError(\"Class private methods are not enabled. \" + \"Please add `@babel/plugin-transform-private-methods` to your configuration.\");\n  }\n  if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods)) {\n    throw path.buildCodeFrameError(\"Class fields are not enabled. \" + \"Please add `@babel/plugin-transform-class-properties` to your configuration.\");\n  }\n  if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) {\n    throw path.buildCodeFrameError(\"Static class blocks are not enabled. \" + \"Please add `@babel/plugin-transform-class-static-block` to your configuration.\");\n  }\n  if (decoratorPath || privateMethodPath || staticBlockPath) {\n    return true;\n  }\n  if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields)) {\n    return true;\n  }\n  return false;\n}\n\n//# sourceMappingURL=features.js.map\n"]}