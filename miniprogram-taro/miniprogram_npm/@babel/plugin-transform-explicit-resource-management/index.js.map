{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginTransformDestructuring = require(\"@babel/plugin-transform-destructuring\");\nvar _core = require(\"@babel/core\");\nfunction isAnonymousFunctionDefinition(node) {\n  return _core.types.isArrowFunctionExpression(node) || (_core.types.isFunctionExpression(node) || _core.types.isClassExpression(node)) && !node.id;\n}\nfunction emitSetFunctionNameCall(state, expression, name) {\n  return _core.types.callExpression(state.addHelper(\"setFunctionName\"), [expression, _core.types.stringLiteral(name)]);\n}\nvar _default = exports.default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(\"^7.23.9 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const TOP_LEVEL_USING = new Map();\n  function isUsingDeclaration(node) {\n    if (!_core.types.isVariableDeclaration(node)) return false;\n    return node.kind === \"using\" || node.kind === \"await using\" || TOP_LEVEL_USING.has(node);\n  }\n  const transformUsingDeclarationsVisitor = {\n    ForOfStatement(path) {\n      const {\n        left\n      } = path.node;\n      if (!isUsingDeclaration(left)) return;\n      const {\n        id\n      } = left.declarations[0];\n      const tmpId = path.scope.generateUidIdentifierBasedOnNode(id);\n      left.declarations[0].id = tmpId;\n      left.kind = \"const\";\n      path.ensureBlock();\n      (0, _pluginTransformDestructuring.unshiftForXStatementBody)(path, [_core.types.variableDeclaration(\"using\", [_core.types.variableDeclarator(id, _core.types.cloneNode(tmpId))])]);\n    },\n    \"BlockStatement|StaticBlock\"(path, state) {\n      let ctx = null;\n      let needsAwait = false;\n      const scope = path.scope;\n      for (const node of path.node.body) {\n        if (!isUsingDeclaration(node)) continue;\n        ctx != null ? ctx : ctx = scope.generateUidIdentifier(\"usingCtx\");\n        const isAwaitUsing = node.kind === \"await using\" || TOP_LEVEL_USING.get(node) === 1;\n        needsAwait || (needsAwait = isAwaitUsing);\n        if (!TOP_LEVEL_USING.delete(node)) {\n          node.kind = \"const\";\n        }\n        for (const decl of node.declarations) {\n          const currentInit = decl.init;\n          decl.init = _core.types.callExpression(_core.types.memberExpression(_core.types.cloneNode(ctx), isAwaitUsing ? _core.types.identifier(\"a\") : _core.types.identifier(\"u\")), [isAnonymousFunctionDefinition(currentInit) && _core.types.isIdentifier(decl.id) ? emitSetFunctionNameCall(state, currentInit, decl.id.name) : currentInit]);\n        }\n      }\n      if (!ctx) return;\n      const disposeCall = _core.types.callExpression(_core.types.memberExpression(_core.types.cloneNode(ctx), _core.types.identifier(\"d\")), []);\n      const replacement = _core.template.statement.ast`\n        try {\n          var ${_core.types.cloneNode(ctx)} = ${state.addHelper(\"usingCtx\")}();\n          ${path.node.body}\n        } catch (_) {\n          ${_core.types.cloneNode(ctx)}.e = _;\n        } finally {\n          ${needsAwait ? _core.types.awaitExpression(disposeCall) : disposeCall}\n        }\n      `;\n      _core.types.inherits(replacement, path.node);\n      const {\n        parentPath\n      } = path;\n      if (parentPath.isFunction() || parentPath.isTryStatement() || parentPath.isCatchClause()) {\n        path.replaceWith(_core.types.blockStatement([replacement]));\n      } else if (path.isStaticBlock()) {\n        path.node.body = [replacement];\n      } else {\n        path.replaceWith(replacement);\n      }\n    }\n  };\n  const transformUsingDeclarationsVisitorSkipFn = _core.traverse.visitors.merge([transformUsingDeclarationsVisitor, {\n    Function(path) {\n      path.skip();\n    }\n  }]);\n  return {\n    name: \"transform-explicit-resource-management\",\n    manipulateOptions: (_, p) => p.plugins.push(\"explicitResourceManagement\"),\n    visitor: _core.traverse.visitors.merge([transformUsingDeclarationsVisitor, {\n      Program(path) {\n        TOP_LEVEL_USING.clear();\n        if (path.node.sourceType !== \"module\") return;\n        if (!path.node.body.some(isUsingDeclaration)) return;\n        const innerBlockBody = [];\n        for (const stmt of path.get(\"body\")) {\n          if (stmt.isFunctionDeclaration() || stmt.isImportDeclaration()) {\n            continue;\n          }\n          let node = stmt.node;\n          let shouldRemove = true;\n          if (stmt.isExportDefaultDeclaration()) {\n            let {\n              declaration\n            } = stmt.node;\n            let varId;\n            if (_core.types.isClassDeclaration(declaration)) {\n              varId = declaration.id;\n              declaration.id = _core.types.cloneNode(varId);\n              declaration = _core.types.toExpression(declaration);\n            } else if (!_core.types.isExpression(declaration)) {\n              continue;\n            }\n            varId != null ? varId : varId = path.scope.generateUidIdentifier(\"_default\");\n            innerBlockBody.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(varId, declaration)]));\n            stmt.replaceWith(_core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(varId), _core.types.identifier(\"default\"))]));\n            continue;\n          }\n          if (stmt.isExportNamedDeclaration()) {\n            node = stmt.node.declaration;\n            if (!node || _core.types.isFunction(node)) continue;\n            stmt.replaceWith(_core.types.exportNamedDeclaration(null, Object.keys(_core.types.getOuterBindingIdentifiers(node, false)).map(id => _core.types.exportSpecifier(_core.types.identifier(id), _core.types.identifier(id)))));\n            shouldRemove = false;\n          } else if (stmt.isExportDeclaration()) {\n            continue;\n          }\n          if (_core.types.isClassDeclaration(node)) {\n            const {\n              id\n            } = node;\n            node.id = _core.types.cloneNode(id);\n            innerBlockBody.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.toExpression(node))]));\n          } else if (_core.types.isVariableDeclaration(node)) {\n            if (node.kind === \"using\") {\n              TOP_LEVEL_USING.set(stmt.node, 0);\n            } else if (node.kind === \"await using\") {\n              TOP_LEVEL_USING.set(stmt.node, 1);\n            }\n            node.kind = \"var\";\n            innerBlockBody.push(node);\n          } else {\n            innerBlockBody.push(stmt.node);\n          }\n          if (shouldRemove) stmt.remove();\n        }\n        path.pushContainer(\"body\", _core.types.blockStatement(innerBlockBody));\n      },\n      Function(path, state) {\n        if (path.node.async) {\n          path.traverse(transformUsingDeclarationsVisitorSkipFn, state);\n        }\n      }\n    }])\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}