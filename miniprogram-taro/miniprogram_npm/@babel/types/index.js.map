{"version":3,"sources":["index.js","validators/react/isReactComponent.js","validators/buildMatchMemberExpression.js","validators/matchesPattern.js","validators/generated/index.js","utils/shallowEqual.js","utils/deprecationWarning.js","validators/react/isCompatTag.js","builders/react/buildChildren.js","utils/react/cleanJSXElementLiteralChild.js","builders/generated/index.js","builders/generated/lowercase.js","validators/validate.js","definitions/index.js","definitions/core.js","validators/is.js","validators/isType.js","validators/isPlaceholderType.js","validators/isValidIdentifier.js","constants/index.js","definitions/utils.js","definitions/flow.js","definitions/jsx.js","definitions/misc.js","definitions/placeholders.js","definitions/experimental.js","definitions/typescript.js","definitions/deprecated-aliases.js","builders/generated/uppercase.js","asserts/assertNode.js","validators/isNode.js","asserts/generated/index.js","builders/flow/createTypeAnnotationBasedOnTypeof.js","builders/flow/createFlowUnionType.js","modifications/flow/removeTypeDuplicates.js","builders/typescript/createTSUnionType.js","modifications/typescript/removeTypeDuplicates.js","builders/productions.js","clone/cloneNode.js","clone/clone.js","clone/cloneDeep.js","clone/cloneDeepWithoutLoc.js","clone/cloneWithoutLoc.js","comments/addComment.js","comments/addComments.js","comments/inheritInnerComments.js","utils/inherit.js","comments/inheritLeadingComments.js","comments/inheritsComments.js","comments/inheritTrailingComments.js","comments/removeComments.js","constants/generated/index.js","converters/ensureBlock.js","converters/toBlock.js","converters/toBindingIdentifierName.js","converters/toIdentifier.js","converters/toComputedKey.js","converters/toExpression.js","converters/toKeyAlias.js","modifications/removePropertiesDeep.js","traverse/traverseFast.js","modifications/removeProperties.js","converters/toStatement.js","converters/valueToNode.js","modifications/appendToMemberExpression.js","modifications/inherits.js","modifications/prependToMemberExpression.js","retrievers/getAssignmentIdentifiers.js","retrievers/getBindingIdentifiers.js","retrievers/getOuterBindingIdentifiers.js","retrievers/getFunctionName.js","traverse/traverse.js","validators/isBinding.js","validators/isBlockScoped.js","validators/isLet.js","validators/isImmutable.js","validators/isNodesEquivalent.js","validators/isReferenced.js","validators/isScope.js","validators/isSpecifierDefault.js","validators/isValidES3Identifier.js","validators/isVar.js","converters/toSequenceExpression.js","converters/gatherSequenceExpressions.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AMlBA,ADGA,AHSA,AENA,ADGA;AHUA,AMlBA,ADGA,AHSA,AENA,ADGA;AHUA,AMlBA,ADGA,ADGA,ADGA;AHUA,AMlBA,ADGA,ADGA,ADGA,AIZA;APsBA,AMlBA,ADGA,ADGA,ADGA,AIZA;APsBA,AMlBA,ADGA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,ADGA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,ADGA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,ADGA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;ACFA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;AGRA,AFMA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;AGRA,AFMA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;AGRA,AFMA,ARwBA,AMlBA,AGTA,AJYA,ADGA,ADGA,AIZA;AGRA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA;AOpBA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA;AOpBA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA;AOpBA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,ARwBA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AKfA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AKfA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AKfA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,ADGA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AZoCA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AZoCA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AZoCA,AS3BA;AFOA,ACHA,AHSA,AMlBA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,ACHA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,ACHA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,ACHA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AbuCA,AS3BA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;AFOA,ACHA,AGTA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;AFOA,ACHA,AQxBA,ALeA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;AFOA,ACHA,AQxBA,ALeA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;AFOA,ACHA,AQxBA,ALeA,ADGA,AbuCA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,ADGA,AOrBA,ApB4DA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,ADGA,AOrBA,ApB4DA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,ADGA,AOrBA,ApB4DA,AMlBA,AGTA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AOrBA,ApB4DA,AS3BA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AOrBA,ApB4DA,AS3BA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AOrBA,ApB4DA,AS3BA,ALeA,AWjCA,AENA,ADGA,AENA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,AFMA,ApB4DA,AS3BA,ALeA,AWjCA,AENA,ACHA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,AFMA,ApB4DA,AS3BA,ALeA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,AFMA,ApB4DA,AIZA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,AHSA,ApB4DA,AIZA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,AHSA,ApB4DA,AIZA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,AHSA,ApB4DA,AIZA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AWjCA,AGTA,ANkBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AOrBA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AJYA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,AQxBA;ADIA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AQxBA,ALeA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AQxBA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AQxBA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AQxBA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AiBnDA,AT2BA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AiBnDA,AT2BA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AOpBA,AiBnDA,AT2BA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AyB1EA,AlBsDA,AiBnDA,AT2BA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AyB1EA,AlBsDA,AiBnDA,AT2BA,ALeA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AyB1EA,AlBsDA,AiBnDA,Ad0CA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA;AyB1EA,AlBsDA,AiBnDA,Ad0CA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AlBsDA,AiBnDA,Ad0CA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AlBsDA,AiBnDA,Ad0CA,AavCA,AFMA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ApB4DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ApB4DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ApB4DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ACHA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ACHA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,ACHA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,ACHA,AENA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,ACHA,AGTA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AIZA,A0B9EA;ADIA,AENA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA,A0B9EA;ADIA,AENA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,Ad0CA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,A9B0FA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AOrBA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,ArB+DA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,AGTA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,AGTA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,AGTA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,AENA,ADGA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ADGA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ADGA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ADGA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AS3BA,AFMA,AIZA,ACHA,ACHA,AHSA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AOrBA,AIZA,ACHA,ACHA,AHSA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AOrBA,AIZA,ACHA,ACHA,AHSA,AxBwEA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AOrBA,AIZA,ACHA,ACHA,AHSA,AIZA,A5BoFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ACHA,ArB+DA,AiBnDA,AOrBA,AIZA,ACHA,ACHA,AHSA,AIZA,A5BoFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AWjCA,ACHA,ACHA,AHSA,AIZA,A5BoFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AWjCA,ACHA,ACHA,AHSA,AIZA,ACHA,A7BuFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AYpCA,ACHA,AHSA,AIZA,ACHA,A7BuFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AYpCA,ACHA,AHSA,AIZA,ACHA,A7BuFA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AYpCA,ACHA,AHSA,AIZA,ACHA,ACHA,A9B0FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AavCA,AHSA,AIZA,ACHA,ACHA,A9B0FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AavCA,AHSA,AIZA,ACHA,ACHA,A9B0FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AavCA,AHSA,AIZA,ACHA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AIZA,ACHA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AIZA,ACHA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AIZA,ACHA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,A/B6FA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,AENA,AjCmGA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,AENA,AjCmGA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,AENA,AjCmGA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AKfA,ACHA,ACHA,AENA,ACHA,AlCsGA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,ACHA,AENA,ACHA,AlCsGA,AWjCA,AJYA,ARwBA,AS3BA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,ACHA,AENA,ACHA,AlCsGA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,ACHA,AENA,AENA,ADGA,AlCsGA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AlCsGA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AlCsGA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AENA,ApC4GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AENA,ApC4GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AU9BA,A1C8HA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AENA,ApC4GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AGTA,AENA,ADGA,AENA,ACHA,ArC+GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AMlBA,AKfA,ADGA,AENA,ACHA,ArC+GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AWjCA,ADGA,AENA,ACHA,ArC+GA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AWjCA,ADGA,AENA,ACHA,ACHA,AtCkHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AWjCA,ADGA,AENA,ACHA,ACHA,AtCkHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AWjCA,ADGA,AENA,ACHA,ACHA,AtCkHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AWjCA,ADGA,AENA,ACHA,ACHA,ACHA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AU9BA,AENA,ACHA,ACHA,ACHA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AU9BA,AENA,ACHA,ACHA,ACHA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AYpCA,ACHA,ACHA,AENA,ADGA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AYpCA,ACHA,ACHA,AENA,ADGA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AYpCA,ACHA,ACHA,AENA,ADGA,AvCqHA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AYpCA,ACHA,ACHA,AENA,ADGA,AENA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,ACHA,AENA,ADGA,AENA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,ACHA,AENA,ADGA,AENA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AkCtGA,AENA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,ACHA,AENA,ADGA,AGTA,ADGA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,ACHA,AENA,ADGA,AGTA,ADGA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,ACHA,AENA,ADGA,AGTA,ADGA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AzC2HA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AoC5GA,AhCgGA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,AvDqKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,AvDqKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,AvDqKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AGTA,ACHA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A2DjLA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,A5CoIA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,AIZA,AhDgJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,AIZA,AhDgJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AENA,AIZA,AFMA,AGTA,AIZA,AhDgJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,AFMA,AGTA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,AFMA,AGTA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,A6DvLA,AFMA,ACHA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,AHSA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,AHSA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,AHSA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,AJYA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,AJYA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,AJYA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AMlBA,ACHA,AIZA,ACHA,AjDmJA,AWjCA,AJYA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,ADGA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,APqBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,APqBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,APqBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,ACHA,ARwBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,ACHA,ARwBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,ACHA,ARwBA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AgEhMA,ACHA,ACHA,ALeA,AMlBA,ACHA,ACHA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,ACHA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,ACHA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AOrBA,AIZA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AT2BA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AavCA,AWjCA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA;A2BhFA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA,AoE5MA;AzC4HA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA,AoE5MA;AzC4HA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA,AoE5MA;AzC4HA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA,AoE5MA,ACHA;A1C+HA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ADGA,AENA,AXiCA,AxDwKA,AoE5MA,ACHA;A1C+HA,ApB4DA,AiBnDA,AU9BA,AwBxEA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA;A1C+HA,ApB4DA,AiBnDA,AkCtGA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,ACHA;A3CkIA,ApB4DA,AiBnDA,AkCtGA,ACHA,AjDmJA,AOrBA,ACHA,AIZA,ANkBA,ApB4DA,AiEnMA,AENA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,ACHA;A3CkIA,ApB4DA,AiBnDA,AkCtGA,ACHA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,ACHA;A3CkIA,ApB4DA,AiBnDA,AkCtGA,ACHA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA;A3CkIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA;A3CkIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA;A3CkIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA,AENA;A7CwIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA,AENA;A7CwIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA,AENA;A7CwIA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA,AENA,ACHA;A9C2IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,ACHA,AENA,ADGA,AENA,ACHA;A9C2IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ADGA,AENA,ACHA;A9C2IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ADGA,AENA,ACHA,ACHA;A/C8IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ADGA,AENA,ACHA,ACHA;A/C8IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA;A/C8IA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA;AhDiJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA;AhDiJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA;AhDiJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AjDoJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AjDoJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;AjDoJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AoE5MA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AuErNA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AmCzGA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AuErNA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AsDlKA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AuErNA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AsDlKA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AsDlKA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AmEzMA,ACHA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,ACHA,ACHA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,ACHA,AENA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AGTA,ACHA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AIZA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AIZA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AIZA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AIZA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA,AIZA;AlDuJA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,ACHA,AnEyMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ADGA,AnByDA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AENA,AlEsMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ApB4DA,AjDmJA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AwExNA,ACHA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AoE5MA,AhEgMA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,AuDrKA,ArE+MA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA,AyE3NA;A9C2IA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AiBnDA,Ad0CA,AOrBA,AKfA,ANkBA,ApB4DA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AOrBA,AKfA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,A1B8EA,AIZA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AYpCA,AtBkEA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;A2BhFA,ApB4DA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,AGTA,AV8BA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA,APqBA;AOpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  createFlowUnionType: true,\n  createTSUnionType: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneDeepWithoutLoc: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getAssignmentIdentifiers: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  getFunctionName: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isPlaceholderType: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true,\n  __internal__deprecationWarning: true\n};\nObject.defineProperty(exports, \"__internal__deprecationWarning\", {\n  enumerable: true,\n  get: function () {\n    return _deprecationWarning.default;\n  }\n});\nObject.defineProperty(exports, \"addComment\", {\n  enumerable: true,\n  get: function () {\n    return _addComment.default;\n  }\n});\nObject.defineProperty(exports, \"addComments\", {\n  enumerable: true,\n  get: function () {\n    return _addComments.default;\n  }\n});\nObject.defineProperty(exports, \"appendToMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _appendToMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"assertNode\", {\n  enumerable: true,\n  get: function () {\n    return _assertNode.default;\n  }\n});\nObject.defineProperty(exports, \"buildMatchMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _buildMatchMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"clone\", {\n  enumerable: true,\n  get: function () {\n    return _clone.default;\n  }\n});\nObject.defineProperty(exports, \"cloneDeep\", {\n  enumerable: true,\n  get: function () {\n    return _cloneDeep.default;\n  }\n});\nObject.defineProperty(exports, \"cloneDeepWithoutLoc\", {\n  enumerable: true,\n  get: function () {\n    return _cloneDeepWithoutLoc.default;\n  }\n});\nObject.defineProperty(exports, \"cloneNode\", {\n  enumerable: true,\n  get: function () {\n    return _cloneNode.default;\n  }\n});\nObject.defineProperty(exports, \"cloneWithoutLoc\", {\n  enumerable: true,\n  get: function () {\n    return _cloneWithoutLoc.default;\n  }\n});\nObject.defineProperty(exports, \"createFlowUnionType\", {\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"createTSUnionType\", {\n  enumerable: true,\n  get: function () {\n    return _createTSUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n  enumerable: true,\n  get: function () {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n});\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"ensureBlock\", {\n  enumerable: true,\n  get: function () {\n    return _ensureBlock.default;\n  }\n});\nObject.defineProperty(exports, \"getAssignmentIdentifiers\", {\n  enumerable: true,\n  get: function () {\n    return _getAssignmentIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"getBindingIdentifiers\", {\n  enumerable: true,\n  get: function () {\n    return _getBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"getFunctionName\", {\n  enumerable: true,\n  get: function () {\n    return _getFunctionName.default;\n  }\n});\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n  enumerable: true,\n  get: function () {\n    return _getOuterBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"inheritInnerComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritInnerComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritLeadingComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritLeadingComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritTrailingComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritTrailingComments.default;\n  }\n});\nObject.defineProperty(exports, \"inherits\", {\n  enumerable: true,\n  get: function () {\n    return _inherits.default;\n  }\n});\nObject.defineProperty(exports, \"inheritsComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritsComments.default;\n  }\n});\nObject.defineProperty(exports, \"is\", {\n  enumerable: true,\n  get: function () {\n    return _is.default;\n  }\n});\nObject.defineProperty(exports, \"isBinding\", {\n  enumerable: true,\n  get: function () {\n    return _isBinding.default;\n  }\n});\nObject.defineProperty(exports, \"isBlockScoped\", {\n  enumerable: true,\n  get: function () {\n    return _isBlockScoped.default;\n  }\n});\nObject.defineProperty(exports, \"isImmutable\", {\n  enumerable: true,\n  get: function () {\n    return _isImmutable.default;\n  }\n});\nObject.defineProperty(exports, \"isLet\", {\n  enumerable: true,\n  get: function () {\n    return _isLet.default;\n  }\n});\nObject.defineProperty(exports, \"isNode\", {\n  enumerable: true,\n  get: function () {\n    return _isNode.default;\n  }\n});\nObject.defineProperty(exports, \"isNodesEquivalent\", {\n  enumerable: true,\n  get: function () {\n    return _isNodesEquivalent.default;\n  }\n});\nObject.defineProperty(exports, \"isPlaceholderType\", {\n  enumerable: true,\n  get: function () {\n    return _isPlaceholderType.default;\n  }\n});\nObject.defineProperty(exports, \"isReferenced\", {\n  enumerable: true,\n  get: function () {\n    return _isReferenced.default;\n  }\n});\nObject.defineProperty(exports, \"isScope\", {\n  enumerable: true,\n  get: function () {\n    return _isScope.default;\n  }\n});\nObject.defineProperty(exports, \"isSpecifierDefault\", {\n  enumerable: true,\n  get: function () {\n    return _isSpecifierDefault.default;\n  }\n});\nObject.defineProperty(exports, \"isType\", {\n  enumerable: true,\n  get: function () {\n    return _isType.default;\n  }\n});\nObject.defineProperty(exports, \"isValidES3Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _isValidES3Identifier.default;\n  }\n});\nObject.defineProperty(exports, \"isValidIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _isValidIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"isVar\", {\n  enumerable: true,\n  get: function () {\n    return _isVar.default;\n  }\n});\nObject.defineProperty(exports, \"matchesPattern\", {\n  enumerable: true,\n  get: function () {\n    return _matchesPattern.default;\n  }\n});\nObject.defineProperty(exports, \"prependToMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _prependToMemberExpression.default;\n  }\n});\nexports.react = void 0;\nObject.defineProperty(exports, \"removeComments\", {\n  enumerable: true,\n  get: function () {\n    return _removeComments.default;\n  }\n});\nObject.defineProperty(exports, \"removeProperties\", {\n  enumerable: true,\n  get: function () {\n    return _removeProperties.default;\n  }\n});\nObject.defineProperty(exports, \"removePropertiesDeep\", {\n  enumerable: true,\n  get: function () {\n    return _removePropertiesDeep.default;\n  }\n});\nObject.defineProperty(exports, \"removeTypeDuplicates\", {\n  enumerable: true,\n  get: function () {\n    return _removeTypeDuplicates.default;\n  }\n});\nObject.defineProperty(exports, \"shallowEqual\", {\n  enumerable: true,\n  get: function () {\n    return _shallowEqual.default;\n  }\n});\nObject.defineProperty(exports, \"toBindingIdentifierName\", {\n  enumerable: true,\n  get: function () {\n    return _toBindingIdentifierName.default;\n  }\n});\nObject.defineProperty(exports, \"toBlock\", {\n  enumerable: true,\n  get: function () {\n    return _toBlock.default;\n  }\n});\nObject.defineProperty(exports, \"toComputedKey\", {\n  enumerable: true,\n  get: function () {\n    return _toComputedKey.default;\n  }\n});\nObject.defineProperty(exports, \"toExpression\", {\n  enumerable: true,\n  get: function () {\n    return _toExpression.default;\n  }\n});\nObject.defineProperty(exports, \"toIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _toIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"toKeyAlias\", {\n  enumerable: true,\n  get: function () {\n    return _toKeyAlias.default;\n  }\n});\nObject.defineProperty(exports, \"toStatement\", {\n  enumerable: true,\n  get: function () {\n    return _toStatement.default;\n  }\n});\nObject.defineProperty(exports, \"traverse\", {\n  enumerable: true,\n  get: function () {\n    return _traverse.default;\n  }\n});\nObject.defineProperty(exports, \"traverseFast\", {\n  enumerable: true,\n  get: function () {\n    return _traverseFast.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"valueToNode\", {\n  enumerable: true,\n  get: function () {\n    return _valueToNode.default;\n  }\n});\nvar _isReactComponent = require(\"./validators/react/isReactComponent.js\");\nvar _isCompatTag = require(\"./validators/react/isCompatTag.js\");\nvar _buildChildren = require(\"./builders/react/buildChildren.js\");\nvar _assertNode = require(\"./asserts/assertNode.js\");\nvar _index = require(\"./asserts/generated/index.js\");\nObject.keys(_index).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index[key];\n    }\n  });\n});\nvar _createTypeAnnotationBasedOnTypeof = require(\"./builders/flow/createTypeAnnotationBasedOnTypeof.js\");\nvar _createFlowUnionType = require(\"./builders/flow/createFlowUnionType.js\");\nvar _createTSUnionType = require(\"./builders/typescript/createTSUnionType.js\");\nvar _productions = require(\"./builders/productions.js\");\nObject.keys(_productions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _productions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _productions[key];\n    }\n  });\n});\nvar _index2 = require(\"./builders/generated/index.js\");\nObject.keys(_index2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index2[key];\n    }\n  });\n});\nvar _cloneNode = require(\"./clone/cloneNode.js\");\nvar _clone = require(\"./clone/clone.js\");\nvar _cloneDeep = require(\"./clone/cloneDeep.js\");\nvar _cloneDeepWithoutLoc = require(\"./clone/cloneDeepWithoutLoc.js\");\nvar _cloneWithoutLoc = require(\"./clone/cloneWithoutLoc.js\");\nvar _addComment = require(\"./comments/addComment.js\");\nvar _addComments = require(\"./comments/addComments.js\");\nvar _inheritInnerComments = require(\"./comments/inheritInnerComments.js\");\nvar _inheritLeadingComments = require(\"./comments/inheritLeadingComments.js\");\nvar _inheritsComments = require(\"./comments/inheritsComments.js\");\nvar _inheritTrailingComments = require(\"./comments/inheritTrailingComments.js\");\nvar _removeComments = require(\"./comments/removeComments.js\");\nvar _index3 = require(\"./constants/generated/index.js\");\nObject.keys(_index3).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index3[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index3[key];\n    }\n  });\n});\nvar _index4 = require(\"./constants/index.js\");\nObject.keys(_index4).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index4[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index4[key];\n    }\n  });\n});\nvar _ensureBlock = require(\"./converters/ensureBlock.js\");\nvar _toBindingIdentifierName = require(\"./converters/toBindingIdentifierName.js\");\nvar _toBlock = require(\"./converters/toBlock.js\");\nvar _toComputedKey = require(\"./converters/toComputedKey.js\");\nvar _toExpression = require(\"./converters/toExpression.js\");\nvar _toIdentifier = require(\"./converters/toIdentifier.js\");\nvar _toKeyAlias = require(\"./converters/toKeyAlias.js\");\nvar _toStatement = require(\"./converters/toStatement.js\");\nvar _valueToNode = require(\"./converters/valueToNode.js\");\nvar _index5 = require(\"./definitions/index.js\");\nObject.keys(_index5).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index5[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index5[key];\n    }\n  });\n});\nvar _appendToMemberExpression = require(\"./modifications/appendToMemberExpression.js\");\nvar _inherits = require(\"./modifications/inherits.js\");\nvar _prependToMemberExpression = require(\"./modifications/prependToMemberExpression.js\");\nvar _removeProperties = require(\"./modifications/removeProperties.js\");\nvar _removePropertiesDeep = require(\"./modifications/removePropertiesDeep.js\");\nvar _removeTypeDuplicates = require(\"./modifications/flow/removeTypeDuplicates.js\");\nvar _getAssignmentIdentifiers = require(\"./retrievers/getAssignmentIdentifiers.js\");\nvar _getBindingIdentifiers = require(\"./retrievers/getBindingIdentifiers.js\");\nvar _getOuterBindingIdentifiers = require(\"./retrievers/getOuterBindingIdentifiers.js\");\nvar _getFunctionName = require(\"./retrievers/getFunctionName.js\");\nvar _traverse = require(\"./traverse/traverse.js\");\nObject.keys(_traverse).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _traverse[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _traverse[key];\n    }\n  });\n});\nvar _traverseFast = require(\"./traverse/traverseFast.js\");\nvar _shallowEqual = require(\"./utils/shallowEqual.js\");\nvar _is = require(\"./validators/is.js\");\nvar _isBinding = require(\"./validators/isBinding.js\");\nvar _isBlockScoped = require(\"./validators/isBlockScoped.js\");\nvar _isImmutable = require(\"./validators/isImmutable.js\");\nvar _isLet = require(\"./validators/isLet.js\");\nvar _isNode = require(\"./validators/isNode.js\");\nvar _isNodesEquivalent = require(\"./validators/isNodesEquivalent.js\");\nvar _isPlaceholderType = require(\"./validators/isPlaceholderType.js\");\nvar _isReferenced = require(\"./validators/isReferenced.js\");\nvar _isScope = require(\"./validators/isScope.js\");\nvar _isSpecifierDefault = require(\"./validators/isSpecifierDefault.js\");\nvar _isType = require(\"./validators/isType.js\");\nvar _isValidES3Identifier = require(\"./validators/isValidES3Identifier.js\");\nvar _isValidIdentifier = require(\"./validators/isValidIdentifier.js\");\nvar _isVar = require(\"./validators/isVar.js\");\nvar _matchesPattern = require(\"./validators/matchesPattern.js\");\nvar _validate = require(\"./validators/validate.js\");\nvar _buildMatchMemberExpression = require(\"./validators/buildMatchMemberExpression.js\");\nvar _index6 = require(\"./validators/generated/index.js\");\nObject.keys(_index6).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index6[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index6[key];\n    }\n  });\n});\nvar _deprecationWarning = require(\"./utils/deprecationWarning.js\");\nvar _toSequenceExpression = require(\"./converters/toSequenceExpression.js\");\nconst react = exports.react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\nexports.toSequenceExpression = _toSequenceExpression.default;\nif (process.env.BABEL_TYPES_8_BREAKING) {\n  console.warn(\"BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!\");\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _buildMatchMemberExpression = require(\"../buildMatchMemberExpression.js\");\nconst isReactComponent = (0, _buildMatchMemberExpression.default)(\"React.Component\");\nvar _default = exports.default = isReactComponent;\n\n//# sourceMappingURL=isReactComponent.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildMatchMemberExpression;\nvar _matchesPattern = require(\"./matchesPattern.js\");\nfunction buildMatchMemberExpression(match, allowPartial) {\n  const parts = match.split(\".\");\n  return member => (0, _matchesPattern.default)(member, parts, allowPartial);\n}\n\n//# sourceMappingURL=buildMatchMemberExpression.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = matchesPattern;\nvar _index = require(\"./generated/index.js\");\nfunction isMemberExpressionLike(node) {\n  return (0, _index.isMemberExpression)(node) || (0, _index.isMetaProperty)(node);\n}\nfunction matchesPattern(member, match, allowPartial) {\n  if (!isMemberExpressionLike(member)) return false;\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n  let node;\n  for (node = member; isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {\n    var _object;\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if ((0, _index.isIdentifier)(node)) {\n      value = node.name;\n    } else if ((0, _index.isStringLiteral)(node)) {\n      value = node.value;\n    } else if ((0, _index.isThisExpression)(node)) {\n      value = \"this\";\n    } else if ((0, _index.isSuper)(node)) {\n      value = \"super\";\n    } else if ((0, _index.isPrivateName)(node)) {\n      value = \"#\" + node.id.name;\n    } else {\n      return false;\n    }\n    if (parts[i] !== value) return false;\n  }\n  return true;\n}\n\n//# sourceMappingURL=matchesPattern.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isAccessor = isAccessor;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isArrayExpression = isArrayExpression;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isBinary = isBinary;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isBindExpression = isBindExpression;\nexports.isBlock = isBlock;\nexports.isBlockParent = isBlockParent;\nexports.isBlockStatement = isBlockStatement;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isClass = isClass;\nexports.isClassAccessorProperty = isClassAccessorProperty;\nexports.isClassBody = isClassBody;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isClassExpression = isClassExpression;\nexports.isClassImplements = isClassImplements;\nexports.isClassMethod = isClassMethod;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassProperty = isClassProperty;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isDeclaration = isDeclaration;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isDecorator = isDecorator;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isDoExpression = isDoExpression;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isEnumBody = isEnumBody;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isEnumMember = isEnumMember;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isExpression = isExpression;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFile = isFile;\nexports.isFlow = isFlow;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isFlowType = isFlowType;\nexports.isFor = isFor;\nexports.isForInStatement = isForInStatement;\nexports.isForOfStatement = isForOfStatement;\nexports.isForStatement = isForStatement;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isFunctionParameter = isFunctionParameter;\nexports.isFunctionParent = isFunctionParent;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isImmutable = isImmutable;\nexports.isImport = isImport;\nexports.isImportAttribute = isImportAttribute;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportExpression = isImportExpression;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportOrExportDeclaration = isImportOrExportDeclaration;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isIndexedAccessType = isIndexedAccessType;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isJSX = isJSX;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXText = isJSXText;\nexports.isLVal = isLVal;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isLiteral = isLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isLoop = isLoop;\nexports.isMemberExpression = isMemberExpression;\nexports.isMetaProperty = isMetaProperty;\nexports.isMethod = isMethod;\nexports.isMiscellaneous = isMiscellaneous;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isModuleExpression = isModuleExpression;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isNewExpression = isNewExpression;\nexports.isNoop = isNoop;\nexports.isNullLiteral = isNullLiteral;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMember = isObjectMember;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isObjectProperty = isObjectProperty;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isPattern = isPattern;\nexports.isPatternLike = isPatternLike;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPlaceholder = isPlaceholder;\nexports.isPrivate = isPrivate;\nexports.isPrivateName = isPrivateName;\nexports.isProgram = isProgram;\nexports.isProperty = isProperty;\nexports.isPureish = isPureish;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isRecordExpression = isRecordExpression;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestElement = isRestElement;\nexports.isRestProperty = isRestProperty;\nexports.isReturnStatement = isReturnStatement;\nexports.isScopable = isScopable;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isSpreadElement = isSpreadElement;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStandardized = isStandardized;\nexports.isStatement = isStatement;\nexports.isStaticBlock = isStaticBlock;\nexports.isStringLiteral = isStringLiteral;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSuper = isSuper;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSBaseType = isTSBaseType;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSEntityName = isTSEntityName;\nexports.isTSEnumBody = isTSEnumBody;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSImportType = isTSImportType;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSInferType = isTSInferType;\nexports.isTSInstantiationExpression = isTSInstantiationExpression;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSRestType = isTSRestType;\nexports.isTSSatisfiesExpression = isTSSatisfiesExpression;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSTemplateLiteralType = isTSTemplateLiteralType;\nexports.isTSThisType = isTSThisType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSType = isTSType;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isTerminatorless = isTerminatorless;\nexports.isThisExpression = isThisExpression;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isThrowStatement = isThrowStatement;\nexports.isTopicReference = isTopicReference;\nexports.isTryStatement = isTryStatement;\nexports.isTupleExpression = isTupleExpression;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isTypeScript = isTypeScript;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUnaryLike = isUnaryLike;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isVariance = isVariance;\nexports.isVoidPattern = isVoidPattern;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isWhile = isWhile;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isYieldExpression = isYieldExpression;\nvar _shallowEqual = require(\"../../utils/shallowEqual.js\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning.js\");\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AssignmentExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BinaryExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterpreterDirective\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Directive\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DirectiveLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BlockStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BreakStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"CallExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"CatchClause\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ConditionalExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ContinueStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DebuggerStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DoWhileStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EmptyStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExpressionStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFile(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"File\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForInStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Identifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IfStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"LabeledStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumericLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RegExpLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"LogicalExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NewExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Program\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RestElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ReturnStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SequenceExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ParenthesizedExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SwitchCase\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SwitchStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThisExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThrowStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TryStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UnaryExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UpdateExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VariableDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VariableDeclarator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"WhileStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"WithStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AssignmentPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportAllDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ForOfStatement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MetaProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SpreadElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Super\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TemplateElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TemplateLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"YieldExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AwaitExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImport(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Import\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BigIntLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalMemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalCallExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassAccessorProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassAccessorProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassPrivateProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassPrivateMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PrivateName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StaticBlock\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ImportAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ClassImplements\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareClass\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareInterface\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareModule\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareModuleExports\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareTypeAlias\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareOpaqueType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareVariable\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DeclaredPredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"FunctionTypeParam\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InferredPredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceExtends\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OpaqueType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"StringTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeAlias\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeCastExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameter\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Variance\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumBooleanBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumNumberBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumStringBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumSymbolBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumBooleanMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumNumberMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumStringMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"EnumDefaultedMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"IndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXClosingElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXEmptyExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXExpressionContainer\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXSpreadChild\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXMemberExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXNamespacedName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXOpeningElement\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXText\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXOpeningFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"JSXClosingFragment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Noop\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Placeholder\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"BindExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"Decorator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DoExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"RecordExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TupleExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"DecimalLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"ModuleExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TopicReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelineTopicExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelineBareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"PipelinePrimaryTopicReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVoidPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"VoidPattern\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSParameterProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSDeclareFunction\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSDeclareMethod\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSQualifiedName\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSPropertySignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSMethodSignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIndexSignature\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSAnyKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSBooleanKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSBigIntKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNeverKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNullKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNumberKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSObjectKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSStringKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSSymbolKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUnknownKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSVoidKeyword\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSThisType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSFunctionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConstructorType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypePredicate\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeQuery\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSArrayType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTupleType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSOptionalType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSRestType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNamedTupleMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSUnionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIntersectionType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSConditionalType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInferType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSParenthesizedType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeOperator\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSIndexedAccessType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSMappedType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTemplateLiteralType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTemplateLiteralType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSLiteralType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExpressionWithTypeArguments\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInterfaceBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInstantiationExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSInstantiationExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSAsExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSatisfiesExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAssertion\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumBody\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSEnumMember\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSModuleDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSModuleBlock\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSImportType\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExternalModuleReference\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNonNullExpression\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSExportAssignment\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeAnnotation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== \"TSTypeParameter\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStandardized(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n    case \"ImportAttribute\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"RecordExpression\":\n    case \"TupleExpression\":\n    case \"DecimalLiteral\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"PipelineTopicExpression\":\n    case \"PipelineBareFunction\":\n    case \"PipelinePrimaryTopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionParameter(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSParameterProperty\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Identifier\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClass(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportOrExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAccessor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMiscellaneous(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"Noop\":\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeScript(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumBody\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n  if (node.type !== \"NumberLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n  if (node.type !== \"RegexLiteral\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n  if (node.type !== \"RestProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n  if (node.type !== \"SpreadProperty\") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = shallowEqual;\nfunction shallowEqual(actual, expected) {\n  const keys = Object.keys(expected);\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=shallowEqual.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deprecationWarning;\nconst warnings = new Set();\nfunction deprecationWarning(oldName, newName, prefix = \"\", cacheKey = oldName) {\n  if (warnings.has(cacheKey)) return;\n  warnings.add(cacheKey);\n  const {\n    internal,\n    trace\n  } = captureShortStackTrace(1, 2);\n  if (internal) {\n    return;\n  }\n  console.warn(`${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`);\n}\nfunction captureShortStackTrace(skip, length) {\n  const {\n    stackTraceLimit,\n    prepareStackTrace\n  } = Error;\n  let stackTrace;\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n  if (!stackTrace) return {\n    internal: false,\n    trace: \"\"\n  };\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()),\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join(\"\\n\")\n  };\n}\n\n//# sourceMappingURL=deprecationWarning.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isCompatTag;\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n\n//# sourceMappingURL=isCompatTag.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildChildren;\nvar _index = require(\"../../validators/generated/index.js\");\nvar _cleanJSXElementLiteralChild = require(\"../../utils/react/cleanJSXElementLiteralChild.js\");\nfunction buildChildren(node) {\n  const elements = [];\n  for (let i = 0; i < node.children.length; i++) {\n    let child = node.children[i];\n    if ((0, _index.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n    if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _index.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n  return elements;\n}\n\n//# sourceMappingURL=buildChildren.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cleanJSXElementLiteralChild;\nvar _index = require(\"../../builders/generated/index.js\");\nvar _index2 = require(\"../../index.js\");\nfunction cleanJSXElementLiteralChild(child, args) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n  let lastNonEmptyLine = 0;\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n  let str = \"\";\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n    let trimmedLine = line.replace(/\\t/g, \" \");\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, \"\");\n    }\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, \"\");\n    }\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n      str += trimmedLine;\n    }\n  }\n  if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));\n}\n\n//# sourceMappingURL=cleanJSXElementLiteralChild.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _lowercase = require(\"./lowercase.js\");\nObject.keys(_lowercase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _lowercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _lowercase[key];\n    }\n  });\n});\nvar _uppercase = require(\"./uppercase.js\");\nObject.keys(_uppercase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _uppercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _uppercase[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.arrayExpression = arrayExpression;\nexports.arrayPattern = arrayPattern;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.assignmentPattern = assignmentPattern;\nexports.awaitExpression = awaitExpression;\nexports.bigIntLiteral = bigIntLiteral;\nexports.binaryExpression = binaryExpression;\nexports.bindExpression = bindExpression;\nexports.blockStatement = blockStatement;\nexports.booleanLiteral = booleanLiteral;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.classAccessorProperty = classAccessorProperty;\nexports.classBody = classBody;\nexports.classDeclaration = classDeclaration;\nexports.classExpression = classExpression;\nexports.classImplements = classImplements;\nexports.classMethod = classMethod;\nexports.classPrivateMethod = classPrivateMethod;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classProperty = classProperty;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.decimalLiteral = decimalLiteral;\nexports.declareClass = declareClass;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareVariable = declareVariable;\nexports.declaredPredicate = declaredPredicate;\nexports.decorator = decorator;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.doExpression = doExpression;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumDeclaration = enumDeclaration;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.enumNumberBody = enumNumberBody;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringBody = enumStringBody;\nexports.enumStringMember = enumStringMember;\nexports.enumSymbolBody = enumSymbolBody;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.exportSpecifier = exportSpecifier;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forOfStatement = forOfStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.import = _import;\nexports.importAttribute = importAttribute;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importExpression = importExpression;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.indexedAccessType = indexedAccessType;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.interpreterDirective = interpreterDirective;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXText = exports.jsxText = jsxText;\nexports.labeledStatement = labeledStatement;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.metaProperty = metaProperty;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.moduleExpression = moduleExpression;\nexports.newExpression = newExpression;\nexports.noop = noop;\nexports.nullLiteral = nullLiteral;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteral = NumberLiteral;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.numericLiteral = numericLiteral;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectPattern = objectPattern;\nexports.objectProperty = objectProperty;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.optionalCallExpression = optionalCallExpression;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.placeholder = placeholder;\nexports.privateName = privateName;\nexports.program = program;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.recordExpression = recordExpression;\nexports.regExpLiteral = regExpLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restElement = restElement;\nexports.restProperty = RestProperty;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.spreadElement = spreadElement;\nexports.spreadProperty = SpreadProperty;\nexports.staticBlock = staticBlock;\nexports.stringLiteral = stringLiteral;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.super = _super;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.thisExpression = thisExpression;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.throwStatement = throwStatement;\nexports.topicReference = topicReference;\nexports.tryStatement = tryStatement;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSEnumBody = exports.tsEnumBody = tsEnumBody;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tupleExpression = tupleExpression;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.unaryExpression = unaryExpression;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.updateExpression = updateExpression;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.variance = variance;\nexports.voidPattern = voidPattern;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.yieldExpression = yieldExpression;\nvar _validate = require(\"../../validators/validate.js\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning.js\");\nvar utils = require(\"../../definitions/utils.js\");\nconst {\n  validateInternal: validate\n} = _validate;\nconst {\n  NODE_FIELDS\n} = utils;\nfunction bigIntLiteral(value) {\n  if (typeof value === \"bigint\") {\n    value = value.toString();\n  }\n  const node = {\n    type: \"BigIntLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction arrayExpression(elements = []) {\n  const node = {\n    type: \"ArrayExpression\",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction assignmentExpression(operator, left, right) {\n  const node = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction binaryExpression(operator, left, right) {\n  const node = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction interpreterDirective(value) {\n  const node = {\n    type: \"InterpreterDirective\",\n    value\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction directive(value) {\n  const node = {\n    type: \"Directive\",\n    value\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction directiveLiteral(value) {\n  const node = {\n    type: \"DirectiveLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction blockStatement(body, directives = []) {\n  const node = {\n    type: \"BlockStatement\",\n    body,\n    directives\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nfunction breakStatement(label = null) {\n  const node = {\n    type: \"BreakStatement\",\n    label\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nfunction callExpression(callee, _arguments) {\n  const node = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nfunction catchClause(param = null, body) {\n  const node = {\n    type: \"CatchClause\",\n    param,\n    body\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction conditionalExpression(test, consequent, alternate) {\n  const node = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nfunction continueStatement(label = null) {\n  const node = {\n    type: \"ContinueStatement\",\n    label\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nfunction debuggerStatement() {\n  return {\n    type: \"DebuggerStatement\"\n  };\n}\nfunction doWhileStatement(test, body) {\n  const node = {\n    type: \"DoWhileStatement\",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction emptyStatement() {\n  return {\n    type: \"EmptyStatement\"\n  };\n}\nfunction expressionStatement(expression) {\n  const node = {\n    type: \"ExpressionStatement\",\n    expression\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction file(program, comments = null, tokens = null) {\n  const node = {\n    type: \"File\",\n    program,\n    comments,\n    tokens\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nfunction forInStatement(left, right, body) {\n  const node = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction forStatement(init = null, test = null, update = null, body) {\n  const node = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction functionDeclaration(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction functionExpression(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction identifier(name) {\n  const node = {\n    type: \"Identifier\",\n    name\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction ifStatement(test, consequent, alternate = null) {\n  const node = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nfunction labeledStatement(label, body) {\n  const node = {\n    type: \"LabeledStatement\",\n    label,\n    body\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction stringLiteral(value) {\n  const node = {\n    type: \"StringLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction numericLiteral(value) {\n  const node = {\n    type: \"NumericLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction nullLiteral() {\n  return {\n    type: \"NullLiteral\"\n  };\n}\nfunction booleanLiteral(value) {\n  const node = {\n    type: \"BooleanLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction regExpLiteral(pattern, flags = \"\") {\n  const node = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nfunction logicalExpression(operator, left, right) {\n  const node = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction memberExpression(object, property, computed = false, optional = null) {\n  const node = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction newExpression(callee, _arguments) {\n  const node = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nfunction program(body, directives = [], sourceType = \"script\", interpreter = null) {\n  const node = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nfunction objectExpression(properties) {\n  const node = {\n    type: \"ObjectExpression\",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction objectMethod(kind = \"method\", key, params, body, computed = false, generator = false, async = false) {\n  const node = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction objectProperty(key, value, computed = false, shorthand = false, decorators = null) {\n  const node = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators\n  };\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction restElement(argument) {\n  const node = {\n    type: \"RestElement\",\n    argument\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction returnStatement(argument = null) {\n  const node = {\n    type: \"ReturnStatement\",\n    argument\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction sequenceExpression(expressions) {\n  const node = {\n    type: \"SequenceExpression\",\n    expressions\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nfunction parenthesizedExpression(expression) {\n  const node = {\n    type: \"ParenthesizedExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction switchCase(test = null, consequent) {\n  const node = {\n    type: \"SwitchCase\",\n    test,\n    consequent\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nfunction switchStatement(discriminant, cases) {\n  const node = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nfunction thisExpression() {\n  return {\n    type: \"ThisExpression\"\n  };\n}\nfunction throwStatement(argument) {\n  const node = {\n    type: \"ThrowStatement\",\n    argument\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction tryStatement(block, handler = null, finalizer = null) {\n  const node = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nfunction unaryExpression(operator, argument, prefix = true) {\n  const node = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nfunction updateExpression(operator, argument, prefix = false) {\n  const node = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nfunction variableDeclaration(kind, declarations) {\n  const node = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nfunction variableDeclarator(id, init = null) {\n  const node = {\n    type: \"VariableDeclarator\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction whileStatement(test, body) {\n  const node = {\n    type: \"WhileStatement\",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction withStatement(object, body) {\n  const node = {\n    type: \"WithStatement\",\n    object,\n    body\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction assignmentPattern(left, right) {\n  const node = {\n    type: \"AssignmentPattern\",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction arrayPattern(elements) {\n  const node = {\n    type: \"ArrayPattern\",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction arrowFunctionExpression(params, body, async = false) {\n  const node = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction classBody(body) {\n  const node = {\n    type: \"ClassBody\",\n    body\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction classExpression(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction classDeclaration(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nfunction exportAllDeclaration(source) {\n  const node = {\n    type: \"ExportAllDeclaration\",\n    source\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction exportDefaultDeclaration(declaration) {\n  const node = {\n    type: \"ExportDefaultDeclaration\",\n    declaration\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nfunction exportNamedDeclaration(declaration = null, specifiers = [], source = null) {\n  const node = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction exportSpecifier(local, exported) {\n  const node = {\n    type: \"ExportSpecifier\",\n    local,\n    exported\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction forOfStatement(left, right, body, _await = false) {\n  const node = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nfunction importDeclaration(specifiers, source) {\n  const node = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nfunction importDefaultSpecifier(local) {\n  const node = {\n    type: \"ImportDefaultSpecifier\",\n    local\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nfunction importNamespaceSpecifier(local) {\n  const node = {\n    type: \"ImportNamespaceSpecifier\",\n    local\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nfunction importSpecifier(local, imported) {\n  const node = {\n    type: \"ImportSpecifier\",\n    local,\n    imported\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nfunction importExpression(source, options = null) {\n  const node = {\n    type: \"ImportExpression\",\n    source,\n    options\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nfunction metaProperty(meta, property) {\n  const node = {\n    type: \"MetaProperty\",\n    meta,\n    property\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nfunction classMethod(kind = \"method\", key, params, body, computed = false, _static = false, generator = false, async = false) {\n  const node = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction objectPattern(properties) {\n  const node = {\n    type: \"ObjectPattern\",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction spreadElement(argument) {\n  const node = {\n    type: \"SpreadElement\",\n    argument\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super() {\n  return {\n    type: \"Super\"\n  };\n}\nfunction taggedTemplateExpression(tag, quasi) {\n  const node = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nfunction templateElement(value, tail = false) {\n  const node = {\n    type: \"TemplateElement\",\n    value,\n    tail\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nfunction templateLiteral(quasis, expressions) {\n  const node = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nfunction yieldExpression(argument = null, delegate = false) {\n  const node = {\n    type: \"YieldExpression\",\n    argument,\n    delegate\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nfunction awaitExpression(argument) {\n  const node = {\n    type: \"AwaitExpression\",\n    argument\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import() {\n  return {\n    type: \"Import\"\n  };\n}\nfunction exportNamespaceSpecifier(exported) {\n  const node = {\n    type: \"ExportNamespaceSpecifier\",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction optionalMemberExpression(object, property, computed = false, optional) {\n  const node = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n  const node = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classPrivateProperty(key, value = null, decorators = null, _static = false) {\n  const node = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction classPrivateMethod(kind = \"method\", key, params, body, _static = false) {\n  const node = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nfunction privateName(id) {\n  const node = {\n    type: \"PrivateName\",\n    id\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction staticBlock(body) {\n  const node = {\n    type: \"StaticBlock\",\n    body\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction importAttribute(key, value) {\n  const node = {\n    type: \"ImportAttribute\",\n    key,\n    value\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction anyTypeAnnotation() {\n  return {\n    type: \"AnyTypeAnnotation\"\n  };\n}\nfunction arrayTypeAnnotation(elementType) {\n  const node = {\n    type: \"ArrayTypeAnnotation\",\n    elementType\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nfunction booleanTypeAnnotation() {\n  return {\n    type: \"BooleanTypeAnnotation\"\n  };\n}\nfunction booleanLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction nullLiteralTypeAnnotation() {\n  return {\n    type: \"NullLiteralTypeAnnotation\"\n  };\n}\nfunction classImplements(id, typeParameters = null) {\n  const node = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction declareClass(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction declareFunction(id) {\n  const node = {\n    type: \"DeclareFunction\",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction declareInterface(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction declareModule(id, body, kind = null) {\n  const node = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nfunction declareModuleExports(typeAnnotation) {\n  const node = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction declareTypeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction declareOpaqueType(id, typeParameters = null, supertype = null) {\n  const node = {\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  return node;\n}\nfunction declareVariable(id) {\n  const node = {\n    type: \"DeclareVariable\",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {\n  const node = {\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nfunction declareExportAllDeclaration(source, attributes = null) {\n  const node = {\n    type: \"DeclareExportAllDeclaration\",\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nfunction declaredPredicate(value) {\n  const node = {\n    type: \"DeclaredPredicate\",\n    value\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction existsTypeAnnotation() {\n  return {\n    type: \"ExistsTypeAnnotation\"\n  };\n}\nfunction functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {\n  const node = {\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.rest, node, \"rest\", rest, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction functionTypeParam(name = null, typeAnnotation) {\n  const node = {\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction genericTypeAnnotation(id, typeParameters = null) {\n  const node = {\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction inferredPredicate() {\n  return {\n    type: \"InferredPredicate\"\n  };\n}\nfunction interfaceExtends(id, typeParameters = null) {\n  const node = {\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction interfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction interfaceTypeAnnotation(_extends = null, body) {\n  const node = {\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction intersectionTypeAnnotation(types) {\n  const node = {\n    type: \"IntersectionTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction mixedTypeAnnotation() {\n  return {\n    type: \"MixedTypeAnnotation\"\n  };\n}\nfunction emptyTypeAnnotation() {\n  return {\n    type: \"EmptyTypeAnnotation\"\n  };\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction numberLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"NumberLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction numberTypeAnnotation() {\n  return {\n    type: \"NumberTypeAnnotation\"\n  };\n}\nfunction objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {\n  const node = {\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  validate(defs.indexers, node, \"indexers\", indexers, 1);\n  validate(defs.callProperties, node, \"callProperties\", callProperties, 1);\n  validate(defs.internalSlots, node, \"internalSlots\", internalSlots, 1);\n  validate(defs.exact, node, \"exact\", exact);\n  return node;\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  const node = {\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.method, node, \"method\", method);\n  return node;\n}\nfunction objectTypeCallProperty(value) {\n  const node = {\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction objectTypeIndexer(id = null, key, value, variance = null) {\n  const node = {\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction objectTypeProperty(key, value, variance = null) {\n  const node = {\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction objectTypeSpreadProperty(argument) {\n  const node = {\n    type: \"ObjectTypeSpreadProperty\",\n    argument\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction opaqueType(id, typeParameters = null, supertype = null, impltype) {\n  const node = {\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  validate(defs.impltype, node, \"impltype\", impltype, 1);\n  return node;\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n  const node = {\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.qualification, node, \"qualification\", qualification, 1);\n  return node;\n}\nfunction stringLiteralTypeAnnotation(value) {\n  const node = {\n    type: \"StringLiteralTypeAnnotation\",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction stringTypeAnnotation() {\n  return {\n    type: \"StringTypeAnnotation\"\n  };\n}\nfunction symbolTypeAnnotation() {\n  return {\n    type: \"SymbolTypeAnnotation\"\n  };\n}\nfunction thisTypeAnnotation() {\n  return {\n    type: \"ThisTypeAnnotation\"\n  };\n}\nfunction tupleTypeAnnotation(types) {\n  const node = {\n    type: \"TupleTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction typeofTypeAnnotation(argument) {\n  const node = {\n    type: \"TypeofTypeAnnotation\",\n    argument\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction typeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction typeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"TypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction typeParameter(bound = null, _default = null, variance = null) {\n  const node = {\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.bound, node, \"bound\", bound, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nfunction typeParameterDeclaration(params) {\n  const node = {\n    type: \"TypeParameterDeclaration\",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction typeParameterInstantiation(params) {\n  const node = {\n    type: \"TypeParameterInstantiation\",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction unionTypeAnnotation(types) {\n  const node = {\n    type: \"UnionTypeAnnotation\",\n    types\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction variance(kind) {\n  const node = {\n    type: \"Variance\",\n    kind\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nfunction voidTypeAnnotation() {\n  return {\n    type: \"VoidTypeAnnotation\"\n  };\n}\nfunction enumDeclaration(id, body) {\n  const node = {\n    type: \"EnumDeclaration\",\n    id,\n    body\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction enumBooleanBody(members) {\n  const node = {\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumNumberBody(members) {\n  const node = {\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumStringBody(members) {\n  const node = {\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumSymbolBody(members) {\n  const node = {\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction enumBooleanMember(id) {\n  const node = {\n    type: \"EnumBooleanMember\",\n    id,\n    init: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction enumNumberMember(id, init) {\n  const node = {\n    type: \"EnumNumberMember\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction enumStringMember(id, init) {\n  const node = {\n    type: \"EnumStringMember\",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nfunction enumDefaultedMember(id) {\n  const node = {\n    type: \"EnumDefaultedMember\",\n    id\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction indexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction jsxAttribute(name, value = null) {\n  const node = {\n    type: \"JSXAttribute\",\n    name,\n    value\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nfunction jsxClosingElement(name) {\n  const node = {\n    type: \"JSXClosingElement\",\n    name\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction jsxElement(openingElement, closingElement = null, children, selfClosing = null) {\n  const node = {\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, \"openingElement\", openingElement, 1);\n  validate(defs.closingElement, node, \"closingElement\", closingElement, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nfunction jsxEmptyExpression() {\n  return {\n    type: \"JSXEmptyExpression\"\n  };\n}\nfunction jsxExpressionContainer(expression) {\n  const node = {\n    type: \"JSXExpressionContainer\",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction jsxSpreadChild(expression) {\n  const node = {\n    type: \"JSXSpreadChild\",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction jsxIdentifier(name) {\n  const node = {\n    type: \"JSXIdentifier\",\n    name\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction jsxMemberExpression(object, property) {\n  const node = {\n    type: \"JSXMemberExpression\",\n    object,\n    property\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nfunction jsxNamespacedName(namespace, name) {\n  const node = {\n    type: \"JSXNamespacedName\",\n    namespace,\n    name\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, \"namespace\", namespace, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction jsxOpeningElement(name, attributes, selfClosing = false) {\n  const node = {\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nfunction jsxSpreadAttribute(argument) {\n  const node = {\n    type: \"JSXSpreadAttribute\",\n    argument\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction jsxText(value) {\n  const node = {\n    type: \"JSXText\",\n    value\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  const node = {\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, \"openingFragment\", openingFragment, 1);\n  validate(defs.closingFragment, node, \"closingFragment\", closingFragment, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nfunction jsxOpeningFragment() {\n  return {\n    type: \"JSXOpeningFragment\"\n  };\n}\nfunction jsxClosingFragment() {\n  return {\n    type: \"JSXClosingFragment\"\n  };\n}\nfunction noop() {\n  return {\n    type: \"Noop\"\n  };\n}\nfunction placeholder(expectedNode, name) {\n  const node = {\n    type: \"Placeholder\",\n    expectedNode,\n    name\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, \"expectedNode\", expectedNode);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nfunction v8IntrinsicIdentifier(name) {\n  const node = {\n    type: \"V8IntrinsicIdentifier\",\n    name\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction argumentPlaceholder() {\n  return {\n    type: \"ArgumentPlaceholder\"\n  };\n}\nfunction bindExpression(object, callee) {\n  const node = {\n    type: \"BindExpression\",\n    object,\n    callee\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nfunction decorator(expression) {\n  const node = {\n    type: \"Decorator\",\n    expression\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction doExpression(body, async = false) {\n  const node = {\n    type: \"DoExpression\",\n    body,\n    async\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nfunction exportDefaultSpecifier(exported) {\n  const node = {\n    type: \"ExportDefaultSpecifier\",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nfunction recordExpression(properties) {\n  const node = {\n    type: \"RecordExpression\",\n    properties\n  };\n  const defs = NODE_FIELDS.RecordExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nfunction tupleExpression(elements = []) {\n  const node = {\n    type: \"TupleExpression\",\n    elements\n  };\n  const defs = NODE_FIELDS.TupleExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nfunction decimalLiteral(value) {\n  const node = {\n    type: \"DecimalLiteral\",\n    value\n  };\n  const defs = NODE_FIELDS.DecimalLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nfunction moduleExpression(body) {\n  const node = {\n    type: \"ModuleExpression\",\n    body\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction topicReference() {\n  return {\n    type: \"TopicReference\"\n  };\n}\nfunction pipelineTopicExpression(expression) {\n  const node = {\n    type: \"PipelineTopicExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.PipelineTopicExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction pipelineBareFunction(callee) {\n  const node = {\n    type: \"PipelineBareFunction\",\n    callee\n  };\n  const defs = NODE_FIELDS.PipelineBareFunction;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nfunction pipelinePrimaryTopicReference() {\n  return {\n    type: \"PipelinePrimaryTopicReference\"\n  };\n}\nfunction voidPattern() {\n  return {\n    type: \"VoidPattern\"\n  };\n}\nfunction tsParameterProperty(parameter) {\n  const node = {\n    type: \"TSParameterProperty\",\n    parameter\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, \"parameter\", parameter, 1);\n  return node;\n}\nfunction tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nfunction tsQualifiedName(left, right) {\n  const node = {\n    type: \"TSQualifiedName\",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nfunction tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsPropertySignature(key, typeAnnotation = null) {\n  const node = {\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsIndexSignature(parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsAnyKeyword() {\n  return {\n    type: \"TSAnyKeyword\"\n  };\n}\nfunction tsBooleanKeyword() {\n  return {\n    type: \"TSBooleanKeyword\"\n  };\n}\nfunction tsBigIntKeyword() {\n  return {\n    type: \"TSBigIntKeyword\"\n  };\n}\nfunction tsIntrinsicKeyword() {\n  return {\n    type: \"TSIntrinsicKeyword\"\n  };\n}\nfunction tsNeverKeyword() {\n  return {\n    type: \"TSNeverKeyword\"\n  };\n}\nfunction tsNullKeyword() {\n  return {\n    type: \"TSNullKeyword\"\n  };\n}\nfunction tsNumberKeyword() {\n  return {\n    type: \"TSNumberKeyword\"\n  };\n}\nfunction tsObjectKeyword() {\n  return {\n    type: \"TSObjectKeyword\"\n  };\n}\nfunction tsStringKeyword() {\n  return {\n    type: \"TSStringKeyword\"\n  };\n}\nfunction tsSymbolKeyword() {\n  return {\n    type: \"TSSymbolKeyword\"\n  };\n}\nfunction tsUndefinedKeyword() {\n  return {\n    type: \"TSUndefinedKeyword\"\n  };\n}\nfunction tsUnknownKeyword() {\n  return {\n    type: \"TSUnknownKeyword\"\n  };\n}\nfunction tsVoidKeyword() {\n  return {\n    type: \"TSVoidKeyword\"\n  };\n}\nfunction tsThisType() {\n  return {\n    type: \"TSThisType\"\n  };\n}\nfunction tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSFunctionType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: \"TSConstructorType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeReference(typeName, typeParameters = null) {\n  const node = {\n    type: \"TSTypeReference\",\n    typeName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, \"typeName\", typeName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {\n  const node = {\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, \"parameterName\", parameterName, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.asserts, node, \"asserts\", asserts);\n  return node;\n}\nfunction tsTypeQuery(exprName, typeParameters = null) {\n  const node = {\n    type: \"TSTypeQuery\",\n    exprName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, \"exprName\", exprName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsTypeLiteral(members) {\n  const node = {\n    type: \"TSTypeLiteral\",\n    members\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsArrayType(elementType) {\n  const node = {\n    type: \"TSArrayType\",\n    elementType\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nfunction tsTupleType(elementTypes) {\n  const node = {\n    type: \"TSTupleType\",\n    elementTypes\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, \"elementTypes\", elementTypes, 1);\n  return node;\n}\nfunction tsOptionalType(typeAnnotation) {\n  const node = {\n    type: \"TSOptionalType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsRestType(typeAnnotation) {\n  const node = {\n    type: \"TSRestType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsNamedTupleMember(label, elementType, optional = false) {\n  const node = {\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nfunction tsUnionType(types) {\n  const node = {\n    type: \"TSUnionType\",\n    types\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsIntersectionType(types) {\n  const node = {\n    type: \"TSIntersectionType\",\n    types\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  const node = {\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, \"checkType\", checkType, 1);\n  validate(defs.extendsType, node, \"extendsType\", extendsType, 1);\n  validate(defs.trueType, node, \"trueType\", trueType, 1);\n  validate(defs.falseType, node, \"falseType\", falseType, 1);\n  return node;\n}\nfunction tsInferType(typeParameter) {\n  const node = {\n    type: \"TSInferType\",\n    typeParameter\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  return node;\n}\nfunction tsParenthesizedType(typeAnnotation) {\n  const node = {\n    type: \"TSParenthesizedType\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeOperator(typeAnnotation, operator = \"keyof\") {\n  const node = {\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.operator, node, \"operator\", operator);\n  return node;\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nfunction tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {\n  const node = {\n    type: \"TSMappedType\",\n    typeParameter,\n    typeAnnotation,\n    nameType\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.nameType, node, \"nameType\", nameType, 1);\n  return node;\n}\nfunction tsTemplateLiteralType(quasis, types) {\n  const node = {\n    type: \"TSTemplateLiteralType\",\n    quasis,\n    types\n  };\n  const defs = NODE_FIELDS.TSTemplateLiteralType;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nfunction tsLiteralType(literal) {\n  const node = {\n    type: \"TSLiteralType\",\n    literal\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, \"literal\", literal, 1);\n  return node;\n}\nfunction tsExpressionWithTypeArguments(expression, typeParameters = null) {\n  const node = {\n    type: \"TSExpressionWithTypeArguments\",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsInterfaceBody(body) {\n  const node = {\n    type: \"TSInterfaceBody\",\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {\n  const node = {\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsInstantiationExpression(expression, typeParameters = null) {\n  const node = {\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsSatisfiesExpression(expression, typeAnnotation) {\n  const node = {\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  const node = {\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsEnumBody(members) {\n  const node = {\n    type: \"TSEnumBody\",\n    members\n  };\n  const defs = NODE_FIELDS.TSEnumBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsEnumDeclaration(id, members) {\n  const node = {\n    type: \"TSEnumDeclaration\",\n    id,\n    members\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nfunction tsEnumMember(id, initializer = null) {\n  const node = {\n    type: \"TSEnumMember\",\n    id,\n    initializer\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.initializer, node, \"initializer\", initializer, 1);\n  return node;\n}\nfunction tsModuleDeclaration(id, body) {\n  const node = {\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsModuleBlock(body) {\n  const node = {\n    type: \"TSModuleBlock\",\n    body\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nfunction tsImportType(argument, qualifier = null, typeParameters = null) {\n  const node = {\n    type: \"TSImportType\",\n    argument,\n    qualifier,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.qualifier, node, \"qualifier\", qualifier, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  const node = {\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n    isExport: null\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.moduleReference, node, \"moduleReference\", moduleReference, 1);\n  return node;\n}\nfunction tsExternalModuleReference(expression) {\n  const node = {\n    type: \"TSExternalModuleReference\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsNonNullExpression(expression) {\n  const node = {\n    type: \"TSNonNullExpression\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsExportAssignment(expression) {\n  const node = {\n    type: \"TSExportAssignment\",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nfunction tsNamespaceExportDeclaration(id) {\n  const node = {\n    type: \"TSNamespaceExportDeclaration\",\n    id\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: \"TSTypeAnnotation\",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeParameterInstantiation(params) {\n  const node = {\n    type: \"TSTypeParameterInstantiation\",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction tsTypeParameterDeclaration(params) {\n  const node = {\n    type: \"TSTypeParameterDeclaration\",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nfunction tsTypeParameter(constraint = null, _default = null, name) {\n  const node = {\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nfunction NumberLiteral(value) {\n  (0, _deprecationWarning.default)(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nfunction RegexLiteral(pattern, flags = \"\") {\n  (0, _deprecationWarning.default)(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nfunction RestProperty(argument) {\n  (0, _deprecationWarning.default)(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nfunction SpreadProperty(argument) {\n  (0, _deprecationWarning.default)(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\n\n//# sourceMappingURL=lowercase.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = validate;\nexports.validateChild = validateChild;\nexports.validateField = validateField;\nexports.validateInternal = validateInternal;\nvar _index = require(\"../definitions/index.js\");\nfunction validate(node, key, val) {\n  if (!node) return;\n  const fields = _index.NODE_FIELDS[node.type];\n  if (!fields) return;\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\nfunction validateInternal(field, node, key, val, maybeNode) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n  if (maybeNode) {\n    var _NODE_PARENT_VALIDATI;\n    const type = val.type;\n    if (type == null) return;\n    (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n  }\n}\nfunction validateField(node, key, val, field) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}\nfunction validateChild(node, key, val) {\n  var _NODE_PARENT_VALIDATI2;\n  const type = val == null ? void 0 : val.type;\n  if (type == null) return;\n  (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n}\n\n//# sourceMappingURL=validate.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ALIAS_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"BUILDER_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.BUILDER_KEYS;\n  }\n});\nObject.defineProperty(exports, \"DEPRECATED_ALIASES\", {\n  enumerable: true,\n  get: function () {\n    return _deprecatedAliases.DEPRECATED_ALIASES;\n  }\n});\nObject.defineProperty(exports, \"DEPRECATED_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.DEPRECATED_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FLIPPED_ALIAS_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"NODE_FIELDS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_FIELDS;\n  }\n});\nObject.defineProperty(exports, \"NODE_PARENT_VALIDATIONS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_PARENT_VALIDATIONS;\n  }\n});\nObject.defineProperty(exports, \"NODE_UNION_SHAPES__PRIVATE\", {\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_UNION_SHAPES__PRIVATE;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS_ALIAS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_ALIAS;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS_FLIPPED_ALIAS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n  }\n});\nexports.TYPES = void 0;\nObject.defineProperty(exports, \"VISITOR_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.VISITOR_KEYS;\n  }\n});\nrequire(\"./core.js\");\nrequire(\"./flow.js\");\nrequire(\"./jsx.js\");\nrequire(\"./misc.js\");\nrequire(\"./experimental.js\");\nrequire(\"./typescript.js\");\nvar _utils = require(\"./utils.js\");\nvar _placeholders = require(\"./placeholders.js\");\nvar _deprecatedAliases = require(\"./deprecated-aliases.js\");\nObject.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(deprecatedAlias => {\n  _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];\n});\nfor (const {\n  types,\n  set\n} of _utils.allExpandedTypes) {\n  for (const type of types) {\n    const aliases = _utils.FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      aliases.forEach(set.add, set);\n    } else {\n      set.add(type);\n    }\n  }\n}\nconst TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyUnionShapeCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\nvar _is = require(\"../validators/is.js\");\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier.js\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _helperStringParser = require(\"@babel/helper-string-parser\");\nvar _index = require(\"../constants/index.js\");\nvar _utils = require(\"./utils.js\");\nconst classMethodOrPropertyUnionShapeCommon = (allowPrivateName = false) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        key: {\n          validate: allowPrivateName ? (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\") : (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\")\n        }\n      }\n    }]\n  }\n});\nexports.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\")),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"string\") : Object.assign(function () {\n        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }(), {\n        oneOf: _index.ASSIGNMENT_OPERATORS\n      })\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\", \"OptionalMemberExpression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"OptionalMemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.arrayOfType)(\"Directive\"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: (0, _utils.validateArrayOfType)(\"Expression\", \"SpreadElement\", \"ArgumentPlaceholder\"),\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, process.env.BABEL_TYPES_8_BREAKING ? {} : {\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = () => ({\n  params: (0, _utils.validateArrayOfType)(\"FunctionParameter\"),\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)(\"Decorator\"),\n    optional: true\n  }\n});\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"FunctionParameter\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      })) : (0, _utils.assertValueType)(\"string\")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {\n    const match = /\\.(\\w+)$/.exec(key.toString());\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  } : undefined\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"number\"), Object.assign(function (node, key, val) {\n        if (1 / val < 0 || !Number.isFinite(val)) {\n          const error = new Error(\"NumericLiterals must be non-negative finite numbers. \" + `You can use t.valueToNode(${val}) instead.`);\n        }\n      }, {\n        type: \"number\"\n      }))\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        const invalid = /[^dgimsuvy]/.exec(val);\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })) : (0, _utils.assertValueType)(\"string\"),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        property: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        property: {\n          validate: (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\")\n        }\n      }\n    }]\n  },\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.arrayOfType)(\"Directive\"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")\n  }\n});\ndefineType(\"ObjectMethod\", Object.assign({\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n}));\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [{\n      name: \"computed\",\n      value: [true],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Expression\")\n        }\n      }\n    }, {\n      name: \"nonComputed\",\n      value: [false],\n      properties: {\n        key: {\n          validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\")\n        }\n      }\n    }]\n  },\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, shorthand) {\n        if (!shorthand) return;\n        if (node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n        if (!(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }, {\n        type: \"boolean\"\n      })) : (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"FunctionParameter\", \"PatternLike\", \"LVal\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\", \"RestElement\", \"AssignmentPattern\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  } : undefined\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: (0, _utils.validateArrayOfType)(\"Expression\")\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: (0, _utils.validateArrayOfType)(\"SwitchCase\")\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      })) : (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\", \"using\", \"await using\")\n    },\n    declarations: (0, _utils.validateArrayOfType)(\"VariableDeclarator\")\n  },\n  validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {\n    const withoutInit = (0, _utils.assertNodeType)(\"Identifier\", \"Placeholder\");\n    const constOrLetOrVar = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"Placeholder\");\n    const usingOrAwaitUsing = (0, _utils.assertNodeType)(\"Identifier\", \"VoidPattern\", \"Placeholder\");\n    return function (parent, key, node) {\n      const {\n        kind,\n        declarations\n      } = node;\n      const parentIsForX = (0, _is.default)(\"ForXStatement\", parent, {\n        left: node\n      });\n      if (parentIsForX) {\n        if (declarations.length !== 1) {\n          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n        }\n      }\n      for (const decl of declarations) {\n        if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n          if (!parentIsForX && !decl.init) {\n            withoutInit(decl, \"id\", decl.id);\n          } else {\n            constOrLetOrVar(decl, \"id\", decl.id);\n          }\n        } else {\n          usingOrAwaitUsing(decl, \"id\", decl.id);\n        }\n      }\n    };\n  })() : undefined\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\", \"VoidPattern\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"VoidPattern\")\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"decorators\", \"id\", \"typeParameters\", \"superClass\", \"superTypeParameters\", \"mixins\", \"implements\", \"body\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    [\"superTypeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    [\"superTypeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\nconst importAttributes = exports.importAttributes = {\n  attributes: {\n    optional: true,\n    validate: (0, _utils.arrayOfType)(\"ImportAttribute\")\n  }\n};\nimportAttributes.assertions = {\n  deprecated: true,\n  optional: true,\n  validate: (0, _utils.arrayOfType)(\"ImportAttribute\")\n};\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: Object.assign({\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }, importAttributes)\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: (0, _utils.validateType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\", \"ExportDeclaration\"],\n  fields: Object.assign({\n    declaration: {\n      optional: true,\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      })) : (0, _utils.assertNodeType)(\"Declaration\")\n    }\n  }, importAttributes, {\n    specifiers: {\n      default: [],\n      validate: (0, _utils.arrayOf)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return Object.assign(function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\"]\n        });\n      }())\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  })\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return Object.assign(function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        }, {\n          oneOfNodeTypes: [\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\"]\n        });\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: Object.assign({}, importAttributes, {\n    module: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)(\"source\", \"defer\")\n    },\n    specifiers: (0, _utils.validateArrayOfType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\"),\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)(\"source\", \"defer\")\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    options: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        let property;\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n          case \"new\":\n            property = \"target\";\n            break;\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      })) : (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n  }\n});\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: (0, _utils.validateArrayOfType)(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)(\"Decorator\"),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", Object.assign({\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n}));\ndefineType(\"ObjectPattern\", {\n  visitor: [\"decorators\", \"properties\", \"typeAnnotation\"],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: (0, _utils.validateArrayOfType)(\"RestElement\", \"ObjectProperty\")\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"typeParameters\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    [\"typeParameters\"]: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let unterminatedCalled = false;\n        const error = () => {\n          throw new Error(\"Internal @babel/types error.\");\n        };\n        const {\n          str,\n          firstInvalidLoc\n        } = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n          unterminated() {\n            unterminatedCalled = true;\n          },\n          strictNumericEscape: error,\n          invalidEscapeSequence: error,\n          numericSeparatorInEscapeSequence: error,\n          unexpectedNumericSeparator: error,\n          invalidDigit: error,\n          invalidCodePoint: error\n        });\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = firstInvalidLoc ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: (0, _utils.validateArrayOfType)(\"TemplateElement\"),\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })) : (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: (0, _utils.validateArrayOfType)(\"Expression\", \"SpreadElement\", \"ArgumentPlaceholder\"),\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, {\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassProperty\", Object.assign({\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"]\n}, classMethodOrPropertyUnionShapeCommon(), {\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n}));\ndefineType(\"ClassAccessorProperty\", Object.assign({\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"]\n}, classMethodOrPropertyUnionShapeCommon(true), {\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n}));\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\", \"body\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      default: \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n//# sourceMappingURL=core.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = is;\nvar _shallowEqual = require(\"../utils/shallowEqual.js\");\nvar _isType = require(\"./isType.js\");\nvar _isPlaceholderType = require(\"./isPlaceholderType.js\");\nvar _index = require(\"../definitions/index.js\");\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in _index.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n    return false;\n  }\n  if (opts === undefined) {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}\n\n//# sourceMappingURL=is.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isType;\nvar _index = require(\"../definitions/index.js\");\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (nodeType == null) return false;\n  if (_index.ALIAS_KEYS[targetType]) return false;\n  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases != null && aliases.includes(nodeType)) return true;\n  return false;\n}\n\n//# sourceMappingURL=isType.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPlaceholderType;\nvar _index = require(\"../definitions/index.js\");\nfunction isPlaceholderType(placeholderType, targetType) {\n  if (placeholderType === targetType) return true;\n  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases != null && aliases.includes(targetType)) return true;\n  return false;\n}\n\n//# sourceMappingURL=isPlaceholderType.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidIdentifier;\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nfunction isValidIdentifier(name, reserved = true) {\n  if (typeof name !== \"string\") return false;\n  if (reserved) {\n    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {\n      return false;\n    }\n  }\n  return (0, _helperValidatorIdentifier.isIdentifierName)(name);\n}\n\n//# sourceMappingURL=isValidIdentifier.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;\nconst STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nconst FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nconst FOR_INIT_KEYS = exports.FOR_INIT_KEYS = [\"left\", \"init\"];\nconst COMMENT_KEYS = exports.COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\nconst LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nconst UPDATE_OPERATORS = exports.UPDATE_OPERATORS = [\"++\", \"--\"];\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nconst EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nconst COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, \"in\", \"instanceof\"];\nconst BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];\nconst NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nconst BINARY_OPERATORS = exports.BINARY_OPERATORS = [\"+\", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, \"|>\"];\nconst ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = [\"=\", \"+=\", ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"), ...LOGICAL_OPERATORS.map(op => op + \"=\")];\nconst BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nconst NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nconst STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = [\"typeof\"];\nconst UNARY_OPERATORS = exports.UNARY_OPERATORS = [\"void\", \"throw\", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];\nconst INHERIT_KEYS = exports.INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\nexports.BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nexports.NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_UNION_SHAPES__PRIVATE = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = require(\"../validators/is.js\");\nvar _validate = require(\"../validators/validate.js\");\nconst VISITOR_KEYS = exports.VISITOR_KEYS = {};\nconst ALIAS_KEYS = exports.ALIAS_KEYS = {};\nconst FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};\nconst NODE_FIELDS = exports.NODE_FIELDS = {};\nconst BUILDER_KEYS = exports.BUILDER_KEYS = {};\nconst DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};\nconst NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};\nconst NODE_UNION_SHAPES__PRIVATE = exports.NODE_UNION_SHAPES__PRIVATE = {};\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\nfunction validateType(...typeNames) {\n  return validate(assertNodeType(...typeNames));\n}\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(...typeNames) {\n  return {\n    validate: assertNodeType(...typeNames),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\nfunction arrayOfType(...typeNames) {\n  return arrayOf(assertNodeType(...typeNames));\n}\nfunction validateArrayOfType(...typeNames) {\n  return validate(arrayOfType(...typeNames));\n}\nfunction assertEach(callback) {\n  const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {};\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    let i = 0;\n    const subKey = {\n      toString() {\n        return `${key}[${i}]`;\n      }\n    };\n    for (; i < val.length; i++) {\n      const v = val[i];\n      callback(node, subKey, v);\n      childValidator(node, subKey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (!values.includes(val)) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nconst allExpandedTypes = exports.allExpandedTypes = [];\nfunction assertNodeType(...types) {\n  const expandedTypes = new Set();\n  allExpandedTypes.push({\n    types,\n    set: expandedTypes\n  });\n  function validate(node, key, val) {\n    const valType = val == null ? void 0 : val.type;\n    if (valType != null) {\n      if (expandedTypes.has(valType)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n      if (valType === \"Placeholder\") {\n        for (const type of types) {\n          if ((0, _is.default)(type, val)) {\n            (0, _validate.validateChild)(node, key, val);\n            return;\n          }\n        }\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(valType)}`);\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    const primitiveType = getType(val);\n    for (const type of types) {\n      if (primitiveType === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    if (getType(val) === type) {\n      return;\n    }\n    throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  const keys = Object.keys(shape);\n  function validate(node, key, val) {\n    const errors = [];\n    for (const property of keys) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    let current = node;\n    while (node) {\n      const {\n        type\n      } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n  return validate;\n}\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n  return validate;\n}\nconst validTypeOpts = new Set([\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\", \"unionShape\"]);\nconst validFieldKeys = new Set([\"default\", \"optional\", \"deprecated\", \"validate\"]);\nconst store = {};\nfunction defineAliasedType(...aliases) {\n  return (type, opts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      defined != null ? defined : defined = [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate\n        };\n      }\n    }\n  }\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n    if (field.default !== undefined && !builder.includes(key)) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  if (opts.unionShape) {\n    NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;\n  }\n  store[type] = opts;\n}\n\n//# sourceMappingURL=utils.js.map\n","\n\nvar _core = require(\"./core.js\");\nvar _utils = require(\"./utils.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"Flow\");\nconst defineInterfaceishType = name => {\n  const isDeclareClass = name === \"DeclareClass\";\n  defineType(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\"id\", \"typeParameters\", \"extends\", ...(isDeclareClass ? [\"mixins\", \"implements\"] : []), \"body\"],\n    aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: Object.assign({\n      id: (0, _utils.validateType)(\"Identifier\"),\n      typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\"))\n    }, isDeclareClass ? {\n      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ClassImplements\"))\n    } : {}, {\n      body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n    })\n  });\n};\ndefineType(\"AnyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"BooleanTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"DeclareClass\");\ndefineType(\"DeclareFunction\", {\n  builder: [\"id\"],\n  visitor: [\"id\", \"predicate\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    predicate: (0, _utils.validateOptionalType)(\"DeclaredPredicate\")\n  }\n});\ndefineInterfaceishType(\"DeclareInterface\");\ndefineType(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    body: (0, _utils.validateType)(\"BlockStatement\"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"CommonJS\", \"ES\"))\n  }\n});\ndefineType(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\ndefineType(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateOptionalType)(\"FlowType\")\n  }\n});\ndefineType(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: Object.assign({\n    declaration: (0, _utils.validateOptionalType)(\"Flow\"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ExportSpecifier\", \"ExportNamespaceSpecifier\")),\n    source: (0, _utils.validateOptionalType)(\"StringLiteral\"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }, _core.importAttributes)\n});\ndefineType(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: Object.assign({\n    source: (0, _utils.validateType)(\"StringLiteral\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }, _core.importAttributes)\n});\ndefineType(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"FlowPredicate\"],\n  fields: {\n    value: (0, _utils.validateType)(\"Flow\")\n  }\n});\ndefineType(\"ExistsTypeAnnotation\", {\n  aliases: [\"FlowType\"]\n});\ndefineType(\"FunctionTypeAnnotation\", {\n  builder: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  visitor: [\"typeParameters\", \"this\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    params: (0, _utils.validateArrayOfType)(\"FunctionTypeParam\"),\n    rest: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    this: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    returnType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  fields: {\n    name: (0, _utils.validateOptionalType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineType(\"InferredPredicate\", {\n  aliases: [\"FlowPredicate\"]\n});\ndefineType(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"InterfaceDeclaration\");\ndefineType(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\ndefineType(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"MixedTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"EmptyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"number\"))\n  }\n});\ndefineType(\"NumberTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"FlowType\"],\n  builder: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\", \"exact\"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)(\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\")),\n    indexers: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeIndexer\"),\n      optional: true,\n      default: []\n    },\n    callProperties: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeCallProperty\"),\n      optional: true,\n      default: []\n    },\n    internalSlots: {\n      validate: (0, _utils.arrayOfType)(\"ObjectTypeInternalSlot\"),\n      optional: true,\n      default: []\n    },\n    exact: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\"],\n  builder: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeIndexer\", {\n  visitor: [\"variance\", \"id\", \"key\", \"value\"],\n  builder: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateOptionalType)(\"Identifier\"),\n    key: (0, _utils.validateType)(\"FlowType\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\ndefineType(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    key: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"init\", \"get\", \"set\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    proto: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\"),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"QualifiedTypeIdentifier\", {\n  visitor: [\"qualification\", \"id\"],\n  builder: [\"id\", \"qualification\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    qualification: (0, _utils.validateType)(\"Identifier\", \"QualifiedTypeIdentifier\")\n  }\n});\ndefineType(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"string\"))\n  }\n});\ndefineType(\"StringTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"SymbolTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"ThisTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\ndefineType(\"TypeParameter\", {\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    bound: (0, _utils.validateOptionalType)(\"TypeAnnotation\"),\n    default: (0, _utils.validateOptionalType)(\"FlowType\"),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\ndefineType(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"TypeParameter\"))\n  }\n});\ndefineType(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\ndefineType(\"Variance\", {\n  builder: [\"kind\"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"minus\", \"plus\"))\n  }\n});\ndefineType(\"VoidTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"]\n});\ndefineType(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    body: (0, _utils.validateType)(\"EnumBooleanBody\", \"EnumNumberBody\", \"EnumStringBody\", \"EnumSymbolBody\")\n  }\n});\ndefineType(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumBooleanMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumNumberMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumStringMember\", \"EnumDefaultedMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"EnumDefaultedMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\ndefineType(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  builder: [\"id\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"BooleanLiteral\")\n  }\n});\ndefineType(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"NumericLiteral\")\n  }\n});\ndefineType(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\ndefineType(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n\n//# sourceMappingURL=flow.js.map\n","\n\nvar _utils = require(\"./utils.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"JSX\");\ndefineType(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXElement\", \"JSXFragment\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\ndefineType(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    }\n  }\n});\ndefineType(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: Object.assign({\n    openingElement: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: (0, _utils.validateArrayOfType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")\n  }, {\n    selfClosing: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"JSXEmptyExpression\", {});\ndefineType(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"JSXEmptyExpression\")\n    }\n  }\n});\ndefineType(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\ndefineType(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\ndefineType(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"typeParameters\", \"typeArguments\", \"attributes\"],\n  aliases: [\"Immutable\"],\n  fields: Object.assign({\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    },\n    selfClosing: {\n      default: false\n    },\n    attributes: (0, _utils.validateArrayOfType)(\"JSXAttribute\", \"JSXSpreadAttribute\"),\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    }\n  }, {\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"JSXText\", {\n  aliases: [\"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningFragment\")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXClosingFragment\")\n    },\n    children: (0, _utils.validateArrayOfType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")\n  }\n});\ndefineType(\"JSXOpeningFragment\", {\n  aliases: [\"Immutable\"]\n});\ndefineType(\"JSXClosingFragment\", {\n  aliases: [\"Immutable\"]\n});\n\n//# sourceMappingURL=jsx.js.map\n","\n\nvar _utils = require(\"./utils.js\");\nvar _placeholders = require(\"./placeholders.js\");\nvar _core = require(\"./core.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"Miscellaneous\");\ndefineType(\"Noop\", {\n  visitor: []\n});\ndefineType(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  fields: Object.assign({\n    name: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    expectedNode: {\n      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)\n    }\n  }, (0, _core.patternLikeCommon)())\n});\ndefineType(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n\n//# sourceMappingURL=misc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;\nvar _utils = require(\"./utils.js\");\nconst PLACEHOLDERS = exports.PLACEHOLDERS = [\"Identifier\", \"StringLiteral\", \"Expression\", \"Statement\", \"Declaration\", \"BlockStatement\", \"ClassBody\", \"Pattern\"];\nconst PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"]\n};\nfor (const type of PLACEHOLDERS) {\n  const alias = _utils.ALIAS_KEYS[type];\n  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\nconst PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n\n//# sourceMappingURL=placeholders.js.map\n","\n\nvar _utils = require(\"./utils.js\");\n(0, _utils.default)(\"ArgumentPlaceholder\", {});\n(0, _utils.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n    object: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    },\n    callee: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    }\n  } : {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    async: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"RecordExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)(\"ObjectProperty\", \"SpreadElement\")\n  }\n});\n(0, _utils.default)(\"TupleExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOfType)(\"Expression\", \"SpreadElement\"),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"DecimalLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TopicReference\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineTopicExpression\", {\n  builder: [\"expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineBareFunction\", {\n  builder: [\"callee\"],\n  visitor: [\"callee\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelinePrimaryTopicReference\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VoidPattern\", {\n  aliases: [\"Pattern\", \"PatternLike\", \"FunctionParameter\"]\n});\n\n//# sourceMappingURL=experimental.js.map\n","\n\nvar _utils = require(\"./utils.js\");\nvar _core = require(\"./core.js\");\nvar _is = require(\"../validators/is.js\");\nconst defineType = (0, _utils.defineAliasedType)(\"TypeScript\");\nconst bool = (0, _utils.assertValueType)(\"boolean\");\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)(\"Decorator\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType(\"TSDeclareMethod\", Object.assign({\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"]\n}, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {\n  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())\n}));\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nconst signatureDeclarationCommon = () => ({\n  typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n  [\"parameters\"]: (0, _utils.validateArrayOfType)(\"ArrayPattern\", \"Identifier\", \"ObjectPattern\", \"RestElement\"),\n  [\"typeAnnotation\"]: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n});\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon()\n};\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = () => ({\n  key: (0, _utils.validateType)(\"Expression\"),\n  computed: {\n    default: false\n  },\n  optional: (0, _utils.validateOptional)(bool)\n});\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: Object.assign({}, namedTypeElementCommon(), {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    kind: {\n      optional: true,\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }\n  })\n});\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nconst tsKeywordTypes = [\"TSAnyKeyword\", \"TSBooleanKeyword\", \"TSBigIntKeyword\", \"TSIntrinsicKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\"];\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {}\n  });\n}\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"]\n};\ndefineType(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon()\n}));\ndefineType(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon(), {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: (0, _utils.validateType)(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: (0, _utils.validateType)(\"TSEntityName\", \"TSImportType\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)(\"TSType\", \"TSNamedTupleMember\")\n  }\n});\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: (0, _utils.validateType)(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  builder: [\"typeAnnotation\", \"operator\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertValueType)(\"string\"),\n      default: \"keyof\"\n    },\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"nameType\", \"typeAnnotation\"],\n  builder: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: Object.assign({}, {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }, {\n    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, \"+\", \"-\")),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n    nameType: (0, _utils.validateOptionalType)(\"TSType\")\n  })\n});\ndefineType(\"TSTemplateLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"quasis\", \"types\"],\n  fields: {\n    quasis: (0, _utils.validateArrayOfType)(\"TemplateElement\"),\n    types: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: function () {\n        const unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n        const unaryOperator = (0, _utils.assertOneOf)(\"-\");\n        const literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\");\n        const validator = function validator(parent, key, node) {\n          if ((0, _is.default)(\"UnaryExpression\", node)) {\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        };\n        validator.oneOfNodeTypes = [\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"TemplateLiteral\", \"UnaryExpression\"];\n        return validator;\n      }()\n    }\n  }\n});\ndefineType(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\ndefineType(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    [\"typeParameters\"]: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n};\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSEnumBody\", {\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\")\n  }\n});\ndefineType(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n    body: (0, _utils.validateOptionalType)(\"TSEnumBody\")\n  }\n});\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: Object.assign({\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"global\", \"module\", \"namespace\")\n    },\n    declare: (0, _utils.validateOptional)(bool)\n  }, {\n    global: (0, _utils.validateOptional)(bool)\n  }, {\n    id: (0, _utils.validateType)(\"Identifier\", \"StringLiteral\"),\n    body: (0, _utils.validateType)(\"TSModuleBlock\", \"TSModuleDeclaration\")\n  })\n});\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  builder: [\"argument\", \"qualifier\", \"typeParameters\"],\n  visitor: [\"argument\", \"options\", \"qualifier\", \"typeParameters\"],\n  fields: Object.assign({}, {\n    argument: (0, _utils.validateType)(\"StringLiteral\")\n  }, {\n    qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\")\n  }, {\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }, {\n    options: {\n      validate: (0, _utils.assertNodeType)(\"ObjectExpression\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: Object.assign({}, {\n    isExport: (0, _utils.validate)(bool)\n  }, {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)(\"TSEntityName\", \"TSExternalModuleReference\"),\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n});\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)(\"TSTypeParameter\")\n  }\n});\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    in: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    out: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    const: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});\n\n//# sourceMappingURL=typescript.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEPRECATED_ALIASES = void 0;\nconst DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {\n  ModuleDeclaration: \"ImportOrExportDeclaration\"\n};\n\n//# sourceMappingURL=deprecated-aliases.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSXIdentifier = exports.JSXFragment = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = exports.JSXAttribute = exports.IntersectionTypeAnnotation = exports.InterpreterDirective = exports.InterfaceTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.InferredPredicate = exports.IndexedAccessType = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportExpression = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportAttribute = exports.Import = exports.IfStatement = exports.Identifier = exports.GenericTypeAnnotation = exports.FunctionTypeParam = exports.FunctionTypeAnnotation = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.File = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamespaceSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultSpecifier = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.ExistsTypeAnnotation = exports.EnumSymbolBody = exports.EnumStringMember = exports.EnumStringBody = exports.EnumNumberMember = exports.EnumNumberBody = exports.EnumDefaultedMember = exports.EnumDeclaration = exports.EnumBooleanMember = exports.EnumBooleanBody = exports.EmptyTypeAnnotation = exports.EmptyStatement = exports.DoWhileStatement = exports.DoExpression = exports.DirectiveLiteral = exports.Directive = exports.Decorator = exports.DeclaredPredicate = exports.DeclareVariable = exports.DeclareTypeAlias = exports.DeclareOpaqueType = exports.DeclareModuleExports = exports.DeclareModule = exports.DeclareInterface = exports.DeclareFunction = exports.DeclareExportDeclaration = exports.DeclareExportAllDeclaration = exports.DeclareClass = exports.DecimalLiteral = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassProperty = exports.ClassPrivateProperty = exports.ClassPrivateMethod = exports.ClassMethod = exports.ClassImplements = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ClassAccessorProperty = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BooleanTypeAnnotation = exports.BooleanLiteralTypeAnnotation = exports.BooleanLiteral = exports.BlockStatement = exports.BindExpression = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayTypeAnnotation = exports.ArrayPattern = exports.ArrayExpression = exports.ArgumentPlaceholder = exports.AnyTypeAnnotation = void 0;\nexports.TSNumberKeyword = exports.TSNullKeyword = exports.TSNonNullExpression = exports.TSNeverKeyword = exports.TSNamespaceExportDeclaration = exports.TSNamedTupleMember = exports.TSModuleDeclaration = exports.TSModuleBlock = exports.TSMethodSignature = exports.TSMappedType = exports.TSLiteralType = exports.TSIntrinsicKeyword = exports.TSIntersectionType = exports.TSInterfaceDeclaration = exports.TSInterfaceBody = exports.TSInstantiationExpression = exports.TSInferType = exports.TSIndexedAccessType = exports.TSIndexSignature = exports.TSImportType = exports.TSImportEqualsDeclaration = exports.TSFunctionType = exports.TSExternalModuleReference = exports.TSExpressionWithTypeArguments = exports.TSExportAssignment = exports.TSEnumMember = exports.TSEnumDeclaration = exports.TSEnumBody = exports.TSDeclareMethod = exports.TSDeclareFunction = exports.TSConstructorType = exports.TSConstructSignatureDeclaration = exports.TSConditionalType = exports.TSCallSignatureDeclaration = exports.TSBooleanKeyword = exports.TSBigIntKeyword = exports.TSAsExpression = exports.TSArrayType = exports.TSAnyKeyword = exports.SymbolTypeAnnotation = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StringTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringLiteral = exports.StaticBlock = exports.SpreadProperty = exports.SpreadElement = exports.SequenceExpression = exports.ReturnStatement = exports.RestProperty = exports.RestElement = exports.RegexLiteral = exports.RegExpLiteral = exports.RecordExpression = exports.QualifiedTypeIdentifier = exports.Program = exports.PrivateName = exports.Placeholder = exports.PipelineTopicExpression = exports.PipelinePrimaryTopicReference = exports.PipelineBareFunction = exports.ParenthesizedExpression = exports.OptionalMemberExpression = exports.OptionalIndexedAccessType = exports.OptionalCallExpression = exports.OpaqueType = exports.ObjectTypeSpreadProperty = exports.ObjectTypeProperty = exports.ObjectTypeInternalSlot = exports.ObjectTypeIndexer = exports.ObjectTypeCallProperty = exports.ObjectTypeAnnotation = exports.ObjectProperty = exports.ObjectPattern = exports.ObjectMethod = exports.ObjectExpression = exports.NumericLiteral = exports.NumberTypeAnnotation = exports.NumberLiteralTypeAnnotation = exports.NumberLiteral = exports.NullableTypeAnnotation = exports.NullLiteralTypeAnnotation = exports.NullLiteral = exports.Noop = exports.NewExpression = exports.ModuleExpression = exports.MixedTypeAnnotation = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.LabeledStatement = exports.JSXText = exports.JSXSpreadChild = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXMemberExpression = void 0;\nexports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VoidTypeAnnotation = exports.VoidPattern = exports.Variance = exports.VariableDeclarator = exports.VariableDeclaration = exports.V8IntrinsicIdentifier = exports.UpdateExpression = exports.UnionTypeAnnotation = exports.UnaryExpression = exports.TypeofTypeAnnotation = exports.TypeParameterInstantiation = exports.TypeParameterDeclaration = exports.TypeParameter = exports.TypeCastExpression = exports.TypeAnnotation = exports.TypeAlias = exports.TupleTypeAnnotation = exports.TupleExpression = exports.TryStatement = exports.TopicReference = exports.ThrowStatement = exports.ThisTypeAnnotation = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.TSVoidKeyword = exports.TSUnknownKeyword = exports.TSUnionType = exports.TSUndefinedKeyword = exports.TSTypeReference = exports.TSTypeQuery = exports.TSTypePredicate = exports.TSTypeParameterInstantiation = exports.TSTypeParameterDeclaration = exports.TSTypeParameter = exports.TSTypeOperator = exports.TSTypeLiteral = exports.TSTypeAssertion = exports.TSTypeAnnotation = exports.TSTypeAliasDeclaration = exports.TSTupleType = exports.TSThisType = exports.TSTemplateLiteralType = exports.TSSymbolKeyword = exports.TSStringKeyword = exports.TSSatisfiesExpression = exports.TSRestType = exports.TSQualifiedName = exports.TSPropertySignature = exports.TSParenthesizedType = exports.TSParameterProperty = exports.TSOptionalType = exports.TSObjectKeyword = void 0;\nvar b = require(\"./lowercase.js\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning.js\");\nfunction alias(lowercase) {\n  return b[lowercase];\n}\nconst ArrayExpression = exports.ArrayExpression = alias(\"arrayExpression\"),\n  AssignmentExpression = exports.AssignmentExpression = alias(\"assignmentExpression\"),\n  BinaryExpression = exports.BinaryExpression = alias(\"binaryExpression\"),\n  InterpreterDirective = exports.InterpreterDirective = alias(\"interpreterDirective\"),\n  Directive = exports.Directive = alias(\"directive\"),\n  DirectiveLiteral = exports.DirectiveLiteral = alias(\"directiveLiteral\"),\n  BlockStatement = exports.BlockStatement = alias(\"blockStatement\"),\n  BreakStatement = exports.BreakStatement = alias(\"breakStatement\"),\n  CallExpression = exports.CallExpression = alias(\"callExpression\"),\n  CatchClause = exports.CatchClause = alias(\"catchClause\"),\n  ConditionalExpression = exports.ConditionalExpression = alias(\"conditionalExpression\"),\n  ContinueStatement = exports.ContinueStatement = alias(\"continueStatement\"),\n  DebuggerStatement = exports.DebuggerStatement = alias(\"debuggerStatement\"),\n  DoWhileStatement = exports.DoWhileStatement = alias(\"doWhileStatement\"),\n  EmptyStatement = exports.EmptyStatement = alias(\"emptyStatement\"),\n  ExpressionStatement = exports.ExpressionStatement = alias(\"expressionStatement\"),\n  File = exports.File = alias(\"file\"),\n  ForInStatement = exports.ForInStatement = alias(\"forInStatement\"),\n  ForStatement = exports.ForStatement = alias(\"forStatement\"),\n  FunctionDeclaration = exports.FunctionDeclaration = alias(\"functionDeclaration\"),\n  FunctionExpression = exports.FunctionExpression = alias(\"functionExpression\"),\n  Identifier = exports.Identifier = alias(\"identifier\"),\n  IfStatement = exports.IfStatement = alias(\"ifStatement\"),\n  LabeledStatement = exports.LabeledStatement = alias(\"labeledStatement\"),\n  StringLiteral = exports.StringLiteral = alias(\"stringLiteral\"),\n  NumericLiteral = exports.NumericLiteral = alias(\"numericLiteral\"),\n  NullLiteral = exports.NullLiteral = alias(\"nullLiteral\"),\n  BooleanLiteral = exports.BooleanLiteral = alias(\"booleanLiteral\"),\n  RegExpLiteral = exports.RegExpLiteral = alias(\"regExpLiteral\"),\n  LogicalExpression = exports.LogicalExpression = alias(\"logicalExpression\"),\n  MemberExpression = exports.MemberExpression = alias(\"memberExpression\"),\n  NewExpression = exports.NewExpression = alias(\"newExpression\"),\n  Program = exports.Program = alias(\"program\"),\n  ObjectExpression = exports.ObjectExpression = alias(\"objectExpression\"),\n  ObjectMethod = exports.ObjectMethod = alias(\"objectMethod\"),\n  ObjectProperty = exports.ObjectProperty = alias(\"objectProperty\"),\n  RestElement = exports.RestElement = alias(\"restElement\"),\n  ReturnStatement = exports.ReturnStatement = alias(\"returnStatement\"),\n  SequenceExpression = exports.SequenceExpression = alias(\"sequenceExpression\"),\n  ParenthesizedExpression = exports.ParenthesizedExpression = alias(\"parenthesizedExpression\"),\n  SwitchCase = exports.SwitchCase = alias(\"switchCase\"),\n  SwitchStatement = exports.SwitchStatement = alias(\"switchStatement\"),\n  ThisExpression = exports.ThisExpression = alias(\"thisExpression\"),\n  ThrowStatement = exports.ThrowStatement = alias(\"throwStatement\"),\n  TryStatement = exports.TryStatement = alias(\"tryStatement\"),\n  UnaryExpression = exports.UnaryExpression = alias(\"unaryExpression\"),\n  UpdateExpression = exports.UpdateExpression = alias(\"updateExpression\"),\n  VariableDeclaration = exports.VariableDeclaration = alias(\"variableDeclaration\"),\n  VariableDeclarator = exports.VariableDeclarator = alias(\"variableDeclarator\"),\n  WhileStatement = exports.WhileStatement = alias(\"whileStatement\"),\n  WithStatement = exports.WithStatement = alias(\"withStatement\"),\n  AssignmentPattern = exports.AssignmentPattern = alias(\"assignmentPattern\"),\n  ArrayPattern = exports.ArrayPattern = alias(\"arrayPattern\"),\n  ArrowFunctionExpression = exports.ArrowFunctionExpression = alias(\"arrowFunctionExpression\"),\n  ClassBody = exports.ClassBody = alias(\"classBody\"),\n  ClassExpression = exports.ClassExpression = alias(\"classExpression\"),\n  ClassDeclaration = exports.ClassDeclaration = alias(\"classDeclaration\"),\n  ExportAllDeclaration = exports.ExportAllDeclaration = alias(\"exportAllDeclaration\"),\n  ExportDefaultDeclaration = exports.ExportDefaultDeclaration = alias(\"exportDefaultDeclaration\"),\n  ExportNamedDeclaration = exports.ExportNamedDeclaration = alias(\"exportNamedDeclaration\"),\n  ExportSpecifier = exports.ExportSpecifier = alias(\"exportSpecifier\"),\n  ForOfStatement = exports.ForOfStatement = alias(\"forOfStatement\"),\n  ImportDeclaration = exports.ImportDeclaration = alias(\"importDeclaration\"),\n  ImportDefaultSpecifier = exports.ImportDefaultSpecifier = alias(\"importDefaultSpecifier\"),\n  ImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = alias(\"importNamespaceSpecifier\"),\n  ImportSpecifier = exports.ImportSpecifier = alias(\"importSpecifier\"),\n  ImportExpression = exports.ImportExpression = alias(\"importExpression\"),\n  MetaProperty = exports.MetaProperty = alias(\"metaProperty\"),\n  ClassMethod = exports.ClassMethod = alias(\"classMethod\"),\n  ObjectPattern = exports.ObjectPattern = alias(\"objectPattern\"),\n  SpreadElement = exports.SpreadElement = alias(\"spreadElement\"),\n  Super = exports.Super = alias(\"super\"),\n  TaggedTemplateExpression = exports.TaggedTemplateExpression = alias(\"taggedTemplateExpression\"),\n  TemplateElement = exports.TemplateElement = alias(\"templateElement\"),\n  TemplateLiteral = exports.TemplateLiteral = alias(\"templateLiteral\"),\n  YieldExpression = exports.YieldExpression = alias(\"yieldExpression\"),\n  AwaitExpression = exports.AwaitExpression = alias(\"awaitExpression\"),\n  Import = exports.Import = alias(\"import\"),\n  BigIntLiteral = exports.BigIntLiteral = alias(\"bigIntLiteral\"),\n  ExportNamespaceSpecifier = exports.ExportNamespaceSpecifier = alias(\"exportNamespaceSpecifier\"),\n  OptionalMemberExpression = exports.OptionalMemberExpression = alias(\"optionalMemberExpression\"),\n  OptionalCallExpression = exports.OptionalCallExpression = alias(\"optionalCallExpression\"),\n  ClassProperty = exports.ClassProperty = alias(\"classProperty\"),\n  ClassAccessorProperty = exports.ClassAccessorProperty = alias(\"classAccessorProperty\"),\n  ClassPrivateProperty = exports.ClassPrivateProperty = alias(\"classPrivateProperty\"),\n  ClassPrivateMethod = exports.ClassPrivateMethod = alias(\"classPrivateMethod\"),\n  PrivateName = exports.PrivateName = alias(\"privateName\"),\n  StaticBlock = exports.StaticBlock = alias(\"staticBlock\"),\n  ImportAttribute = exports.ImportAttribute = alias(\"importAttribute\"),\n  AnyTypeAnnotation = exports.AnyTypeAnnotation = alias(\"anyTypeAnnotation\"),\n  ArrayTypeAnnotation = exports.ArrayTypeAnnotation = alias(\"arrayTypeAnnotation\"),\n  BooleanTypeAnnotation = exports.BooleanTypeAnnotation = alias(\"booleanTypeAnnotation\"),\n  BooleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = alias(\"booleanLiteralTypeAnnotation\"),\n  NullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = alias(\"nullLiteralTypeAnnotation\"),\n  ClassImplements = exports.ClassImplements = alias(\"classImplements\"),\n  DeclareClass = exports.DeclareClass = alias(\"declareClass\"),\n  DeclareFunction = exports.DeclareFunction = alias(\"declareFunction\"),\n  DeclareInterface = exports.DeclareInterface = alias(\"declareInterface\"),\n  DeclareModule = exports.DeclareModule = alias(\"declareModule\"),\n  DeclareModuleExports = exports.DeclareModuleExports = alias(\"declareModuleExports\"),\n  DeclareTypeAlias = exports.DeclareTypeAlias = alias(\"declareTypeAlias\"),\n  DeclareOpaqueType = exports.DeclareOpaqueType = alias(\"declareOpaqueType\"),\n  DeclareVariable = exports.DeclareVariable = alias(\"declareVariable\"),\n  DeclareExportDeclaration = exports.DeclareExportDeclaration = alias(\"declareExportDeclaration\"),\n  DeclareExportAllDeclaration = exports.DeclareExportAllDeclaration = alias(\"declareExportAllDeclaration\"),\n  DeclaredPredicate = exports.DeclaredPredicate = alias(\"declaredPredicate\"),\n  ExistsTypeAnnotation = exports.ExistsTypeAnnotation = alias(\"existsTypeAnnotation\"),\n  FunctionTypeAnnotation = exports.FunctionTypeAnnotation = alias(\"functionTypeAnnotation\"),\n  FunctionTypeParam = exports.FunctionTypeParam = alias(\"functionTypeParam\"),\n  GenericTypeAnnotation = exports.GenericTypeAnnotation = alias(\"genericTypeAnnotation\"),\n  InferredPredicate = exports.InferredPredicate = alias(\"inferredPredicate\"),\n  InterfaceExtends = exports.InterfaceExtends = alias(\"interfaceExtends\"),\n  InterfaceDeclaration = exports.InterfaceDeclaration = alias(\"interfaceDeclaration\"),\n  InterfaceTypeAnnotation = exports.InterfaceTypeAnnotation = alias(\"interfaceTypeAnnotation\"),\n  IntersectionTypeAnnotation = exports.IntersectionTypeAnnotation = alias(\"intersectionTypeAnnotation\"),\n  MixedTypeAnnotation = exports.MixedTypeAnnotation = alias(\"mixedTypeAnnotation\"),\n  EmptyTypeAnnotation = exports.EmptyTypeAnnotation = alias(\"emptyTypeAnnotation\"),\n  NullableTypeAnnotation = exports.NullableTypeAnnotation = alias(\"nullableTypeAnnotation\"),\n  NumberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = alias(\"numberLiteralTypeAnnotation\"),\n  NumberTypeAnnotation = exports.NumberTypeAnnotation = alias(\"numberTypeAnnotation\"),\n  ObjectTypeAnnotation = exports.ObjectTypeAnnotation = alias(\"objectTypeAnnotation\"),\n  ObjectTypeInternalSlot = exports.ObjectTypeInternalSlot = alias(\"objectTypeInternalSlot\"),\n  ObjectTypeCallProperty = exports.ObjectTypeCallProperty = alias(\"objectTypeCallProperty\"),\n  ObjectTypeIndexer = exports.ObjectTypeIndexer = alias(\"objectTypeIndexer\"),\n  ObjectTypeProperty = exports.ObjectTypeProperty = alias(\"objectTypeProperty\"),\n  ObjectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = alias(\"objectTypeSpreadProperty\"),\n  OpaqueType = exports.OpaqueType = alias(\"opaqueType\"),\n  QualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = alias(\"qualifiedTypeIdentifier\"),\n  StringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = alias(\"stringLiteralTypeAnnotation\"),\n  StringTypeAnnotation = exports.StringTypeAnnotation = alias(\"stringTypeAnnotation\"),\n  SymbolTypeAnnotation = exports.SymbolTypeAnnotation = alias(\"symbolTypeAnnotation\"),\n  ThisTypeAnnotation = exports.ThisTypeAnnotation = alias(\"thisTypeAnnotation\"),\n  TupleTypeAnnotation = exports.TupleTypeAnnotation = alias(\"tupleTypeAnnotation\"),\n  TypeofTypeAnnotation = exports.TypeofTypeAnnotation = alias(\"typeofTypeAnnotation\"),\n  TypeAlias = exports.TypeAlias = alias(\"typeAlias\"),\n  TypeAnnotation = exports.TypeAnnotation = alias(\"typeAnnotation\"),\n  TypeCastExpression = exports.TypeCastExpression = alias(\"typeCastExpression\"),\n  TypeParameter = exports.TypeParameter = alias(\"typeParameter\"),\n  TypeParameterDeclaration = exports.TypeParameterDeclaration = alias(\"typeParameterDeclaration\"),\n  TypeParameterInstantiation = exports.TypeParameterInstantiation = alias(\"typeParameterInstantiation\"),\n  UnionTypeAnnotation = exports.UnionTypeAnnotation = alias(\"unionTypeAnnotation\"),\n  Variance = exports.Variance = alias(\"variance\"),\n  VoidTypeAnnotation = exports.VoidTypeAnnotation = alias(\"voidTypeAnnotation\"),\n  EnumDeclaration = exports.EnumDeclaration = alias(\"enumDeclaration\"),\n  EnumBooleanBody = exports.EnumBooleanBody = alias(\"enumBooleanBody\"),\n  EnumNumberBody = exports.EnumNumberBody = alias(\"enumNumberBody\"),\n  EnumStringBody = exports.EnumStringBody = alias(\"enumStringBody\"),\n  EnumSymbolBody = exports.EnumSymbolBody = alias(\"enumSymbolBody\"),\n  EnumBooleanMember = exports.EnumBooleanMember = alias(\"enumBooleanMember\"),\n  EnumNumberMember = exports.EnumNumberMember = alias(\"enumNumberMember\"),\n  EnumStringMember = exports.EnumStringMember = alias(\"enumStringMember\"),\n  EnumDefaultedMember = exports.EnumDefaultedMember = alias(\"enumDefaultedMember\"),\n  IndexedAccessType = exports.IndexedAccessType = alias(\"indexedAccessType\"),\n  OptionalIndexedAccessType = exports.OptionalIndexedAccessType = alias(\"optionalIndexedAccessType\"),\n  JSXAttribute = exports.JSXAttribute = alias(\"jsxAttribute\"),\n  JSXClosingElement = exports.JSXClosingElement = alias(\"jsxClosingElement\"),\n  JSXElement = exports.JSXElement = alias(\"jsxElement\"),\n  JSXEmptyExpression = exports.JSXEmptyExpression = alias(\"jsxEmptyExpression\"),\n  JSXExpressionContainer = exports.JSXExpressionContainer = alias(\"jsxExpressionContainer\"),\n  JSXSpreadChild = exports.JSXSpreadChild = alias(\"jsxSpreadChild\"),\n  JSXIdentifier = exports.JSXIdentifier = alias(\"jsxIdentifier\"),\n  JSXMemberExpression = exports.JSXMemberExpression = alias(\"jsxMemberExpression\"),\n  JSXNamespacedName = exports.JSXNamespacedName = alias(\"jsxNamespacedName\"),\n  JSXOpeningElement = exports.JSXOpeningElement = alias(\"jsxOpeningElement\"),\n  JSXSpreadAttribute = exports.JSXSpreadAttribute = alias(\"jsxSpreadAttribute\"),\n  JSXText = exports.JSXText = alias(\"jsxText\"),\n  JSXFragment = exports.JSXFragment = alias(\"jsxFragment\"),\n  JSXOpeningFragment = exports.JSXOpeningFragment = alias(\"jsxOpeningFragment\"),\n  JSXClosingFragment = exports.JSXClosingFragment = alias(\"jsxClosingFragment\"),\n  Noop = exports.Noop = alias(\"noop\"),\n  Placeholder = exports.Placeholder = alias(\"placeholder\"),\n  V8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = alias(\"v8IntrinsicIdentifier\"),\n  ArgumentPlaceholder = exports.ArgumentPlaceholder = alias(\"argumentPlaceholder\"),\n  BindExpression = exports.BindExpression = alias(\"bindExpression\"),\n  Decorator = exports.Decorator = alias(\"decorator\"),\n  DoExpression = exports.DoExpression = alias(\"doExpression\"),\n  ExportDefaultSpecifier = exports.ExportDefaultSpecifier = alias(\"exportDefaultSpecifier\"),\n  RecordExpression = exports.RecordExpression = alias(\"recordExpression\"),\n  TupleExpression = exports.TupleExpression = alias(\"tupleExpression\"),\n  DecimalLiteral = exports.DecimalLiteral = alias(\"decimalLiteral\"),\n  ModuleExpression = exports.ModuleExpression = alias(\"moduleExpression\"),\n  TopicReference = exports.TopicReference = alias(\"topicReference\"),\n  PipelineTopicExpression = exports.PipelineTopicExpression = alias(\"pipelineTopicExpression\"),\n  PipelineBareFunction = exports.PipelineBareFunction = alias(\"pipelineBareFunction\"),\n  PipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = alias(\"pipelinePrimaryTopicReference\"),\n  VoidPattern = exports.VoidPattern = alias(\"voidPattern\"),\n  TSParameterProperty = exports.TSParameterProperty = alias(\"tsParameterProperty\"),\n  TSDeclareFunction = exports.TSDeclareFunction = alias(\"tsDeclareFunction\"),\n  TSDeclareMethod = exports.TSDeclareMethod = alias(\"tsDeclareMethod\"),\n  TSQualifiedName = exports.TSQualifiedName = alias(\"tsQualifiedName\"),\n  TSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = alias(\"tsCallSignatureDeclaration\"),\n  TSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = alias(\"tsConstructSignatureDeclaration\"),\n  TSPropertySignature = exports.TSPropertySignature = alias(\"tsPropertySignature\"),\n  TSMethodSignature = exports.TSMethodSignature = alias(\"tsMethodSignature\"),\n  TSIndexSignature = exports.TSIndexSignature = alias(\"tsIndexSignature\"),\n  TSAnyKeyword = exports.TSAnyKeyword = alias(\"tsAnyKeyword\"),\n  TSBooleanKeyword = exports.TSBooleanKeyword = alias(\"tsBooleanKeyword\"),\n  TSBigIntKeyword = exports.TSBigIntKeyword = alias(\"tsBigIntKeyword\"),\n  TSIntrinsicKeyword = exports.TSIntrinsicKeyword = alias(\"tsIntrinsicKeyword\"),\n  TSNeverKeyword = exports.TSNeverKeyword = alias(\"tsNeverKeyword\"),\n  TSNullKeyword = exports.TSNullKeyword = alias(\"tsNullKeyword\"),\n  TSNumberKeyword = exports.TSNumberKeyword = alias(\"tsNumberKeyword\"),\n  TSObjectKeyword = exports.TSObjectKeyword = alias(\"tsObjectKeyword\"),\n  TSStringKeyword = exports.TSStringKeyword = alias(\"tsStringKeyword\"),\n  TSSymbolKeyword = exports.TSSymbolKeyword = alias(\"tsSymbolKeyword\"),\n  TSUndefinedKeyword = exports.TSUndefinedKeyword = alias(\"tsUndefinedKeyword\"),\n  TSUnknownKeyword = exports.TSUnknownKeyword = alias(\"tsUnknownKeyword\"),\n  TSVoidKeyword = exports.TSVoidKeyword = alias(\"tsVoidKeyword\"),\n  TSThisType = exports.TSThisType = alias(\"tsThisType\"),\n  TSFunctionType = exports.TSFunctionType = alias(\"tsFunctionType\"),\n  TSConstructorType = exports.TSConstructorType = alias(\"tsConstructorType\"),\n  TSTypeReference = exports.TSTypeReference = alias(\"tsTypeReference\"),\n  TSTypePredicate = exports.TSTypePredicate = alias(\"tsTypePredicate\"),\n  TSTypeQuery = exports.TSTypeQuery = alias(\"tsTypeQuery\"),\n  TSTypeLiteral = exports.TSTypeLiteral = alias(\"tsTypeLiteral\"),\n  TSArrayType = exports.TSArrayType = alias(\"tsArrayType\"),\n  TSTupleType = exports.TSTupleType = alias(\"tsTupleType\"),\n  TSOptionalType = exports.TSOptionalType = alias(\"tsOptionalType\"),\n  TSRestType = exports.TSRestType = alias(\"tsRestType\"),\n  TSNamedTupleMember = exports.TSNamedTupleMember = alias(\"tsNamedTupleMember\"),\n  TSUnionType = exports.TSUnionType = alias(\"tsUnionType\"),\n  TSIntersectionType = exports.TSIntersectionType = alias(\"tsIntersectionType\"),\n  TSConditionalType = exports.TSConditionalType = alias(\"tsConditionalType\"),\n  TSInferType = exports.TSInferType = alias(\"tsInferType\"),\n  TSParenthesizedType = exports.TSParenthesizedType = alias(\"tsParenthesizedType\"),\n  TSTypeOperator = exports.TSTypeOperator = alias(\"tsTypeOperator\"),\n  TSIndexedAccessType = exports.TSIndexedAccessType = alias(\"tsIndexedAccessType\"),\n  TSMappedType = exports.TSMappedType = alias(\"tsMappedType\"),\n  TSTemplateLiteralType = exports.TSTemplateLiteralType = alias(\"tsTemplateLiteralType\"),\n  TSLiteralType = exports.TSLiteralType = alias(\"tsLiteralType\"),\n  TSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = alias(\"tsExpressionWithTypeArguments\"),\n  TSInterfaceDeclaration = exports.TSInterfaceDeclaration = alias(\"tsInterfaceDeclaration\"),\n  TSInterfaceBody = exports.TSInterfaceBody = alias(\"tsInterfaceBody\"),\n  TSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = alias(\"tsTypeAliasDeclaration\"),\n  TSInstantiationExpression = exports.TSInstantiationExpression = alias(\"tsInstantiationExpression\"),\n  TSAsExpression = exports.TSAsExpression = alias(\"tsAsExpression\"),\n  TSSatisfiesExpression = exports.TSSatisfiesExpression = alias(\"tsSatisfiesExpression\"),\n  TSTypeAssertion = exports.TSTypeAssertion = alias(\"tsTypeAssertion\"),\n  TSEnumBody = exports.TSEnumBody = alias(\"tsEnumBody\"),\n  TSEnumDeclaration = exports.TSEnumDeclaration = alias(\"tsEnumDeclaration\"),\n  TSEnumMember = exports.TSEnumMember = alias(\"tsEnumMember\"),\n  TSModuleDeclaration = exports.TSModuleDeclaration = alias(\"tsModuleDeclaration\"),\n  TSModuleBlock = exports.TSModuleBlock = alias(\"tsModuleBlock\"),\n  TSImportType = exports.TSImportType = alias(\"tsImportType\"),\n  TSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = alias(\"tsImportEqualsDeclaration\"),\n  TSExternalModuleReference = exports.TSExternalModuleReference = alias(\"tsExternalModuleReference\"),\n  TSNonNullExpression = exports.TSNonNullExpression = alias(\"tsNonNullExpression\"),\n  TSExportAssignment = exports.TSExportAssignment = alias(\"tsExportAssignment\"),\n  TSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = alias(\"tsNamespaceExportDeclaration\"),\n  TSTypeAnnotation = exports.TSTypeAnnotation = alias(\"tsTypeAnnotation\"),\n  TSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = alias(\"tsTypeParameterInstantiation\"),\n  TSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = alias(\"tsTypeParameterDeclaration\"),\n  TSTypeParameter = exports.TSTypeParameter = alias(\"tsTypeParameter\");\nconst NumberLiteral = exports.NumberLiteral = b.numberLiteral,\n  RegexLiteral = exports.RegexLiteral = b.regexLiteral,\n  RestProperty = exports.RestProperty = b.restProperty,\n  SpreadProperty = exports.SpreadProperty = b.spreadProperty;\n\n//# sourceMappingURL=uppercase.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertNode;\nvar _isNode = require(\"../validators/isNode.js\");\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var _node$type;\n    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}\n\n//# sourceMappingURL=assertNode.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNode;\nvar _index = require(\"../definitions/index.js\");\nfunction isNode(node) {\n  return !!(node && _index.VISITOR_KEYS[node.type]);\n}\n\n//# sourceMappingURL=isNode.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertAccessor = assertAccessor;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArgumentPlaceholder = assertArgumentPlaceholder;\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertBigIntLiteral = assertBigIntLiteral;\nexports.assertBinary = assertBinary;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertBindExpression = assertBindExpression;\nexports.assertBlock = assertBlock;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertClass = assertClass;\nexports.assertClassAccessorProperty = assertClassAccessorProperty;\nexports.assertClassBody = assertClassBody;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertClassExpression = assertClassExpression;\nexports.assertClassImplements = assertClassImplements;\nexports.assertClassMethod = assertClassMethod;\nexports.assertClassPrivateMethod = assertClassPrivateMethod;\nexports.assertClassPrivateProperty = assertClassPrivateProperty;\nexports.assertClassProperty = assertClassProperty;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDecimalLiteral = assertDecimalLiteral;\nexports.assertDeclaration = assertDeclaration;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertDecorator = assertDecorator;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertDoExpression = assertDoExpression;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertEnumBody = assertEnumBody;\nexports.assertEnumBooleanBody = assertEnumBooleanBody;\nexports.assertEnumBooleanMember = assertEnumBooleanMember;\nexports.assertEnumDeclaration = assertEnumDeclaration;\nexports.assertEnumDefaultedMember = assertEnumDefaultedMember;\nexports.assertEnumMember = assertEnumMember;\nexports.assertEnumNumberBody = assertEnumNumberBody;\nexports.assertEnumNumberMember = assertEnumNumberMember;\nexports.assertEnumStringBody = assertEnumStringBody;\nexports.assertEnumStringMember = assertEnumStringMember;\nexports.assertEnumSymbolBody = assertEnumSymbolBody;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertExpression = assertExpression;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFile = assertFile;\nexports.assertFlow = assertFlow;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertFlowType = assertFlowType;\nexports.assertFor = assertFor;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertFunctionParameter = assertFunctionParameter;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertImmutable = assertImmutable;\nexports.assertImport = assertImport;\nexports.assertImportAttribute = assertImportAttribute;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportExpression = assertImportExpression;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertIndexedAccessType = assertIndexedAccessType;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\nexports.assertInterpreterDirective = assertInterpreterDirective;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertJSX = assertJSX;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXText = assertJSXText;\nexports.assertLVal = assertLVal;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertLiteral = assertLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertLoop = assertLoop;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertMethod = assertMethod;\nexports.assertMiscellaneous = assertMiscellaneous;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertModuleExpression = assertModuleExpression;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertNewExpression = assertNewExpression;\nexports.assertNoop = assertNoop;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMember = assertObjectMember;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertPattern = assertPattern;\nexports.assertPatternLike = assertPatternLike;\nexports.assertPipelineBareFunction = assertPipelineBareFunction;\nexports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\nexports.assertPipelineTopicExpression = assertPipelineTopicExpression;\nexports.assertPlaceholder = assertPlaceholder;\nexports.assertPrivate = assertPrivate;\nexports.assertPrivateName = assertPrivateName;\nexports.assertProgram = assertProgram;\nexports.assertProperty = assertProperty;\nexports.assertPureish = assertPureish;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertRecordExpression = assertRecordExpression;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestElement = assertRestElement;\nexports.assertRestProperty = assertRestProperty;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertScopable = assertScopable;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSpreadProperty = assertSpreadProperty;\nexports.assertStandardized = assertStandardized;\nexports.assertStatement = assertStatement;\nexports.assertStaticBlock = assertStaticBlock;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertSuper = assertSuper;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSBaseType = assertTSBaseType;\nexports.assertTSBigIntKeyword = assertTSBigIntKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertTSEnumBody = assertTSEnumBody;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSImportType = assertTSImportType;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSInstantiationExpression = assertTSInstantiationExpression;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSNamedTupleMember = assertTSNamedTupleMember;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSOptionalType = assertTSOptionalType;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSRestType = assertTSRestType;\nexports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSTemplateLiteralType = assertTSTemplateLiteralType;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSType = assertTSType;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSUnknownKeyword = assertTSUnknownKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTopicReference = assertTopicReference;\nexports.assertTryStatement = assertTryStatement;\nexports.assertTupleExpression = assertTupleExpression;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertTypeScript = assertTypeScript;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertVariance = assertVariance;\nexports.assertVoidPattern = assertVoidPattern;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertWhile = assertWhile;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertYieldExpression = assertYieldExpression;\nvar _is = require(\"../../validators/is.js\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning.js\");\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(`Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` + `but instead got \"${node.type}\".`);\n  }\n}\nfunction assertArrayExpression(node, opts) {\n  assert(\"ArrayExpression\", node, opts);\n}\nfunction assertAssignmentExpression(node, opts) {\n  assert(\"AssignmentExpression\", node, opts);\n}\nfunction assertBinaryExpression(node, opts) {\n  assert(\"BinaryExpression\", node, opts);\n}\nfunction assertInterpreterDirective(node, opts) {\n  assert(\"InterpreterDirective\", node, opts);\n}\nfunction assertDirective(node, opts) {\n  assert(\"Directive\", node, opts);\n}\nfunction assertDirectiveLiteral(node, opts) {\n  assert(\"DirectiveLiteral\", node, opts);\n}\nfunction assertBlockStatement(node, opts) {\n  assert(\"BlockStatement\", node, opts);\n}\nfunction assertBreakStatement(node, opts) {\n  assert(\"BreakStatement\", node, opts);\n}\nfunction assertCallExpression(node, opts) {\n  assert(\"CallExpression\", node, opts);\n}\nfunction assertCatchClause(node, opts) {\n  assert(\"CatchClause\", node, opts);\n}\nfunction assertConditionalExpression(node, opts) {\n  assert(\"ConditionalExpression\", node, opts);\n}\nfunction assertContinueStatement(node, opts) {\n  assert(\"ContinueStatement\", node, opts);\n}\nfunction assertDebuggerStatement(node, opts) {\n  assert(\"DebuggerStatement\", node, opts);\n}\nfunction assertDoWhileStatement(node, opts) {\n  assert(\"DoWhileStatement\", node, opts);\n}\nfunction assertEmptyStatement(node, opts) {\n  assert(\"EmptyStatement\", node, opts);\n}\nfunction assertExpressionStatement(node, opts) {\n  assert(\"ExpressionStatement\", node, opts);\n}\nfunction assertFile(node, opts) {\n  assert(\"File\", node, opts);\n}\nfunction assertForInStatement(node, opts) {\n  assert(\"ForInStatement\", node, opts);\n}\nfunction assertForStatement(node, opts) {\n  assert(\"ForStatement\", node, opts);\n}\nfunction assertFunctionDeclaration(node, opts) {\n  assert(\"FunctionDeclaration\", node, opts);\n}\nfunction assertFunctionExpression(node, opts) {\n  assert(\"FunctionExpression\", node, opts);\n}\nfunction assertIdentifier(node, opts) {\n  assert(\"Identifier\", node, opts);\n}\nfunction assertIfStatement(node, opts) {\n  assert(\"IfStatement\", node, opts);\n}\nfunction assertLabeledStatement(node, opts) {\n  assert(\"LabeledStatement\", node, opts);\n}\nfunction assertStringLiteral(node, opts) {\n  assert(\"StringLiteral\", node, opts);\n}\nfunction assertNumericLiteral(node, opts) {\n  assert(\"NumericLiteral\", node, opts);\n}\nfunction assertNullLiteral(node, opts) {\n  assert(\"NullLiteral\", node, opts);\n}\nfunction assertBooleanLiteral(node, opts) {\n  assert(\"BooleanLiteral\", node, opts);\n}\nfunction assertRegExpLiteral(node, opts) {\n  assert(\"RegExpLiteral\", node, opts);\n}\nfunction assertLogicalExpression(node, opts) {\n  assert(\"LogicalExpression\", node, opts);\n}\nfunction assertMemberExpression(node, opts) {\n  assert(\"MemberExpression\", node, opts);\n}\nfunction assertNewExpression(node, opts) {\n  assert(\"NewExpression\", node, opts);\n}\nfunction assertProgram(node, opts) {\n  assert(\"Program\", node, opts);\n}\nfunction assertObjectExpression(node, opts) {\n  assert(\"ObjectExpression\", node, opts);\n}\nfunction assertObjectMethod(node, opts) {\n  assert(\"ObjectMethod\", node, opts);\n}\nfunction assertObjectProperty(node, opts) {\n  assert(\"ObjectProperty\", node, opts);\n}\nfunction assertRestElement(node, opts) {\n  assert(\"RestElement\", node, opts);\n}\nfunction assertReturnStatement(node, opts) {\n  assert(\"ReturnStatement\", node, opts);\n}\nfunction assertSequenceExpression(node, opts) {\n  assert(\"SequenceExpression\", node, opts);\n}\nfunction assertParenthesizedExpression(node, opts) {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\nfunction assertSwitchCase(node, opts) {\n  assert(\"SwitchCase\", node, opts);\n}\nfunction assertSwitchStatement(node, opts) {\n  assert(\"SwitchStatement\", node, opts);\n}\nfunction assertThisExpression(node, opts) {\n  assert(\"ThisExpression\", node, opts);\n}\nfunction assertThrowStatement(node, opts) {\n  assert(\"ThrowStatement\", node, opts);\n}\nfunction assertTryStatement(node, opts) {\n  assert(\"TryStatement\", node, opts);\n}\nfunction assertUnaryExpression(node, opts) {\n  assert(\"UnaryExpression\", node, opts);\n}\nfunction assertUpdateExpression(node, opts) {\n  assert(\"UpdateExpression\", node, opts);\n}\nfunction assertVariableDeclaration(node, opts) {\n  assert(\"VariableDeclaration\", node, opts);\n}\nfunction assertVariableDeclarator(node, opts) {\n  assert(\"VariableDeclarator\", node, opts);\n}\nfunction assertWhileStatement(node, opts) {\n  assert(\"WhileStatement\", node, opts);\n}\nfunction assertWithStatement(node, opts) {\n  assert(\"WithStatement\", node, opts);\n}\nfunction assertAssignmentPattern(node, opts) {\n  assert(\"AssignmentPattern\", node, opts);\n}\nfunction assertArrayPattern(node, opts) {\n  assert(\"ArrayPattern\", node, opts);\n}\nfunction assertArrowFunctionExpression(node, opts) {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\nfunction assertClassBody(node, opts) {\n  assert(\"ClassBody\", node, opts);\n}\nfunction assertClassExpression(node, opts) {\n  assert(\"ClassExpression\", node, opts);\n}\nfunction assertClassDeclaration(node, opts) {\n  assert(\"ClassDeclaration\", node, opts);\n}\nfunction assertExportAllDeclaration(node, opts) {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\nfunction assertExportDefaultDeclaration(node, opts) {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\nfunction assertExportNamedDeclaration(node, opts) {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\nfunction assertExportSpecifier(node, opts) {\n  assert(\"ExportSpecifier\", node, opts);\n}\nfunction assertForOfStatement(node, opts) {\n  assert(\"ForOfStatement\", node, opts);\n}\nfunction assertImportDeclaration(node, opts) {\n  assert(\"ImportDeclaration\", node, opts);\n}\nfunction assertImportDefaultSpecifier(node, opts) {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\nfunction assertImportNamespaceSpecifier(node, opts) {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nfunction assertImportSpecifier(node, opts) {\n  assert(\"ImportSpecifier\", node, opts);\n}\nfunction assertImportExpression(node, opts) {\n  assert(\"ImportExpression\", node, opts);\n}\nfunction assertMetaProperty(node, opts) {\n  assert(\"MetaProperty\", node, opts);\n}\nfunction assertClassMethod(node, opts) {\n  assert(\"ClassMethod\", node, opts);\n}\nfunction assertObjectPattern(node, opts) {\n  assert(\"ObjectPattern\", node, opts);\n}\nfunction assertSpreadElement(node, opts) {\n  assert(\"SpreadElement\", node, opts);\n}\nfunction assertSuper(node, opts) {\n  assert(\"Super\", node, opts);\n}\nfunction assertTaggedTemplateExpression(node, opts) {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\nfunction assertTemplateElement(node, opts) {\n  assert(\"TemplateElement\", node, opts);\n}\nfunction assertTemplateLiteral(node, opts) {\n  assert(\"TemplateLiteral\", node, opts);\n}\nfunction assertYieldExpression(node, opts) {\n  assert(\"YieldExpression\", node, opts);\n}\nfunction assertAwaitExpression(node, opts) {\n  assert(\"AwaitExpression\", node, opts);\n}\nfunction assertImport(node, opts) {\n  assert(\"Import\", node, opts);\n}\nfunction assertBigIntLiteral(node, opts) {\n  assert(\"BigIntLiteral\", node, opts);\n}\nfunction assertExportNamespaceSpecifier(node, opts) {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nfunction assertOptionalMemberExpression(node, opts) {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\nfunction assertOptionalCallExpression(node, opts) {\n  assert(\"OptionalCallExpression\", node, opts);\n}\nfunction assertClassProperty(node, opts) {\n  assert(\"ClassProperty\", node, opts);\n}\nfunction assertClassAccessorProperty(node, opts) {\n  assert(\"ClassAccessorProperty\", node, opts);\n}\nfunction assertClassPrivateProperty(node, opts) {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\nfunction assertClassPrivateMethod(node, opts) {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\nfunction assertPrivateName(node, opts) {\n  assert(\"PrivateName\", node, opts);\n}\nfunction assertStaticBlock(node, opts) {\n  assert(\"StaticBlock\", node, opts);\n}\nfunction assertImportAttribute(node, opts) {\n  assert(\"ImportAttribute\", node, opts);\n}\nfunction assertAnyTypeAnnotation(node, opts) {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\nfunction assertArrayTypeAnnotation(node, opts) {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\nfunction assertBooleanTypeAnnotation(node, opts) {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nfunction assertClassImplements(node, opts) {\n  assert(\"ClassImplements\", node, opts);\n}\nfunction assertDeclareClass(node, opts) {\n  assert(\"DeclareClass\", node, opts);\n}\nfunction assertDeclareFunction(node, opts) {\n  assert(\"DeclareFunction\", node, opts);\n}\nfunction assertDeclareInterface(node, opts) {\n  assert(\"DeclareInterface\", node, opts);\n}\nfunction assertDeclareModule(node, opts) {\n  assert(\"DeclareModule\", node, opts);\n}\nfunction assertDeclareModuleExports(node, opts) {\n  assert(\"DeclareModuleExports\", node, opts);\n}\nfunction assertDeclareTypeAlias(node, opts) {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\nfunction assertDeclareOpaqueType(node, opts) {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\nfunction assertDeclareVariable(node, opts) {\n  assert(\"DeclareVariable\", node, opts);\n}\nfunction assertDeclareExportDeclaration(node, opts) {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nfunction assertDeclaredPredicate(node, opts) {\n  assert(\"DeclaredPredicate\", node, opts);\n}\nfunction assertExistsTypeAnnotation(node, opts) {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeAnnotation(node, opts) {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeParam(node, opts) {\n  assert(\"FunctionTypeParam\", node, opts);\n}\nfunction assertGenericTypeAnnotation(node, opts) {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\nfunction assertInferredPredicate(node, opts) {\n  assert(\"InferredPredicate\", node, opts);\n}\nfunction assertInterfaceExtends(node, opts) {\n  assert(\"InterfaceExtends\", node, opts);\n}\nfunction assertInterfaceDeclaration(node, opts) {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\nfunction assertInterfaceTypeAnnotation(node, opts) {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nfunction assertMixedTypeAnnotation(node, opts) {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\nfunction assertEmptyTypeAnnotation(node, opts) {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\nfunction assertNullableTypeAnnotation(node, opts) {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNumberTypeAnnotation(node, opts) {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeAnnotation(node, opts) {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeInternalSlot(node, opts) {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nfunction assertObjectTypeCallProperty(node, opts) {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\nfunction assertObjectTypeIndexer(node, opts) {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\nfunction assertObjectTypeProperty(node, opts) {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nfunction assertOpaqueType(node, opts) {\n  assert(\"OpaqueType\", node, opts);\n}\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nfunction assertStringTypeAnnotation(node, opts) {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\nfunction assertSymbolTypeAnnotation(node, opts) {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\nfunction assertThisTypeAnnotation(node, opts) {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\nfunction assertTupleTypeAnnotation(node, opts) {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\nfunction assertTypeofTypeAnnotation(node, opts) {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\nfunction assertTypeAlias(node, opts) {\n  assert(\"TypeAlias\", node, opts);\n}\nfunction assertTypeAnnotation(node, opts) {\n  assert(\"TypeAnnotation\", node, opts);\n}\nfunction assertTypeCastExpression(node, opts) {\n  assert(\"TypeCastExpression\", node, opts);\n}\nfunction assertTypeParameter(node, opts) {\n  assert(\"TypeParameter\", node, opts);\n}\nfunction assertTypeParameterDeclaration(node, opts) {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\nfunction assertTypeParameterInstantiation(node, opts) {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\nfunction assertUnionTypeAnnotation(node, opts) {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\nfunction assertVariance(node, opts) {\n  assert(\"Variance\", node, opts);\n}\nfunction assertVoidTypeAnnotation(node, opts) {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\nfunction assertEnumDeclaration(node, opts) {\n  assert(\"EnumDeclaration\", node, opts);\n}\nfunction assertEnumBooleanBody(node, opts) {\n  assert(\"EnumBooleanBody\", node, opts);\n}\nfunction assertEnumNumberBody(node, opts) {\n  assert(\"EnumNumberBody\", node, opts);\n}\nfunction assertEnumStringBody(node, opts) {\n  assert(\"EnumStringBody\", node, opts);\n}\nfunction assertEnumSymbolBody(node, opts) {\n  assert(\"EnumSymbolBody\", node, opts);\n}\nfunction assertEnumBooleanMember(node, opts) {\n  assert(\"EnumBooleanMember\", node, opts);\n}\nfunction assertEnumNumberMember(node, opts) {\n  assert(\"EnumNumberMember\", node, opts);\n}\nfunction assertEnumStringMember(node, opts) {\n  assert(\"EnumStringMember\", node, opts);\n}\nfunction assertEnumDefaultedMember(node, opts) {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\nfunction assertIndexedAccessType(node, opts) {\n  assert(\"IndexedAccessType\", node, opts);\n}\nfunction assertOptionalIndexedAccessType(node, opts) {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\nfunction assertJSXAttribute(node, opts) {\n  assert(\"JSXAttribute\", node, opts);\n}\nfunction assertJSXClosingElement(node, opts) {\n  assert(\"JSXClosingElement\", node, opts);\n}\nfunction assertJSXElement(node, opts) {\n  assert(\"JSXElement\", node, opts);\n}\nfunction assertJSXEmptyExpression(node, opts) {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\nfunction assertJSXExpressionContainer(node, opts) {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\nfunction assertJSXSpreadChild(node, opts) {\n  assert(\"JSXSpreadChild\", node, opts);\n}\nfunction assertJSXIdentifier(node, opts) {\n  assert(\"JSXIdentifier\", node, opts);\n}\nfunction assertJSXMemberExpression(node, opts) {\n  assert(\"JSXMemberExpression\", node, opts);\n}\nfunction assertJSXNamespacedName(node, opts) {\n  assert(\"JSXNamespacedName\", node, opts);\n}\nfunction assertJSXOpeningElement(node, opts) {\n  assert(\"JSXOpeningElement\", node, opts);\n}\nfunction assertJSXSpreadAttribute(node, opts) {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\nfunction assertJSXText(node, opts) {\n  assert(\"JSXText\", node, opts);\n}\nfunction assertJSXFragment(node, opts) {\n  assert(\"JSXFragment\", node, opts);\n}\nfunction assertJSXOpeningFragment(node, opts) {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\nfunction assertJSXClosingFragment(node, opts) {\n  assert(\"JSXClosingFragment\", node, opts);\n}\nfunction assertNoop(node, opts) {\n  assert(\"Noop\", node, opts);\n}\nfunction assertPlaceholder(node, opts) {\n  assert(\"Placeholder\", node, opts);\n}\nfunction assertV8IntrinsicIdentifier(node, opts) {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nfunction assertArgumentPlaceholder(node, opts) {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\nfunction assertBindExpression(node, opts) {\n  assert(\"BindExpression\", node, opts);\n}\nfunction assertDecorator(node, opts) {\n  assert(\"Decorator\", node, opts);\n}\nfunction assertDoExpression(node, opts) {\n  assert(\"DoExpression\", node, opts);\n}\nfunction assertExportDefaultSpecifier(node, opts) {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\nfunction assertRecordExpression(node, opts) {\n  assert(\"RecordExpression\", node, opts);\n}\nfunction assertTupleExpression(node, opts) {\n  assert(\"TupleExpression\", node, opts);\n}\nfunction assertDecimalLiteral(node, opts) {\n  assert(\"DecimalLiteral\", node, opts);\n}\nfunction assertModuleExpression(node, opts) {\n  assert(\"ModuleExpression\", node, opts);\n}\nfunction assertTopicReference(node, opts) {\n  assert(\"TopicReference\", node, opts);\n}\nfunction assertPipelineTopicExpression(node, opts) {\n  assert(\"PipelineTopicExpression\", node, opts);\n}\nfunction assertPipelineBareFunction(node, opts) {\n  assert(\"PipelineBareFunction\", node, opts);\n}\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n  assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\nfunction assertVoidPattern(node, opts) {\n  assert(\"VoidPattern\", node, opts);\n}\nfunction assertTSParameterProperty(node, opts) {\n  assert(\"TSParameterProperty\", node, opts);\n}\nfunction assertTSDeclareFunction(node, opts) {\n  assert(\"TSDeclareFunction\", node, opts);\n}\nfunction assertTSDeclareMethod(node, opts) {\n  assert(\"TSDeclareMethod\", node, opts);\n}\nfunction assertTSQualifiedName(node, opts) {\n  assert(\"TSQualifiedName\", node, opts);\n}\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nfunction assertTSPropertySignature(node, opts) {\n  assert(\"TSPropertySignature\", node, opts);\n}\nfunction assertTSMethodSignature(node, opts) {\n  assert(\"TSMethodSignature\", node, opts);\n}\nfunction assertTSIndexSignature(node, opts) {\n  assert(\"TSIndexSignature\", node, opts);\n}\nfunction assertTSAnyKeyword(node, opts) {\n  assert(\"TSAnyKeyword\", node, opts);\n}\nfunction assertTSBooleanKeyword(node, opts) {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\nfunction assertTSBigIntKeyword(node, opts) {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\nfunction assertTSIntrinsicKeyword(node, opts) {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\nfunction assertTSNeverKeyword(node, opts) {\n  assert(\"TSNeverKeyword\", node, opts);\n}\nfunction assertTSNullKeyword(node, opts) {\n  assert(\"TSNullKeyword\", node, opts);\n}\nfunction assertTSNumberKeyword(node, opts) {\n  assert(\"TSNumberKeyword\", node, opts);\n}\nfunction assertTSObjectKeyword(node, opts) {\n  assert(\"TSObjectKeyword\", node, opts);\n}\nfunction assertTSStringKeyword(node, opts) {\n  assert(\"TSStringKeyword\", node, opts);\n}\nfunction assertTSSymbolKeyword(node, opts) {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\nfunction assertTSUndefinedKeyword(node, opts) {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\nfunction assertTSUnknownKeyword(node, opts) {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\nfunction assertTSVoidKeyword(node, opts) {\n  assert(\"TSVoidKeyword\", node, opts);\n}\nfunction assertTSThisType(node, opts) {\n  assert(\"TSThisType\", node, opts);\n}\nfunction assertTSFunctionType(node, opts) {\n  assert(\"TSFunctionType\", node, opts);\n}\nfunction assertTSConstructorType(node, opts) {\n  assert(\"TSConstructorType\", node, opts);\n}\nfunction assertTSTypeReference(node, opts) {\n  assert(\"TSTypeReference\", node, opts);\n}\nfunction assertTSTypePredicate(node, opts) {\n  assert(\"TSTypePredicate\", node, opts);\n}\nfunction assertTSTypeQuery(node, opts) {\n  assert(\"TSTypeQuery\", node, opts);\n}\nfunction assertTSTypeLiteral(node, opts) {\n  assert(\"TSTypeLiteral\", node, opts);\n}\nfunction assertTSArrayType(node, opts) {\n  assert(\"TSArrayType\", node, opts);\n}\nfunction assertTSTupleType(node, opts) {\n  assert(\"TSTupleType\", node, opts);\n}\nfunction assertTSOptionalType(node, opts) {\n  assert(\"TSOptionalType\", node, opts);\n}\nfunction assertTSRestType(node, opts) {\n  assert(\"TSRestType\", node, opts);\n}\nfunction assertTSNamedTupleMember(node, opts) {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\nfunction assertTSUnionType(node, opts) {\n  assert(\"TSUnionType\", node, opts);\n}\nfunction assertTSIntersectionType(node, opts) {\n  assert(\"TSIntersectionType\", node, opts);\n}\nfunction assertTSConditionalType(node, opts) {\n  assert(\"TSConditionalType\", node, opts);\n}\nfunction assertTSInferType(node, opts) {\n  assert(\"TSInferType\", node, opts);\n}\nfunction assertTSParenthesizedType(node, opts) {\n  assert(\"TSParenthesizedType\", node, opts);\n}\nfunction assertTSTypeOperator(node, opts) {\n  assert(\"TSTypeOperator\", node, opts);\n}\nfunction assertTSIndexedAccessType(node, opts) {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\nfunction assertTSMappedType(node, opts) {\n  assert(\"TSMappedType\", node, opts);\n}\nfunction assertTSTemplateLiteralType(node, opts) {\n  assert(\"TSTemplateLiteralType\", node, opts);\n}\nfunction assertTSLiteralType(node, opts) {\n  assert(\"TSLiteralType\", node, opts);\n}\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\nfunction assertTSInterfaceDeclaration(node, opts) {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\nfunction assertTSInterfaceBody(node, opts) {\n  assert(\"TSInterfaceBody\", node, opts);\n}\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nfunction assertTSInstantiationExpression(node, opts) {\n  assert(\"TSInstantiationExpression\", node, opts);\n}\nfunction assertTSAsExpression(node, opts) {\n  assert(\"TSAsExpression\", node, opts);\n}\nfunction assertTSSatisfiesExpression(node, opts) {\n  assert(\"TSSatisfiesExpression\", node, opts);\n}\nfunction assertTSTypeAssertion(node, opts) {\n  assert(\"TSTypeAssertion\", node, opts);\n}\nfunction assertTSEnumBody(node, opts) {\n  assert(\"TSEnumBody\", node, opts);\n}\nfunction assertTSEnumDeclaration(node, opts) {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\nfunction assertTSEnumMember(node, opts) {\n  assert(\"TSEnumMember\", node, opts);\n}\nfunction assertTSModuleDeclaration(node, opts) {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\nfunction assertTSModuleBlock(node, opts) {\n  assert(\"TSModuleBlock\", node, opts);\n}\nfunction assertTSImportType(node, opts) {\n  assert(\"TSImportType\", node, opts);\n}\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nfunction assertTSExternalModuleReference(node, opts) {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\nfunction assertTSNonNullExpression(node, opts) {\n  assert(\"TSNonNullExpression\", node, opts);\n}\nfunction assertTSExportAssignment(node, opts) {\n  assert(\"TSExportAssignment\", node, opts);\n}\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nfunction assertTSTypeAnnotation(node, opts) {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nfunction assertTSTypeParameter(node, opts) {\n  assert(\"TSTypeParameter\", node, opts);\n}\nfunction assertStandardized(node, opts) {\n  assert(\"Standardized\", node, opts);\n}\nfunction assertExpression(node, opts) {\n  assert(\"Expression\", node, opts);\n}\nfunction assertBinary(node, opts) {\n  assert(\"Binary\", node, opts);\n}\nfunction assertScopable(node, opts) {\n  assert(\"Scopable\", node, opts);\n}\nfunction assertBlockParent(node, opts) {\n  assert(\"BlockParent\", node, opts);\n}\nfunction assertBlock(node, opts) {\n  assert(\"Block\", node, opts);\n}\nfunction assertStatement(node, opts) {\n  assert(\"Statement\", node, opts);\n}\nfunction assertTerminatorless(node, opts) {\n  assert(\"Terminatorless\", node, opts);\n}\nfunction assertCompletionStatement(node, opts) {\n  assert(\"CompletionStatement\", node, opts);\n}\nfunction assertConditional(node, opts) {\n  assert(\"Conditional\", node, opts);\n}\nfunction assertLoop(node, opts) {\n  assert(\"Loop\", node, opts);\n}\nfunction assertWhile(node, opts) {\n  assert(\"While\", node, opts);\n}\nfunction assertExpressionWrapper(node, opts) {\n  assert(\"ExpressionWrapper\", node, opts);\n}\nfunction assertFor(node, opts) {\n  assert(\"For\", node, opts);\n}\nfunction assertForXStatement(node, opts) {\n  assert(\"ForXStatement\", node, opts);\n}\nfunction assertFunction(node, opts) {\n  assert(\"Function\", node, opts);\n}\nfunction assertFunctionParent(node, opts) {\n  assert(\"FunctionParent\", node, opts);\n}\nfunction assertPureish(node, opts) {\n  assert(\"Pureish\", node, opts);\n}\nfunction assertDeclaration(node, opts) {\n  assert(\"Declaration\", node, opts);\n}\nfunction assertFunctionParameter(node, opts) {\n  assert(\"FunctionParameter\", node, opts);\n}\nfunction assertPatternLike(node, opts) {\n  assert(\"PatternLike\", node, opts);\n}\nfunction assertLVal(node, opts) {\n  assert(\"LVal\", node, opts);\n}\nfunction assertTSEntityName(node, opts) {\n  assert(\"TSEntityName\", node, opts);\n}\nfunction assertLiteral(node, opts) {\n  assert(\"Literal\", node, opts);\n}\nfunction assertImmutable(node, opts) {\n  assert(\"Immutable\", node, opts);\n}\nfunction assertUserWhitespacable(node, opts) {\n  assert(\"UserWhitespacable\", node, opts);\n}\nfunction assertMethod(node, opts) {\n  assert(\"Method\", node, opts);\n}\nfunction assertObjectMember(node, opts) {\n  assert(\"ObjectMember\", node, opts);\n}\nfunction assertProperty(node, opts) {\n  assert(\"Property\", node, opts);\n}\nfunction assertUnaryLike(node, opts) {\n  assert(\"UnaryLike\", node, opts);\n}\nfunction assertPattern(node, opts) {\n  assert(\"Pattern\", node, opts);\n}\nfunction assertClass(node, opts) {\n  assert(\"Class\", node, opts);\n}\nfunction assertImportOrExportDeclaration(node, opts) {\n  assert(\"ImportOrExportDeclaration\", node, opts);\n}\nfunction assertExportDeclaration(node, opts) {\n  assert(\"ExportDeclaration\", node, opts);\n}\nfunction assertModuleSpecifier(node, opts) {\n  assert(\"ModuleSpecifier\", node, opts);\n}\nfunction assertAccessor(node, opts) {\n  assert(\"Accessor\", node, opts);\n}\nfunction assertPrivate(node, opts) {\n  assert(\"Private\", node, opts);\n}\nfunction assertFlow(node, opts) {\n  assert(\"Flow\", node, opts);\n}\nfunction assertFlowType(node, opts) {\n  assert(\"FlowType\", node, opts);\n}\nfunction assertFlowBaseAnnotation(node, opts) {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\nfunction assertFlowDeclaration(node, opts) {\n  assert(\"FlowDeclaration\", node, opts);\n}\nfunction assertFlowPredicate(node, opts) {\n  assert(\"FlowPredicate\", node, opts);\n}\nfunction assertEnumBody(node, opts) {\n  assert(\"EnumBody\", node, opts);\n}\nfunction assertEnumMember(node, opts) {\n  assert(\"EnumMember\", node, opts);\n}\nfunction assertJSX(node, opts) {\n  assert(\"JSX\", node, opts);\n}\nfunction assertMiscellaneous(node, opts) {\n  assert(\"Miscellaneous\", node, opts);\n}\nfunction assertTypeScript(node, opts) {\n  assert(\"TypeScript\", node, opts);\n}\nfunction assertTSTypeElement(node, opts) {\n  assert(\"TSTypeElement\", node, opts);\n}\nfunction assertTSType(node, opts) {\n  assert(\"TSType\", node, opts);\n}\nfunction assertTSBaseType(node, opts) {\n  assert(\"TSBaseType\", node, opts);\n}\nfunction assertNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"assertNumberLiteral\", \"assertNumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\nfunction assertRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)(\"assertRegexLiteral\", \"assertRegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\nfunction assertRestProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"assertRestProperty\", \"assertRestElement\");\n  assert(\"RestProperty\", node, opts);\n}\nfunction assertSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)(\"assertSpreadProperty\", \"assertSpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}\nfunction assertModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)(\"assertModuleDeclaration\", \"assertImportOrExportDeclaration\");\n  assert(\"ModuleDeclaration\", node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _index = require(\"../generated/index.js\");\nvar _default = exports.default = createTypeAnnotationBasedOnTypeof;\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  switch (type) {\n    case \"string\":\n      return (0, _index.stringTypeAnnotation)();\n    case \"number\":\n      return (0, _index.numberTypeAnnotation)();\n    case \"undefined\":\n      return (0, _index.voidTypeAnnotation)();\n    case \"boolean\":\n      return (0, _index.booleanTypeAnnotation)();\n    case \"function\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Function\"));\n    case \"object\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Object\"));\n    case \"symbol\":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)(\"Symbol\"));\n    case \"bigint\":\n      return (0, _index.anyTypeAnnotation)();\n  }\n  throw new Error(\"Invalid typeof value: \" + type);\n}\n\n//# sourceMappingURL=createTypeAnnotationBasedOnTypeof.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFlowUnionType;\nvar _index = require(\"../generated/index.js\");\nvar _removeTypeDuplicates = require(\"../../modifications/flow/removeTypeDuplicates.js\");\nfunction createFlowUnionType(types) {\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.unionTypeAnnotation)(flattened);\n  }\n}\n\n//# sourceMappingURL=createFlowUnionType.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\nvar _index = require(\"../../validators/generated/index.js\");\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n    if ((0, _index.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _index.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTSUnionType;\nvar _index = require(\"../generated/index.js\");\nvar _removeTypeDuplicates = require(\"../../modifications/typescript/removeTypeDuplicates.js\");\nvar _index2 = require(\"../../validators/generated/index.js\");\nfunction createTSUnionType(typeAnnotations) {\n  const types = typeAnnotations.map(type => {\n    return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;\n  });\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.tsUnionType)(flattened);\n  }\n}\n\n//# sourceMappingURL=createTSUnionType.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\nvar _index = require(\"../../validators/generated/index.js\");\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? \"this\" : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n    if ((0, _index.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    const typeArgumentsKey = \"typeParameters\";\n    if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {\n      const typeArguments = node[typeArgumentsKey];\n      const name = getQualifiedName(node.typeName);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        const existingTypeArguments = existing[typeArgumentsKey];\n        if (existingTypeArguments) {\n          existingTypeArguments.params.push(...typeArguments.params);\n          existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);\n        } else {\n          existing = typeArguments;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildUndefinedNode = buildUndefinedNode;\nvar _index = require(\"./generated/index.js\");\nfunction buildUndefinedNode() {\n  return (0, _index.unaryExpression)(\"void\", (0, _index.numericLiteral)(0), true);\n}\n\n//# sourceMappingURL=productions.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\nvar _index = require(\"../definitions/index.js\");\nvar _index2 = require(\"../validators/generated/index.js\");\nconst {\n  hasOwn\n} = {\n  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)\n};\nfunction cloneIfNode(obj, deep, withoutLoc, commentsCache) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n  return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\nfunction cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n  if ((0, _index2.isIdentifier)(node)) {\n    newNode.name = node.name;\n    if (hasOwn(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n    if (hasOwn(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;\n    }\n    if (hasOwn(node, \"decorators\")) {\n      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;\n    }\n  } else if (!hasOwn(_index.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_index.NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _index2.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n  if (hasOwn(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n  return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc, commentsCache) {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n    const {\n      type,\n      value,\n      loc\n    } = comment;\n    const ret = {\n      type,\n      value,\n      loc\n    };\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n    commentsCache.set(comment, ret);\n    return ret;\n  });\n}\n\n//# sourceMappingURL=cloneNode.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = clone;\nvar _cloneNode = require(\"./cloneNode.js\");\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}\n\n//# sourceMappingURL=clone.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneDeep;\nvar _cloneNode = require(\"./cloneNode.js\");\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}\n\n//# sourceMappingURL=cloneDeep.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneDeepWithoutLoc;\nvar _cloneNode = require(\"./cloneNode.js\");\nfunction cloneDeepWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, true, true);\n}\n\n//# sourceMappingURL=cloneDeepWithoutLoc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneWithoutLoc;\nvar _cloneNode = require(\"./cloneNode.js\");\nfunction cloneWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, false, true);\n}\n\n//# sourceMappingURL=cloneWithoutLoc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComment;\nvar _addComments = require(\"./addComments.js\");\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? \"CommentLine\" : \"CommentBlock\",\n    value: content\n  }]);\n}\n\n//# sourceMappingURL=addComment.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComments;\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  const key = `${type}Comments`;\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n  return node;\n}\n\n//# sourceMappingURL=addComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritInnerComments;\nvar _inherit = require(\"../utils/inherit.js\");\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)(\"innerComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritInnerComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherit;\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n  }\n}\n\n//# sourceMappingURL=inherit.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritLeadingComments;\nvar _inherit = require(\"../utils/inherit.js\");\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)(\"leadingComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritLeadingComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritsComments;\nvar _inheritTrailingComments = require(\"./inheritTrailingComments.js\");\nvar _inheritLeadingComments = require(\"./inheritLeadingComments.js\");\nvar _inheritInnerComments = require(\"./inheritInnerComments.js\");\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inheritsComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritTrailingComments;\nvar _inherit = require(\"../utils/inherit.js\");\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)(\"trailingComments\", child, parent);\n}\n\n//# sourceMappingURL=inheritTrailingComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeComments;\nvar _index = require(\"../constants/index.js\");\nfunction removeComments(node) {\n  _index.COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n  return node;\n}\n\n//# sourceMappingURL=removeComments.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTIONPARAMETER_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;\nvar _index = require(\"../../definitions/index.js\");\nconst STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Standardized\"];\nconst EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Expression\"];\nconst BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Binary\"];\nconst SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Scopable\"];\nconst BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nconst BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Block\"];\nconst STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Statement\"];\nconst TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nconst COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nconst CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Conditional\"];\nconst LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Loop\"];\nconst WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"While\"];\nconst EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nconst FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS[\"For\"];\nconst FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nconst FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Function\"];\nconst FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nconst PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Pureish\"];\nconst DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Declaration\"];\nconst FUNCTIONPARAMETER_TYPES = exports.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FunctionParameter\"];\nconst PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nconst LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"LVal\"];\nconst TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nconst LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Literal\"];\nconst IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Immutable\"];\nconst USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nconst METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Method\"];\nconst OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nconst PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Property\"];\nconst UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nconst PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Pattern\"];\nconst CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Class\"];\nconst IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ImportOrExportDeclaration\"];\nconst EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nconst MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nconst ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Accessor\"];\nconst PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Private\"];\nconst FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Flow\"];\nconst FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowType\"];\nconst FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nconst FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nconst FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nconst ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nconst ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nconst JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS[\"JSX\"];\nconst MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS[\"Miscellaneous\"];\nconst TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TypeScript\"];\nconst TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nconst TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSType\"];\nconst TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\nconst MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ensureBlock;\nvar _toBlock = require(\"./toBlock.js\");\nfunction ensureBlock(node, key = \"body\") {\n  const result = (0, _toBlock.default)(node[key], node);\n  node[key] = result;\n  return result;\n}\n\n//# sourceMappingURL=ensureBlock.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBlock;\nvar _index = require(\"../validators/generated/index.js\");\nvar _index2 = require(\"../builders/generated/index.js\");\nfunction toBlock(node, parent) {\n  if ((0, _index.isBlockStatement)(node)) {\n    return node;\n  }\n  let blockNodes = [];\n  if ((0, _index.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _index.isStatement)(node)) {\n      if ((0, _index.isFunction)(parent)) {\n        node = (0, _index2.returnStatement)(node);\n      } else {\n        node = (0, _index2.expressionStatement)(node);\n      }\n    }\n    blockNodes = [node];\n  }\n  return (0, _index2.blockStatement)(blockNodes);\n}\n\n//# sourceMappingURL=toBlock.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBindingIdentifierName;\nvar _toIdentifier = require(\"./toIdentifier.js\");\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\n//# sourceMappingURL=toBindingIdentifierName.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toIdentifier;\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier.js\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nfunction toIdentifier(input) {\n  input = input + \"\";\n  let name = \"\";\n  for (const c of input) {\n    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : \"-\";\n  }\n  name = name.replace(/^[-0-9]+/, \"\");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = `_${name}`;\n  }\n  return name || \"_\";\n}\n\n//# sourceMappingURL=toIdentifier.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toComputedKey;\nvar _index = require(\"../validators/generated/index.js\");\nvar _index2 = require(\"../builders/generated/index.js\");\nfunction toComputedKey(node, key = node.key || node.property) {\n  if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);\n  return key;\n}\n\n//# sourceMappingURL=toComputedKey.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _index = require(\"../validators/generated/index.js\");\nvar _default = exports.default = toExpression;\nfunction toExpression(node) {\n  if ((0, _index.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n  if ((0, _index.isExpression)(node)) {\n    return node;\n  }\n  if ((0, _index.isClass)(node)) {\n    node.type = \"ClassExpression\";\n    node.abstract = false;\n  } else if ((0, _index.isFunction)(node)) {\n    node.type = \"FunctionExpression\";\n  }\n  if (!(0, _index.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n  return node;\n}\n\n//# sourceMappingURL=toExpression.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toKeyAlias;\nvar _index = require(\"../validators/generated/index.js\");\nvar _cloneNode = require(\"../clone/cloneNode.js\");\nvar _removePropertiesDeep = require(\"../modifications/removePropertiesDeep.js\");\nfunction toKeyAlias(node, key = node.key) {\n  let alias;\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if ((0, _index.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _index.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n  return alias;\n}\ntoKeyAlias.uid = 0;\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\n//# sourceMappingURL=toKeyAlias.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removePropertiesDeep;\nvar _traverseFast = require(\"../traverse/traverseFast.js\");\nvar _removeProperties = require(\"./removeProperties.js\");\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}\n\n//# sourceMappingURL=removePropertiesDeep.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverseFast;\nvar _index = require(\"../definitions/index.js\");\nconst _skip = Symbol();\nconst _stop = Symbol();\nfunction traverseFast(node, enter, opts) {\n  if (!node) return false;\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return false;\n  opts = opts || {};\n  const ret = enter(node, opts);\n  if (ret !== undefined) {\n    switch (ret) {\n      case _skip:\n        return false;\n      case _stop:\n        return true;\n    }\n  }\n  for (const key of keys) {\n    const subNode = node[key];\n    if (!subNode) continue;\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        if (traverseFast(node, enter, opts)) return true;\n      }\n    } else {\n      if (traverseFast(subNode, enter, opts)) return true;\n    }\n  }\n  return false;\n}\ntraverseFast.skip = _skip;\ntraverseFast.stop = _stop;\n\n//# sourceMappingURL=traverseFast.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeProperties;\nvar _index = require(\"../constants/index.js\");\nconst CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\nconst CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, \"comments\", ...CLEAR_KEYS];\nfunction removeProperties(node, opts = {}) {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    if (node[key] != null) node[key] = undefined;\n  }\n  for (const key of Object.keys(node)) {\n    if (key.startsWith(\"_\") && node[key] != null) node[key] = undefined;\n  }\n  const symbols = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    node[sym] = null;\n  }\n}\n\n//# sourceMappingURL=removeProperties.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _index = require(\"../validators/generated/index.js\");\nvar _index2 = require(\"../builders/generated/index.js\");\nvar _default = exports.default = toStatement;\nfunction toStatement(node, ignore) {\n  if ((0, _index.isStatement)(node)) {\n    return node;\n  }\n  let mustHaveId = false;\n  let newType;\n  if ((0, _index.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _index.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _index.isAssignmentExpression)(node)) {\n    return (0, _index2.expressionStatement)(node);\n  }\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n  node.type = newType;\n  return node;\n}\n\n//# sourceMappingURL=toStatement.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier.js\");\nvar _index = require(\"../builders/generated/index.js\");\nvar _default = exports.default = valueToNode;\nconst objectToString = Function.call.bind(Object.prototype.toString);\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _index.identifier)(\"undefined\");\n  }\n  if (value === true || value === false) {\n    return (0, _index.booleanLiteral)(value);\n  }\n  if (value === null) {\n    return (0, _index.nullLiteral)();\n  }\n  if (typeof value === \"string\") {\n    return (0, _index.stringLiteral)(value);\n  }\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = (0, _index.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        numerator = (0, _index.numericLiteral)(0);\n      } else {\n        numerator = (0, _index.numericLiteral)(1);\n      }\n      result = (0, _index.binaryExpression)(\"/\", numerator, (0, _index.numericLiteral)(0));\n    }\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _index.unaryExpression)(\"-\", result);\n    }\n    return result;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < 0) {\n      return (0, _index.unaryExpression)(\"-\", (0, _index.bigIntLiteral)(-value));\n    } else {\n      return (0, _index.bigIntLiteral)(value);\n    }\n  }\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())[1];\n    return (0, _index.regExpLiteral)(pattern, flags);\n  }\n  if (Array.isArray(value)) {\n    return (0, _index.arrayExpression)(value.map(valueToNode));\n  }\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey,\n        computed = false;\n      if ((0, _isValidIdentifier.default)(key)) {\n        if (key === \"__proto__\") {\n          computed = true;\n          nodeKey = (0, _index.stringLiteral)(key);\n        } else {\n          nodeKey = (0, _index.identifier)(key);\n        }\n      } else {\n        nodeKey = (0, _index.stringLiteral)(key);\n      }\n      props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key]), computed));\n    }\n    return (0, _index.objectExpression)(props);\n  }\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n\n//# sourceMappingURL=valueToNode.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = appendToMemberExpression;\nvar _index = require(\"../builders/generated/index.js\");\nfunction appendToMemberExpression(member, append, computed = false) {\n  member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\n//# sourceMappingURL=appendToMemberExpression.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherits;\nvar _index = require(\"../constants/index.js\");\nvar _inheritsComments = require(\"../comments/inheritsComments.js\");\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n  for (const key of _index.INHERIT_KEYS.optional) {\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of Object.keys(parent)) {\n    if (key.startsWith(\"_\") && key !== \"__clone\") {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of _index.INHERIT_KEYS.force) {\n    child[key] = parent[key];\n  }\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inherits.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = prependToMemberExpression;\nvar _index = require(\"../builders/generated/index.js\");\nvar _index2 = require(\"../index.js\");\nfunction prependToMemberExpression(member, prepend) {\n  if ((0, _index2.isSuper)(member.object)) {\n    throw new Error(\"Cannot prepend node to super property access (`super.foo`).\");\n  }\n  member.object = (0, _index.memberExpression)(prepend, member.object);\n  return member;\n}\n\n//# sourceMappingURL=prependToMemberExpression.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getAssignmentIdentifiers;\nfunction getAssignmentIdentifiers(node) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n    switch (id.type) {\n      case \"ArrayPattern\":\n        search.push(...id.elements);\n        break;\n      case \"AssignmentExpression\":\n      case \"AssignmentPattern\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        search.push(id.left);\n        break;\n      case \"ObjectPattern\":\n        search.push(...id.properties);\n        break;\n      case \"ObjectProperty\":\n        search.push(id.value);\n        break;\n      case \"RestElement\":\n      case \"UpdateExpression\":\n        search.push(id.argument);\n        break;\n      case \"UnaryExpression\":\n        if (id.operator === \"delete\") {\n          search.push(id.argument);\n        }\n        break;\n      case \"Identifier\":\n        ids[id.name] = id;\n        break;\n      default:\n        break;\n    }\n  }\n  return ids;\n}\n\n//# sourceMappingURL=getAssignmentIdentifiers.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getBindingIdentifiers;\nvar _index = require(\"../validators/generated/index.js\");\nfunction getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {\n      continue;\n    }\n    if ((0, _index.isIdentifier)(id)) {\n      if (duplicates) {\n        const _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n    if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {\n      if ((0, _index.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n    if (outerOnly) {\n      if ((0, _index.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n      if ((0, _index.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n    const keys = getBindingIdentifiers.keys[id.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes = id[key];\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\nconst keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  TSImportEqualsDeclaration: [\"id\"],\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n  ObjectProperty: [\"value\"],\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};\ngetBindingIdentifiers.keys = keys;\n\n//# sourceMappingURL=getBindingIdentifiers.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _getBindingIdentifiers = require(\"./getBindingIdentifiers.js\");\nvar _default = exports.default = getOuterBindingIdentifiers;\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}\n\n//# sourceMappingURL=getOuterBindingIdentifiers.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getFunctionName;\nvar _index = require(\"../validators/generated/index.js\");\nfunction getNameFromLiteralId(id) {\n  if ((0, _index.isNullLiteral)(id)) {\n    return \"null\";\n  }\n  if ((0, _index.isRegExpLiteral)(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n  if ((0, _index.isTemplateLiteral)(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n  return null;\n}\nfunction getObjectMemberKey(node) {\n  if (!node.computed || (0, _index.isLiteral)(node.key)) {\n    return node.key;\n  }\n}\nfunction getFunctionName(node, parent) {\n  if (\"id\" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id\n    };\n  }\n  let prefix = \"\";\n  let id;\n  if ((0, _index.isObjectProperty)(parent, {\n    value: node\n  })) {\n    id = getObjectMemberKey(parent);\n  } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {\n    id = getObjectMemberKey(node);\n    if (node.kind === \"get\") prefix = \"get \";else if (node.kind === \"set\") prefix = \"set \";\n  } else if ((0, _index.isVariableDeclarator)(parent, {\n    init: node\n  })) {\n    id = parent.id;\n  } else if ((0, _index.isAssignmentExpression)(parent, {\n    operator: \"=\",\n    right: node\n  })) {\n    id = parent.left;\n  }\n  if (!id) return null;\n  const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;\n  if (name == null) return null;\n  return {\n    name: prefix + name,\n    originalNode: id\n  };\n}\n\n//# sourceMappingURL=getFunctionName.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nvar _index = require(\"../definitions/index.js\");\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === \"function\") {\n    handlers = {\n      enter: handlers\n    };\n  }\n  const {\n    enter,\n    exit\n  } = handlers;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n  for (const key of keys) {\n    const subNode = node[key];\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node,\n          key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n  if (exit) exit(node, ancestors, state);\n}\n\n//# sourceMappingURL=traverse.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBinding;\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers.js\");\nfunction isBinding(node, parent, grandparent) {\n  if (grandparent && node.type === \"Identifier\" && parent.type === \"ObjectProperty\" && grandparent.type === \"ObjectExpression\") {\n    return false;\n  }\n  const keys = _getBindingIdentifiers.default.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isBinding.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBlockScoped;\nvar _index = require(\"./generated/index.js\");\nvar _isLet = require(\"./isLet.js\");\nfunction isBlockScoped(node) {\n  return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}\n\n//# sourceMappingURL=isBlockScoped.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLet;\nvar _index = require(\"./generated/index.js\");\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nfunction isLet(node) {\n  return (0, _index.isVariableDeclaration)(node) && (node.kind !== \"var\" || node[BLOCK_SCOPED_SYMBOL]);\n}\n\n//# sourceMappingURL=isLet.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isImmutable;\nvar _isType = require(\"./isType.js\");\nvar _index = require(\"./generated/index.js\");\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, \"Immutable\")) return true;\n  if ((0, _index.isIdentifier)(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isImmutable.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNodesEquivalent;\nvar _index = require(\"../definitions/index.js\");\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== \"object\" || typeof b !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n  if (a.type !== b.type) {\n    return false;\n  }\n  const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = _index.VISITOR_KEYS[a.type];\n  for (const field of fields) {\n    const val_a = a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (typeof val_a === \"object\" && !(visitorKeys != null && visitorKeys.includes(field))) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=isNodesEquivalent.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isReferenced;\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n    case \"PrivateName\":\n      return false;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return (grandparent == null ? void 0 : grandparent.type) !== \"ObjectPattern\";\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n    case \"AssignmentPattern\":\n      return parent.right === node;\n    case \"LabeledStatement\":\n      return false;\n    case \"CatchClause\":\n      return false;\n    case \"RestElement\":\n      return false;\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n    case \"ExportSpecifier\":\n      if (grandparent != null && grandparent.source) {\n        return false;\n      }\n      return parent.local === node;\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n    case \"ImportAttribute\":\n      return false;\n    case \"JSXAttribute\":\n      return false;\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n    case \"MetaProperty\":\n      return false;\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n    case \"TSEnumMember\":\n      return parent.id !== node;\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n  }\n  return true;\n}\n\n//# sourceMappingURL=isReferenced.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isScope;\nvar _index = require(\"./generated/index.js\");\nfunction isScope(node, parent) {\n  if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return false;\n  }\n  if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return true;\n  }\n  return (0, _index.isScopable)(node);\n}\n\n//# sourceMappingURL=isScope.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isSpecifierDefault;\nvar _index = require(\"./generated/index.js\");\nfunction isSpecifierDefault(specifier) {\n  return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {\n    name: \"default\"\n  });\n}\n\n//# sourceMappingURL=isSpecifierDefault.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidES3Identifier;\nvar _isValidIdentifier = require(\"./isValidIdentifier.js\");\nconst RESERVED_WORDS_ES3_ONLY = new Set([\"abstract\", \"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"final\", \"float\", \"goto\", \"implements\", \"int\", \"interface\", \"long\", \"native\", \"package\", \"private\", \"protected\", \"public\", \"short\", \"static\", \"synchronized\", \"throws\", \"transient\", \"volatile\"]);\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n\n//# sourceMappingURL=isValidES3Identifier.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isVar;\nvar _index = require(\"./generated/index.js\");\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nfunction isVar(node) {\n  return (0, _index.isVariableDeclaration)(node, {\n    kind: \"var\"\n  }) && !node[BLOCK_SCOPED_SYMBOL];\n}\n\n//# sourceMappingURL=isVar.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toSequenceExpression;\nvar _gatherSequenceExpressions = require(\"./gatherSequenceExpressions.js\");\nfunction toSequenceExpression(nodes, scope) {\n  if (!(nodes != null && nodes.length)) return;\n  const declars = [];\n  const result = (0, _gatherSequenceExpressions.default)(nodes, declars);\n  if (!result) return;\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n  return result;\n}\n\n//# sourceMappingURL=toSequenceExpression.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = gatherSequenceExpressions;\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers.js\");\nvar _index = require(\"../validators/generated/index.js\");\nvar _index2 = require(\"../builders/generated/index.js\");\nvar _productions = require(\"../builders/productions.js\");\nvar _cloneNode = require(\"../clone/cloneNode.js\");\nfunction gatherSequenceExpressions(nodes, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!(0, _index.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n    if ((0, _index.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _index.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _index.isVariableDeclaration)(node)) {\n      if (node.kind !== \"var\") return;\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n        if (declar.init) {\n          exprs.push((0, _index2.assignmentExpression)(\"=\", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if ((0, _index.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _index.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _index.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) {\n    exprs.push((0, _productions.buildUndefinedNode)());\n  }\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _index2.sequenceExpression)(exprs);\n  }\n}\n\n//# sourceMappingURL=gatherSequenceExpressions.js.map\n"]}