{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(\"^7.0.0-0 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const {\n    types: t,\n    template\n  } = api;\n  function build(left, right) {\n    return t.callExpression(t.memberExpression(t.identifier(\"Math\"), t.identifier(\"pow\")), [left, right]);\n  }\n  function maybeMemoize(node, scope) {\n    if (scope.isStatic(node)) {\n      return {\n        assign: node,\n        ref: t.cloneNode(node)\n      };\n    }\n    if (scope.path.isPattern()) {\n      return null;\n    }\n    const id = scope.generateUidIdentifierBasedOnNode(node);\n    scope.push({\n      id\n    });\n    return {\n      assign: t.assignmentExpression(\"=\", t.cloneNode(id), node),\n      ref: t.cloneNode(id)\n    };\n  }\n  return {\n    name: \"transform-exponentiation-operator\",\n    visitor: {\n      AssignmentExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (node.operator !== \"**=\") return;\n        if (t.isMemberExpression(node.left)) {\n          let member1;\n          let member2;\n          const object = maybeMemoize(node.left.object, scope);\n          if (!object) {\n            path.replaceWith(template.expression.ast`(() => ${path.node})()`);\n            return;\n          }\n          const {\n            property,\n            computed\n          } = node.left;\n          if (computed) {\n            const prop = maybeMemoize(property, scope);\n            member1 = t.memberExpression(object.assign, prop.assign, true);\n            member2 = t.memberExpression(object.ref, prop.ref, true);\n          } else {\n            member1 = t.memberExpression(object.assign, property, false);\n            member2 = t.memberExpression(object.ref, t.cloneNode(property), false);\n          }\n          path.replaceWith(t.assignmentExpression(\"=\", member1, build(member2, node.right)));\n        } else {\n          path.replaceWith(t.assignmentExpression(\"=\", node.left, build(t.cloneNode(node.left), node.right)));\n        }\n      },\n      BinaryExpression(path) {\n        const {\n          node\n        } = path;\n        if (node.operator === \"**\") {\n          path.replaceWith(build(node.left, node.right));\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}