{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isForStatement({\n    test: node\n  }) || parentPath.isWhile({\n    test: node\n  });\n}\nfunction findOutermostTransparentParent(path) {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n\nconst last = arr => arr[arr.length - 1];\nfunction isSimpleMemberExpression(expression) {\n  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);\n  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n}\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const {\n    scope\n  } = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get(\"object\") : optionalPath.get(\"callee\"));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n    optionalPath = childPath;\n  }\n}\nconst NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);\nconst NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);\nconst NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);\nconst NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);\nfunction transformOptionalChain(path, {\n  pureGetters,\n  noDocumentAll\n}, replacementPath, ifNullish, wrapLast) {\n  const {\n    scope\n  } = path;\n  if (scope.path.isPattern() && needsMemoize(path)) {\n    replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node})()`);\n    return;\n  }\n  const optionals = [];\n  let optionalPath = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath.node.type = \"MemberExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath.node.type = \"CallExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n  if (optionals.length === 0) {\n    return;\n  }\n  const checks = [];\n  let tmpVar;\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n    const isCall = core.types.isCallExpression(node);\n    const chainWithTypes = isCall ? node.callee : node.object;\n    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);\n    let ref;\n    let check;\n    if (isCall && core.types.isIdentifier(chain, {\n      name: \"eval\"\n    })) {\n      check = ref = chain;\n      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      check = ref = node.callee;\n    } else if (scope.isStatic(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      if (!tmpVar || isCall) {\n        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);\n        scope.push({\n          id: core.types.cloneNode(tmpVar)\n        });\n      }\n      ref = tmpVar;\n      check = core.types.assignmentExpression(\"=\", core.types.cloneNode(tmpVar), chainWithTypes);\n      if (isCall) {\n        node.callee = ref;\n      } else {\n        node.object = ref;\n      }\n    }\n    if (isCall && core.types.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        node.callee = chainWithTypes;\n      } else {\n        const {\n          object\n        } = chain;\n        let context;\n        if (core.types.isSuper(object)) {\n          context = core.types.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = core.types.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n        node.arguments.unshift(core.types.cloneNode(context));\n        node.callee = core.types.memberExpression(node.callee, core.types.identifier(\"call\"));\n      }\n    }\n    const data = {\n      check: core.types.cloneNode(check),\n      ref: core.types.cloneNode(ref)\n    };\n    Object.defineProperty(data, \"ref\", {\n      enumerable: false\n    });\n    checks.push(data);\n  }\n  let result = replacementPath.node;\n  if (wrapLast) result = wrapLast(result);\n  const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);\n  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;\n  const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {\n    operator: \"void\"\n  });\n  const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;\n  const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;\n  const logicalOp = ifNullishFalse ? \"&&\" : \"||\";\n  const check = checks.map(tpl).reduce((expr, check) => core.types.logicalExpression(logicalOp, expr, check));\n  replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));\n}\nfunction transform(path, assumptions) {\n  const {\n    scope\n  } = path;\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isUnaryExpression({\n    operator: \"delete\"\n  })) {\n    transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));\n  } else {\n    let wrapLast;\n    if (parentPath.isCallExpression({\n      callee: maybeWrapped.node\n    }) && path.isOptionalMemberExpression()) {\n      wrapLast = replacement => {\n        const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);\n        let baseRef;\n        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {\n          baseRef = scope.maybeGenerateMemoised(object);\n          if (baseRef) {\n            replacement.object = core.types.assignmentExpression(\"=\", baseRef, object);\n          }\n        }\n        return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier(\"bind\")), [core.types.cloneNode(baseRef != null ? baseRef : object)]);\n      };\n    }\n    transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);\n  }\n}\n\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(\"^7.0.0-0 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const {\n    loose = false\n  } = options;\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : loose;\n  return {\n    name: \"transform-optional-chaining\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"optionalChaining\"),\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, {\n          noDocumentAll,\n          pureGetters\n        });\n      }\n    }\n  };\n});\n\nexports.default = index;\nexports.transform = transform;\nexports.transformOptionalChain = transformOptionalChain;\n//# sourceMappingURL=index.js.map\n"]}