{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _core = require(\"@babel/core\");\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _template = require(\"@babel/template\");\nvar DefineAccessorHelper = _template.default.expression.ast`\n    function (type, obj, key, fn) {\n      var desc = { configurable: true, enumerable: true };\n      desc[type] = fn;\n      return Object.defineProperty(obj, key, desc);\n    }\n  `;\nDefineAccessorHelper._compact = true;\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption;\n  api.assertVersion(7);\n  const setComputedProperties = (_api$assumption = api.assumption(\"setComputedProperties\")) != null ? _api$assumption : options.loose;\n  const pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;\n  function buildDefineAccessor(state, obj, prop) {\n    const type = prop.kind;\n    const key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;\n    const fn = getValue(prop);\n    let helper;\n    if (state.availableHelper(\"defineAccessor\")) {\n      helper = state.addHelper(\"defineAccessor\");\n    } else {\n      const file = state.file;\n      helper = file.get(\"fallbackDefineAccessorHelper\");\n      if (!helper) {\n        const id = file.scope.generateUidIdentifier(\"defineAccessor\");\n        file.scope.push({\n          id,\n          init: DefineAccessorHelper\n        });\n        file.set(\"fallbackDefineAccessorHelper\", helper = id);\n      }\n      helper = _core.types.cloneNode(helper);\n    }\n    return _core.types.callExpression(helper, [_core.types.stringLiteral(type), obj, key, fn]);\n  }\n  function getValue(prop) {\n    if (_core.types.isObjectProperty(prop)) {\n      return prop.value;\n    } else if (_core.types.isObjectMethod(prop)) {\n      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);\n    }\n  }\n  function pushAssign(objId, prop, body) {\n    body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));\n  }\n  function pushComputedPropsLoose(info) {\n    const {\n      computedProps,\n      state,\n      initPropExpression,\n      objId,\n      body\n    } = info;\n    for (const prop of computedProps) {\n      if (_core.types.isObjectMethod(prop) && (prop.kind === \"get\" || prop.kind === \"set\")) {\n        if (computedProps.length === 1) {\n          return buildDefineAccessor(state, initPropExpression, prop);\n        } else {\n          body.push(_core.types.expressionStatement(buildDefineAccessor(state, _core.types.cloneNode(objId), prop)));\n        }\n      } else {\n        pushAssign(_core.types.cloneNode(objId), prop, body);\n      }\n    }\n  }\n  function pushComputedPropsSpec(info) {\n    const {\n      objId,\n      body,\n      computedProps,\n      state\n    } = info;\n    const CHUNK_LENGTH_CAP = 10;\n    let currentChunk = null;\n    const computedPropsChunks = [];\n    for (const prop of computedProps) {\n      if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {\n        currentChunk = [];\n        computedPropsChunks.push(currentChunk);\n      }\n      currentChunk.push(prop);\n    }\n    for (const chunk of computedPropsChunks) {\n      const single = computedPropsChunks.length === 1;\n      let node = single ? info.initPropExpression : _core.types.cloneNode(objId);\n      for (const prop of chunk) {\n        if (_core.types.isObjectMethod(prop) && (prop.kind === \"get\" || prop.kind === \"set\")) {\n          node = buildDefineAccessor(info.state, node, prop);\n        } else {\n          node = _core.types.callExpression(state.addHelper(\"defineProperty\"), [node, _core.types.toComputedKey(prop), getValue(prop)]);\n        }\n      }\n      if (single) return node;\n      body.push(_core.types.expressionStatement(node));\n    }\n  }\n  return {\n    name: \"transform-computed-properties\",\n    visitor: {\n      ObjectExpression: {\n        exit(path, state) {\n          const {\n            node,\n            parent,\n            scope\n          } = path;\n          let hasComputed = false;\n          for (const prop of node.properties) {\n            hasComputed = prop.computed === true;\n            if (hasComputed) break;\n          }\n          if (!hasComputed) return;\n          const initProps = [];\n          const computedProps = [];\n          let foundComputed = false;\n          for (const prop of node.properties) {\n            if (_core.types.isSpreadElement(prop)) {\n              continue;\n            }\n            if (prop.computed) {\n              foundComputed = true;\n            }\n            if (foundComputed) {\n              computedProps.push(prop);\n            } else {\n              initProps.push(prop);\n            }\n          }\n          const objId = scope.generateUidIdentifierBasedOnNode(parent);\n          const initPropExpression = _core.types.objectExpression(initProps);\n          const body = [];\n          body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(objId, initPropExpression)]));\n          const single = pushComputedProps({\n            scope,\n            objId,\n            body,\n            computedProps,\n            initPropExpression,\n            state\n          });\n          if (single) {\n            path.replaceWith(single);\n          } else {\n            if (setComputedProperties) {\n              body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));\n            }\n            path.replaceWithMultiple(body);\n          }\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}