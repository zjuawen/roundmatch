{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getExportSpecifierName = getExportSpecifierName;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _core = require(\"@babel/core\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nconst buildTemplate = _core.template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\nconst buildExportAll = _core.template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-transform-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-transform-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\nfunction getExportSpecifierName(node, stringSpecifiers) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);\n  }\n}\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {\n  const statements = [];\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n    } else {\n      const objectProperties = [];\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));\n      }\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n  return statements;\n}\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const reassignmentVisited = new WeakSet();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n      const arg = path.isAssignmentExpression() ? path.get(\"left\") : path.get(\"argument\");\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n      const isPostUpdateExpression = _core.types.isUpdateExpression(node, {\n        prefix: false\n      });\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n      path.replaceWith(node);\n    }\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n    visitor: {\n      [\"CallExpression\" + (api.types.importExpression ? \"|ImportExpression\" : \"\")](path, state) {\n        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;\n        if (path.isCallExpression()) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n        } else {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            throw new Error(MISSING_PLUGIN_ERROR);\n          }\n        }\n        path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, true, specifier => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [specifier])));\n      },\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const {\n            contextIdent,\n            stringSpecifiers\n          } = state;\n          const exportMap = Object.create(null);\n          const modules = [];\n          const beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n            module[key] = module[key].concat(specifiers);\n          }\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(_core.types.cloneNode(path.node.id));\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isVariableDeclaration()) {\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n              if (_core.types.isClassDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (_core.types.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                }\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n              if (declar) {\n                path.replaceWith(declar);\n                if (_core.types.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (_core.types.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(declar.id));\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));\n                  addExportName(name, name);\n                } else {\n                  if (_core.types.isVariableDeclaration(declar)) {\n                    declar.kind = \"var\";\n                  }\n                  for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n                if (specifiers != null && specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n                    for (const specifier of specifiers) {\n                      const {\n                        local,\n                        exported\n                      } = specifier;\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(exportedName);\n                        exportValues.push(_core.types.cloneNode(local));\n                      } else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n                      addExportName(local.name, exportedName);\n                    }\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n              if (_core.types.isImportSpecifier(specifier)) {\n                const {\n                  imported\n                } = specifier;\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === \"StringLiteral\"))));\n              }\n            }\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);\n                  exportNames.push(exportedName);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));\n                } else {}\n              }\n              setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));\n            }\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          {\n            var _path$scope, _path$scope$hoistVari;\n            (_path$scope$hoistVari = (_path$scope = path.scope).hoistVariables) != null ? _path$scope$hoistVari : _path$scope.hoistVariables = require(\"@babel/traverse\").Scope.prototype.hoistVariables;\n          }\n          path.scope.hoistVariables((id, hasInit) => {\n            variableIds.push(id);\n            if (!hasInit && id.name in exportMap) {\n              for (const exported of exportMap[id.name]) {\n                exportNames.push(exported);\n                exportValues.push(_core.types.buildUndefinedNode());\n              }\n            }\n          });\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n          if (exportNames.length) {\n            beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));\n          }\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope\n          });\n          for (const path of removedPaths) {\n            path.remove();\n          }\n          let hasTLA = false;\n          {\n            path.traverse({\n              AwaitExpression(path) {\n                hasTLA = true;\n                path.stop();\n              },\n              Function(path) {\n                path.skip();\n              },\n              noScope: true\n            });\n          }\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),\n            SOURCES: _core.types.arrayExpression(sources),\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n          path.requeue(path.get(\"body.0\"));\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}