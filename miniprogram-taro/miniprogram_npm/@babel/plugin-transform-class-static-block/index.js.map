{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nfunction generateUid(scope, denyList) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n  do {\n    uid = `_${name}`;\n    if (i > 1) uid += i;\n    i++;\n  } while (denyList.has(uid));\n  return uid;\n}\nfunction mapLast(arr, fn) {\n  if (arr.length === 0) return arr;\n  return [...arr.slice(0, -1), fn(arr[arr.length - 1])];\n}\nvar _default = exports.default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  template,\n  traverse,\n  assertVersion\n}) => {\n  assertVersion(\"^7.12.0 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const rawNamedEvaluationVisitor = (0, _helperCreateClassFeaturesPlugin.buildNamedEvaluationVisitor)(path => {\n    if (!path.isClassExpression()) return false;\n    for (let i = path.node.body.body.length - 1; i >= 0; i--) {\n      const el = path.node.body.body[i];\n      if (t.isStaticBlock(el)) {\n        return true;\n      }\n      if ((t.isClassProperty(el) || t.isClassPrivateProperty(el)) && el.static) {\n        break;\n      }\n    }\n    return false;\n  }, (classPath, state, name) => {\n    const nameNode = typeof name === \"string\" ? t.stringLiteral(name) : name;\n    classPath.get(\"body\").unshiftContainer(\"body\", t.staticBlock([template.statement.ast`\n            ${state.addHelper(\"setFunctionName\")}(this, ${nameNode});\n          `]));\n  });\n  if (!t.classAccessorProperty) {\n    delete rawNamedEvaluationVisitor.ClassAccessorProperty;\n  }\n  const namedEvaluationVisitor = traverse.visitors.explode(rawNamedEvaluationVisitor);\n  const maybeSequenceExpression = expressions => {\n    if (expressions.length === 1) {\n      return expressions[0];\n    } else {\n      return t.sequenceExpression(expressions);\n    }\n  };\n  const blocksToExpressions = blocks => blocks.map(block => {\n    const {\n      body\n    } = block;\n    if (body.length === 1 && t.isExpressionStatement(body[0])) {\n      return t.inheritsComments(t.inheritsComments(body[0].expression, body[0]), block);\n    }\n    return t.inheritsComments(template.expression.ast`(() => { ${body} })()`, block);\n  });\n  const prependToInitializer = (prop, expressions) => {\n    prop.value = prop.value ? t.sequenceExpression([...expressions, prop.value]) : maybeSequenceExpression(mapLast(expressions, expr => t.unaryExpression(\"void\", expr)));\n  };\n  return {\n    name: \"transform-class-static-block\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"classStaticBlock\"),\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);\n    },\n    visitor: {\n      ClassBody(classBody) {\n        const {\n          scope\n        } = classBody;\n        let parentPath = classBody.parentPath;\n        if (parentPath.isClassExpression() && !parentPath.node.id) {\n          do ({\n            parentPath\n          } = parentPath); while (parentPath && !namedEvaluationVisitor[parentPath.type] && !parentPath.isStatement());\n          if (parentPath) {\n            var _namedEvaluationVisit;\n            (_namedEvaluationVisit = namedEvaluationVisitor[parentPath.type]) == null || _namedEvaluationVisit.enter.forEach(f => f.call(this, parentPath, this));\n          }\n        }\n        const pendingStaticBlocks = [];\n        let lastStaticProp = null;\n        for (const path of classBody.get(\"body\")) {\n          if (path.isStaticBlock()) {\n            pendingStaticBlocks.push(path.node);\n            path.remove();\n          } else if (path.isClassProperty({\n            static: true\n          }) || path.isClassPrivateProperty({\n            static: true\n          })) {\n            lastStaticProp = path;\n            if (pendingStaticBlocks.length > 0) {\n              prependToInitializer(path.node, blocksToExpressions(pendingStaticBlocks));\n              pendingStaticBlocks.length = 0;\n            }\n          }\n        }\n        if (pendingStaticBlocks.length > 0) {\n          const tmp = scope.generateDeclaredUidIdentifier(\"staticBlock\");\n          let arrowBody;\n          const needsCompletionValue = classBody.parentPath.isExpression();\n          if (pendingStaticBlocks.length > 1 || pendingStaticBlocks[0].body.length === 1 && t.isExpressionStatement(pendingStaticBlocks[0].body[0])) {\n            const expressions = blocksToExpressions(pendingStaticBlocks);\n            if (needsCompletionValue) {\n              expressions.push(t.thisExpression());\n            }\n            arrowBody = maybeSequenceExpression(expressions);\n          } else {\n            arrowBody = t.blockStatement(pendingStaticBlocks[0].body);\n            if (needsCompletionValue) {\n              arrowBody.body.push(t.returnStatement(t.thisExpression()));\n            }\n          }\n          const init = template.expression.ast`${tmp} = () => ${arrowBody}`;\n          if (lastStaticProp) {\n            prependToInitializer(lastStaticProp.node, [init]);\n          } else {\n            const privateNames = new Set();\n            for (const path of classBody.get(\"body\")) {\n              if (path.isPrivate()) {\n                privateNames.add(path.get(\"key.id\").node.name);\n              }\n            }\n            const staticBlockPrivateId = generateUid(scope, privateNames);\n            const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));\n            classBody.pushContainer(\"body\", [t.classPrivateProperty(staticBlockRef, init, [], true)]);\n          }\n          const staticBlockClosureCall = t.callExpression(t.cloneNode(tmp), []);\n          if (classBody.parentPath.isClassExpression()) {\n            classBody.parentPath.replaceWith(t.sequenceExpression([classBody.parent, staticBlockClosureCall]));\n          } else {\n            classBody.parentPath.insertAfter(t.expressionStatement(staticBlockClosureCall));\n          }\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}