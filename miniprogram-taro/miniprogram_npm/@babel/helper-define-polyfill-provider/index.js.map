{"version":3,"sources":["index.js","utils.js","imports-injector.js","debug-utils.js","normalize-options.js","visitors/index.js","visitors/usage.js","visitors/entry.js","node/dependencies.js","meta-resolver.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA;AELA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA;AFOA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AIZA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AHUA,ADGA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AJaA,AFMA,AIZA,AHSA,AMlBA,AFMA,ACHA;AJaA,AFMA,AQxBA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AQxBA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AQxBA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AMlBA,ADGA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AS3BA,ADGA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,AJYA,AHSA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,AQxBA,APqBA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;AJaA,AFMA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA,AKfA;ANmBA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.default = definePolyfillProvider;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperCompilationTargets = _interopRequireWildcard(require(\"@babel/helper-compilation-targets\"));\nvar _utils = require(\"./utils\");\nvar _importsInjector = _interopRequireDefault(require(\"./imports-injector\"));\nvar _debugUtils = require(\"./debug-utils\");\nvar _normalizeOptions = require(\"./normalize-options\");\nvar v = _interopRequireWildcard(require(\"./visitors\"));\nvar deps = _interopRequireWildcard(require(\"./node/dependencies\"));\nvar _metaResolver = _interopRequireDefault(require(\"./meta-resolver\"));\nconst _excluded = [\"method\", \"targets\", \"ignoreBrowserslistConfig\", \"configPath\", \"debug\", \"shouldInjectPolyfill\", \"absoluteImports\"];\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nconst getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;\nfunction resolveOptions(options, babelApi) {\n  const {\n      method,\n      targets: targetsOption,\n      ignoreBrowserslistConfig,\n      configPath,\n      debug,\n      shouldInjectPolyfill,\n      absoluteImports\n    } = options,\n    providerOptions = _objectWithoutPropertiesLoose(options, _excluded);\n  if (isEmpty(options)) {\n    throw new Error(`\\\nThis plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);\n  }\n  let methodName;\n  if (method === \"usage-global\") methodName = \"usageGlobal\";else if (method === \"entry-global\") methodName = \"entryGlobal\";else if (method === \"usage-pure\") methodName = \"usagePure\";else if (typeof method !== \"string\") {\n    throw new Error(\".method must be a string\");\n  } else {\n    throw new Error(`.method must be one of \"entry-global\", \"usage-global\"` + ` or \"usage-pure\" (received ${JSON.stringify(method)})`);\n  }\n  if (typeof shouldInjectPolyfill === \"function\") {\n    if (options.include || options.exclude) {\n      throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`);\n    }\n  } else if (shouldInjectPolyfill != null) {\n    throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`);\n  }\n  if (absoluteImports != null && typeof absoluteImports !== \"boolean\" && typeof absoluteImports !== \"string\") {\n    throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`);\n  }\n  let targets;\n  if (\n  // If any browserslist-related option is specified, fallback to the old\n  // behavior of not using the targets specified in the top-level options.\n  targetsOption || configPath || ignoreBrowserslistConfig) {\n    const targetsObj = typeof targetsOption === \"string\" || Array.isArray(targetsOption) ? {\n      browsers: targetsOption\n    } : targetsOption;\n    targets = getTargets(targetsObj, {\n      ignoreBrowserslistConfig,\n      configPath\n    });\n  } else {\n    targets = babelApi.targets();\n  }\n  return {\n    method,\n    methodName,\n    targets,\n    absoluteImports: absoluteImports != null ? absoluteImports : false,\n    shouldInjectPolyfill,\n    debug: !!debug,\n    providerOptions: providerOptions\n  };\n}\nfunction instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {\n  const {\n    method,\n    methodName,\n    targets,\n    debug,\n    shouldInjectPolyfill,\n    providerOptions,\n    absoluteImports\n  } = resolveOptions(options, babelApi);\n\n  // eslint-disable-next-line prefer-const\n  let include, exclude;\n  let polyfillsSupport;\n  let polyfillsNames;\n  let filterPolyfills;\n  const getUtils = (0, _utils.createUtilsGetter)(new _importsInjector.default(moduleName => deps.resolve(dirname, moduleName, absoluteImports), name => {\n    var _polyfillsNames$get, _polyfillsNames;\n    return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;\n  }));\n  const depsCache = new Map();\n  const api = {\n    babel: babelApi,\n    getUtils,\n    method: options.method,\n    targets,\n    createMetaResolver: _metaResolver.default,\n    shouldInjectPolyfill(name) {\n      if (polyfillsNames === undefined) {\n        throw new Error(`Internal error in the ${factory.name} provider: ` + `shouldInjectPolyfill() can't be called during initialization.`);\n      }\n      if (!polyfillsNames.has(name)) {\n        console.warn(`Internal error in the ${providerName} provider: ` + `unknown polyfill \"${name}\".`);\n      }\n      if (filterPolyfills && !filterPolyfills(name)) return false;\n      let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {\n        compatData: polyfillsSupport,\n        includes: include,\n        excludes: exclude\n      });\n      if (shouldInjectPolyfill) {\n        shouldInject = shouldInjectPolyfill(name, shouldInject);\n        if (typeof shouldInject !== \"boolean\") {\n          throw new Error(`.shouldInjectPolyfill must return a boolean.`);\n        }\n      }\n      return shouldInject;\n    },\n    debug(name) {\n      var _debugLog, _debugLog$polyfillsSu;\n      debugLog().found = true;\n      if (!debug || !name) return;\n      if (debugLog().polyfills.has(providerName)) return;\n      debugLog().polyfills.add(name);\n      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;\n    },\n    assertDependency(name, version = \"*\") {\n      if (missingDependencies === false) return;\n      if (absoluteImports) {\n        // If absoluteImports is not false, we will try resolving\n        // the dependency and throw if it's not possible. We can\n        // skip the check here.\n        return;\n      }\n      const dep = version === \"*\" ? name : `${name}@^${version}`;\n      const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, () => deps.has(dirname, name));\n      if (!found) {\n        debugLog().missingDeps.add(dep);\n      }\n    }\n  };\n  const provider = factory(api, providerOptions, dirname);\n  const providerName = provider.name || factory.name;\n  if (typeof provider[methodName] !== \"function\") {\n    throw new Error(`The \"${providerName}\" provider doesn't support the \"${method}\" polyfilling method.`);\n  }\n  if (Array.isArray(provider.polyfills)) {\n    polyfillsNames = new Map(provider.polyfills.map((name, index) => [name, index]));\n    filterPolyfills = provider.filterPolyfills;\n  } else if (provider.polyfills) {\n    polyfillsNames = new Map(Object.keys(provider.polyfills).map((name, index) => [name, index]));\n    polyfillsSupport = provider.polyfills;\n    filterPolyfills = provider.filterPolyfills;\n  } else {\n    polyfillsNames = new Map();\n  }\n  ({\n    include,\n    exclude\n  } = (0, _normalizeOptions.validateIncludeExclude)(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));\n  let callProvider;\n  if (methodName === \"usageGlobal\") {\n    callProvider = (payload, path) => {\n      var _ref;\n      const utils = getUtils(path);\n      return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;\n    };\n  } else {\n    callProvider = (payload, path) => {\n      const utils = getUtils(path);\n      provider[methodName](payload, utils, path);\n      return false;\n    };\n  }\n  return {\n    debug,\n    method,\n    targets,\n    provider,\n    providerName,\n    callProvider\n  };\n}\nfunction definePolyfillProvider(factory) {\n  return (0, _helperPluginUtils.declare)((babelApi, options, dirname) => {\n    babelApi.assertVersion(\"^7.0.0 || ^8.0.0-alpha.0\");\n    const {\n      traverse\n    } = babelApi;\n    let debugLog;\n    const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);\n    const {\n      debug,\n      method,\n      targets,\n      provider,\n      providerName,\n      callProvider\n    } = instantiateProvider(factory, options, missingDependencies, dirname, () => debugLog, babelApi);\n    const createVisitor = method === \"entry-global\" ? v.entry : v.usage;\n    const visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);\n    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {\n      console.log(`${providerName}: \\`DEBUG\\` option`);\n      console.log(`\\nUsing targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`);\n      console.log(`\\nUsing polyfills with \\`${method}\\` method:`);\n    }\n    const {\n      runtimeName\n    } = provider;\n    return {\n      name: \"inject-polyfills\",\n      visitor,\n      pre(file) {\n        var _provider$pre;\n        if (runtimeName) {\n          if (file.get(\"runtimeHelpersModuleName\") && file.get(\"runtimeHelpersModuleName\") !== runtimeName) {\n            console.warn(`Two different polyfill providers` + ` (${file.get(\"runtimeHelpersModuleProvider\")}` + ` and ${providerName}) are trying to define two` + ` conflicting @babel/runtime alternatives:` + ` ${file.get(\"runtimeHelpersModuleName\")} and ${runtimeName}.` + ` The second one will be ignored.`);\n          } else {\n            file.set(\"runtimeHelpersModuleName\", runtimeName);\n            file.set(\"runtimeHelpersModuleProvider\", providerName);\n          }\n        }\n        debugLog = {\n          polyfills: new Set(),\n          polyfillsSupport: undefined,\n          found: false,\n          providers: new Set(),\n          missingDeps: new Set()\n        };\n        (_provider$pre = provider.pre) == null || _provider$pre.apply(this, arguments);\n      },\n      post() {\n        var _provider$post;\n        (_provider$post = provider.post) == null || _provider$post.apply(this, arguments);\n        if (missingDependencies !== false) {\n          if (missingDependencies.log === \"per-file\") {\n            deps.logMissing(debugLog.missingDeps);\n          } else {\n            deps.laterLogMissing(debugLog.missingDeps);\n          }\n        }\n        if (!debug) return;\n        if (this.filename) console.log(`\\n[${this.filename}]`);\n        if (debugLog.polyfills.size === 0) {\n          console.log(method === \"entry-global\" ? debugLog.found ? `Based on your targets, the ${providerName} polyfill did not add any polyfill.` : `The entry point for the ${providerName} polyfill has not been found.` : `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`);\n          return;\n        }\n        if (method === \"entry-global\") {\n          console.log(`The ${providerName} polyfill entry has been replaced with ` + `the following polyfills:`);\n        } else {\n          console.log(`The ${providerName} polyfill added the following polyfills:`);\n        }\n        for (const name of debugLog.polyfills) {\n          var _debugLog$polyfillsSu2;\n          if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {\n            const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);\n            const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n            console.log(`  ${name} ${formattedTargets}`);\n          } else {\n            console.log(`  ${name}`);\n          }\n        }\n      }\n    };\n  });\n}\nfunction mapGetOr(map, key, getDefault) {\n  let val = map.get(key);\n  if (val === undefined) {\n    val = getDefault();\n    map.set(key, val);\n  }\n  return val;\n}\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}","\n\nexports.__esModule = true;\nexports.createUtilsGetter = createUtilsGetter;\nexports.getImportSource = getImportSource;\nexports.getRequireSource = getRequireSource;\nexports.has = has;\nexports.intersection = intersection;\nexports.resolveKey = resolveKey;\nexports.resolveSource = resolveSource;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nconst {\n  types: t,\n  template: template\n} = _babel.default || _babel;\nfunction intersection(a, b) {\n  const result = new Set();\n  a.forEach(v => b.has(v) && result.add(v));\n  return result;\n}\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\nfunction resolve(path, resolved = new Set()) {\n  if (resolved.has(path)) return;\n  resolved.add(path);\n  if (path.isVariableDeclarator()) {\n    if (path.get(\"id\").isIdentifier()) {\n      return resolve(path.get(\"init\"), resolved);\n    }\n  } else if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return path;\n    if (!binding.constant) return;\n    return resolve(binding.path, resolved);\n  }\n  return path;\n}\nfunction resolveId(path) {\n  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, /* noGlobals */true)) {\n    return path.node.name;\n  }\n  const resolved = resolve(path);\n  if (resolved != null && resolved.isIdentifier()) {\n    return resolved.node.name;\n  }\n}\nfunction resolveKey(path, computed = false) {\n  const {\n    scope\n  } = path;\n  if (path.isStringLiteral()) return path.node.value;\n  const isIdentifier = path.isIdentifier();\n  if (isIdentifier && !(computed || path.parent.computed)) {\n    return path.node.name;\n  }\n  if (computed && path.isMemberExpression() && path.get(\"object\").isIdentifier({\n    name: \"Symbol\"\n  }) && !scope.hasBinding(\"Symbol\", /* noGlobals */true)) {\n    const sym = resolveKey(path.get(\"property\"), path.node.computed);\n    if (sym) return \"Symbol.\" + sym;\n  }\n  if (isIdentifier ? scope.hasBinding(path.node.name, /* noGlobals */true) : path.isPure()) {\n    const {\n      value\n    } = path.evaluate();\n    if (typeof value === \"string\") return value;\n  }\n}\nfunction resolveSource(obj) {\n  if (obj.isMemberExpression() && obj.get(\"property\").isIdentifier({\n    name: \"prototype\"\n  })) {\n    const id = resolveId(obj.get(\"object\"));\n    if (id) {\n      return {\n        id,\n        placement: \"prototype\"\n      };\n    }\n    return {\n      id: null,\n      placement: null\n    };\n  }\n  const id = resolveId(obj);\n  if (id) {\n    return {\n      id,\n      placement: \"static\"\n    };\n  }\n  const path = resolve(obj);\n  switch (path == null ? void 0 : path.type) {\n    case \"RegExpLiteral\":\n      return {\n        id: \"RegExp\",\n        placement: \"prototype\"\n      };\n    case \"FunctionExpression\":\n      return {\n        id: \"Function\",\n        placement: \"prototype\"\n      };\n    case \"StringLiteral\":\n      return {\n        id: \"String\",\n        placement: \"prototype\"\n      };\n    case \"NumberLiteral\":\n      return {\n        id: \"Number\",\n        placement: \"prototype\"\n      };\n    case \"BooleanLiteral\":\n      return {\n        id: \"Boolean\",\n        placement: \"prototype\"\n      };\n    case \"ObjectExpression\":\n      return {\n        id: \"Object\",\n        placement: \"prototype\"\n      };\n    case \"ArrayExpression\":\n      return {\n        id: \"Array\",\n        placement: \"prototype\"\n      };\n  }\n  return {\n    id: null,\n    placement: null\n  };\n}\nfunction getImportSource({\n  node\n}) {\n  if (node.specifiers.length === 0) return node.source.value;\n}\nfunction getRequireSource({\n  node\n}) {\n  if (!t.isExpressionStatement(node)) return;\n  const {\n    expression\n  } = node;\n  if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === \"require\" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0])) {\n    return expression.arguments[0].value;\n  }\n}\nfunction hoist(node) {\n  // @ts-expect-error\n  node._blockHoist = 3;\n  return node;\n}\nfunction createUtilsGetter(cache) {\n  return path => {\n    const prog = path.findParent(p => p.isProgram());\n    return {\n      injectGlobalImport(url, moduleName) {\n        cache.storeAnonymous(prog, url, moduleName, (isScript, source) => {\n          return isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source);\n        });\n      },\n      injectNamedImport(url, name, hint = name, moduleName) {\n        return cache.storeNamed(prog, url, name, moduleName, (isScript, source, name) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`\n                  var ${id} = require(${source}).${name}\n                `) : t.importDeclaration([t.importSpecifier(id, name)], source),\n            name: id.name\n          };\n        });\n      },\n      injectDefaultImport(url, hint = url, moduleName) {\n        return cache.storeNamed(prog, url, \"default\", moduleName, (isScript, source) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([t.importDefaultSpecifier(id)], source),\n            name: id.name\n          };\n        });\n      }\n    };\n  };\n}","\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nconst {\n  types: t\n} = _babel.default || _babel;\nclass ImportsCachedInjector {\n  constructor(resolver, getPreferredIndex) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n    this._getPreferredIndex = getPreferredIndex;\n  }\n  storeAnonymous(programPath, url, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url);\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n    this._injectImport(programPath, node, moduleName);\n  }\n  storeNamed(programPath, url, name, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n    const imports = this._ensure(this._imports, programPath, Map);\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n      this._injectImport(programPath, node, moduleName);\n    }\n    return t.identifier(imports.get(key));\n  }\n  _injectImport(programPath, node, moduleName) {\n    var _this$_lastImports$ge;\n    const newIndex = this._getPreferredIndex(moduleName);\n    const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];\n    const isPathStillValid = path => path.node &&\n    // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    path.parent === programPath.node && path.container === programPath.node.body;\n    let last;\n    if (newIndex === Infinity) {\n      // Fast path: we can always just insert at the end if newIndex is `Infinity`\n      if (lastImports.length > 0) {\n        last = lastImports[lastImports.length - 1].path;\n        if (!isPathStillValid(last)) last = undefined;\n      }\n    } else {\n      for (const [i, data] of lastImports.entries()) {\n        const {\n          path,\n          index\n        } = data;\n        if (isPathStillValid(path)) {\n          if (newIndex < index) {\n            const [newPath] = path.insertBefore(node);\n            lastImports.splice(i, 0, {\n              path: newPath,\n              index: newIndex\n            });\n            return;\n          }\n          last = path;\n        }\n      }\n    }\n    if (last) {\n      const [newPath] = last.insertAfter(node);\n      lastImports.push({\n        path: newPath,\n        index: newIndex\n      });\n    } else {\n      const [newPath] = programPath.unshiftContainer(\"body\", [node]);\n      this._lastImports.set(programPath, [{\n        path: newPath,\n        index: newIndex\n      }]);\n    }\n  }\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n    return collection;\n  }\n  _normalizeKey(programPath, url, name = \"\") {\n    const {\n      sourceType\n    } = programPath.node;\n\n    // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n    return `${name && sourceType}::${url}::${name}`;\n  }\n}\nexports.default = ImportsCachedInjector;","\n\nexports.__esModule = true;\nexports.presetEnvSilentDebugHeader = void 0;\nexports.stringifyTargets = stringifyTargets;\nexports.stringifyTargetsMultiline = stringifyTargetsMultiline;\nvar _helperCompilationTargets = require(\"@babel/helper-compilation-targets\");\nconst presetEnvSilentDebugHeader = exports.presetEnvSilentDebugHeader = \"#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets\";\nfunction stringifyTargetsMultiline(targets) {\n  return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);\n}\nfunction stringifyTargets(targets) {\n  return JSON.stringify(targets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n}","\n\nexports.__esModule = true;\nexports.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;\nexports.validateIncludeExclude = validateIncludeExclude;\nvar _utils = require(\"./utils\");\nfunction patternToRegExp(pattern) {\n  if (pattern instanceof RegExp) return pattern;\n  try {\n    return new RegExp(`^${pattern}$`);\n  } catch (_unused) {\n    return null;\n  }\n}\nfunction buildUnusedError(label, unused) {\n  if (!unused.length) return \"\";\n  return `  - The following \"${label}\" patterns didn't match any polyfill:\\n` + unused.map(original => `    ${String(original)}\\n`).join(\"\");\n}\nfunction buldDuplicatesError(duplicates) {\n  if (!duplicates.size) return \"\";\n  return `  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\\n` + Array.from(duplicates, name => `    ${name}\\n`).join(\"\");\n}\nfunction validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {\n  let current;\n  const filter = pattern => {\n    const regexp = patternToRegExp(pattern);\n    if (!regexp) return false;\n    let matched = false;\n    for (const polyfill of polyfills.keys()) {\n      if (regexp.test(polyfill)) {\n        matched = true;\n        current.add(polyfill);\n      }\n    }\n    return !matched;\n  };\n\n  // prettier-ignore\n  const include = current = new Set();\n  const unusedInclude = Array.from(includePatterns).filter(filter);\n\n  // prettier-ignore\n  const exclude = current = new Set();\n  const unusedExclude = Array.from(excludePatterns).filter(filter);\n  const duplicates = (0, _utils.intersection)(include, exclude);\n  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {\n    throw new Error(`Error while validating the \"${provider}\" provider options:\\n` + buildUnusedError(\"include\", unusedInclude) + buildUnusedError(\"exclude\", unusedExclude) + buldDuplicatesError(duplicates));\n  }\n  return {\n    include,\n    exclude\n  };\n}\nfunction applyMissingDependenciesDefaults(options, babelApi) {\n  const {\n    missingDependencies = {}\n  } = options;\n  if (missingDependencies === false) return false;\n  const caller = babelApi.caller(caller => caller == null ? void 0 : caller.name);\n  const {\n    log = \"deferred\",\n    inject = caller === \"rollup-plugin-babel\" ? \"throw\" : \"import\",\n    all = false\n  } = missingDependencies;\n  return {\n    log,\n    inject,\n    all\n  };\n}","\n\nexports.__esModule = true;\nexports.usage = exports.entry = void 0;\nvar _usage = _interopRequireDefault(require(\"./usage\"));\nexports.usage = _usage.default;\nvar _entry = _interopRequireDefault(require(\"./entry\"));\nexports.entry = _entry.default;\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }","\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nfunction isRemoved(path) {\n  if (path.removed) return true;\n  if (!path.parentPath) return false;\n  if (path.listKey) {\n    var _path$parentPath$node;\n    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;\n  } else {\n    var _path$parentPath$node2;\n    if (((_path$parentPath$node2 = path.parentPath.node) == null ? void 0 : _path$parentPath$node2[path.key]) !== path.node) return true;\n  }\n  return isRemoved(path.parentPath);\n}\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n  function handleReferencedIdentifier(path) {\n    const {\n      node: {\n        name\n      },\n      scope\n    } = path;\n    if (scope.getBindingIdentifier(name)) return;\n    callProvider({\n      kind: \"global\",\n      name\n    }, path);\n  }\n  function analyzeMemberExpression(path) {\n    const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n    return {\n      key,\n      handleAsMemberExpression: !!key && key !== \"prototype\"\n    };\n  }\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        parentPath\n      } = path;\n      if (parentPath.isMemberExpression({\n        object: path.node\n      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {\n        return;\n      }\n      handleReferencedIdentifier(path);\n    },\n    \"MemberExpression|OptionalMemberExpression\"(path) {\n      const {\n        key,\n        handleAsMemberExpression\n      } = analyzeMemberExpression(path);\n      if (!handleAsMemberExpression) return;\n      const object = path.get(\"object\");\n      let objectIsGlobalIdentifier = object.isIdentifier();\n      if (objectIsGlobalIdentifier) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding) {\n          if (binding.path.isImportNamespaceSpecifier()) return;\n          objectIsGlobalIdentifier = false;\n        }\n      }\n      const source = (0, _utils.resolveSource)(object);\n      let skipObject = property(source.id, key, source.placement, path);\n      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));\n      if (!skipObject) handleReferencedIdentifier(object);\n    },\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj;\n\n      // const { keys, values } = Object\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\");\n        // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\");\n        // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n  };\n};\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nvar _default = callProvider => ({\n  ImportDeclaration(path) {\n    const source = (0, _utils.getImportSource)(path);\n    if (!source) return;\n    callProvider({\n      kind: \"import\",\n      source\n    }, path);\n  },\n  Program(path) {\n    path.get(\"body\").forEach(bodyPath => {\n      const source = (0, _utils.getRequireSource)(bodyPath);\n      if (!source) return;\n      callProvider({\n        kind: \"import\",\n        source\n      }, bodyPath);\n    });\n  }\n});\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.has = has;\nexports.laterLogMissing = laterLogMissing;\nexports.logMissing = logMissing;\nexports.resolve = resolve;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.debounce\"));\nvar _resolve = _interopRequireDefault(require(\"resolve\"));\nvar _module = require(\"module\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;\n// eslint-disable-line\n\nfunction myResolve(name, basedir) {\n  if (nativeRequireResolve) {\n    return require.resolve(name, {\n      paths: [basedir]\n    }).replace(/\\\\/g, \"/\");\n  } else {\n    return _resolve.default.sync(name, {\n      basedir\n    }).replace(/\\\\/g, \"/\");\n  }\n}\nfunction resolve(dirname, moduleName, absoluteImports) {\n  if (absoluteImports === false) return moduleName;\n  let basedir = dirname;\n  if (typeof absoluteImports === \"string\") {\n    basedir = _path.default.resolve(basedir, absoluteImports);\n  }\n  try {\n    return myResolve(moduleName, basedir);\n  } catch (err) {\n    if (err.code !== \"MODULE_NOT_FOUND\") throw err;\n    throw Object.assign(new Error(`Failed to resolve \"${moduleName}\" relative to \"${dirname}\"`), {\n      code: \"BABEL_POLYFILL_NOT_FOUND\",\n      polyfill: moduleName,\n      dirname\n    });\n  }\n}\nfunction has(basedir, name) {\n  try {\n    myResolve(name, basedir);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\nfunction logMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  const deps = Array.from(missingDeps).sort().join(\" \");\n  console.warn(\"\\nSome polyfills have been added but are not present in your dependencies.\\n\" + \"Please run one of the following commands:\\n\" + `\\tnpm install --save ${deps}\\n` + `\\tyarn add ${deps}\\n`);\n  process.exitCode = 1;\n}\nlet allMissingDeps = new Set();\nconst laterLogMissingDependencies = (0, _lodash.default)(() => {\n  logMissing(allMissingDeps);\n  allMissingDeps = new Set();\n}, 100);\nfunction laterLogMissing(missingDeps) {\n  if (missingDeps.size === 0) return;\n  missingDeps.forEach(name => allMissingDeps.add(name));\n  laterLogMissingDependencies();\n}","\n\nexports.__esModule = true;\nexports.default = createMetaResolver;\nvar _utils = require(\"./utils\");\nconst PossibleGlobalObjects = new Set([\"global\", \"globalThis\", \"self\", \"window\"]);\nfunction createMetaResolver(polyfills) {\n  const {\n    static: staticP,\n    instance: instanceP,\n    global: globalP\n  } = polyfills;\n  return meta => {\n    if (meta.kind === \"global\" && globalP && (0, _utils.has)(globalP, meta.name)) {\n      return {\n        kind: \"global\",\n        desc: globalP[meta.name],\n        name: meta.name\n      };\n    }\n    if (meta.kind === \"property\" || meta.kind === \"in\") {\n      const {\n        placement,\n        object,\n        key\n      } = meta;\n      if (object && placement === \"static\") {\n        if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) {\n          return {\n            kind: \"global\",\n            desc: globalP[key],\n            name: key\n          };\n        }\n        if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) {\n          return {\n            kind: \"static\",\n            desc: staticP[object][key],\n            name: `${object}$${key}`\n          };\n        }\n      }\n      if (instanceP && (0, _utils.has)(instanceP, key)) {\n        return {\n          kind: \"instance\",\n          desc: instanceP[key],\n          name: `${key}`\n        };\n      }\n    }\n  };\n}"]}