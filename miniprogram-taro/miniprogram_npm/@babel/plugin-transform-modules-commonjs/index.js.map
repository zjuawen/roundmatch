{"version":3,"sources":["index.js","dynamic-import.js","lazy.js","hooks.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nObject.defineProperty(exports, \"defineCommonJSHook\", {\n  enumerable: true,\n  get: function () {\n    return _hooks.defineCommonJSHook;\n  }\n});\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nvar _core = require(\"@babel/core\");\nvar _dynamicImport = require(\"./dynamic-import.js\");\nvar _lazy = require(\"./lazy.js\");\nvar _hooks = require(\"./hooks.js\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2, _api$assumption3;\n  api.assertVersion(7);\n  const {\n    strictNamespace = false,\n    mjsStrictNamespace = strictNamespace,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop,\n    importInterop,\n    lazy = false,\n    allowCommonJSExports = true,\n    loose = false\n  } = options;\n  const constantReexports = (_api$assumption = api.assumption(\"constantReexports\")) != null ? _api$assumption : loose;\n  const enumerableModuleMeta = (_api$assumption2 = api.assumption(\"enumerableModuleMeta\")) != null ? _api$assumption2 : loose;\n  const noIncompleteNsImportDetection = (_api$assumption3 = api.assumption(\"noIncompleteNsImportDetection\")) != null ? _api$assumption3 : false;\n  if (typeof lazy !== \"boolean\" && typeof lazy !== \"function\" && (!Array.isArray(lazy) || !lazy.every(item => typeof item === \"string\"))) {\n    throw new Error(`.lazy must be a boolean, array of strings, or a function`);\n  }\n  if (typeof strictNamespace !== \"boolean\") {\n    throw new Error(`.strictNamespace must be a boolean, or undefined`);\n  }\n  if (typeof mjsStrictNamespace !== \"boolean\") {\n    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);\n  }\n  const getAssertion = localName => _core.template.expression.ast`\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"${localName}\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  `;\n  const moduleExportsVisitor = {\n    ReferencedIdentifier(path) {\n      const localName = path.node.name;\n      if (localName !== \"module\" && localName !== \"exports\") return;\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = this.scope.getBinding(localName);\n      if (rootBinding !== localBinding || path.parentPath.isObjectProperty({\n        value: path.node\n      }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({\n        left: path.node\n      }) || path.isAssignmentExpression({\n        left: path.node\n      })) {\n        return;\n      }\n      path.replaceWith(getAssertion(localName));\n    },\n    UpdateExpression(path) {\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (localName !== \"module\" && localName !== \"exports\") return;\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = this.scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + \"=\", arg.node, getAssertion(localName)));\n    },\n    AssignmentExpression(path) {\n      const left = path.get(\"left\");\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n        if (localName !== \"module\" && localName !== \"exports\") return;\n        const localBinding = path.scope.getBinding(localName);\n        const rootBinding = this.scope.getBinding(localName);\n        if (rootBinding !== localBinding) return;\n        const right = path.get(\"right\");\n        right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));\n      } else if (left.isPattern()) {\n        const ids = left.getOuterBindingIdentifiers();\n        const localName = Object.keys(ids).find(localName => {\n          if (localName !== \"module\" && localName !== \"exports\") return false;\n          return this.scope.getBinding(localName) === path.scope.getBinding(localName);\n        });\n        if (localName) {\n          const right = path.get(\"right\");\n          right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));\n        }\n      }\n    }\n  };\n  return {\n    name: \"transform-modules-commonjs\",\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"commonjs\");\n      if (lazy) (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));\n    },\n    visitor: {\n      [\"CallExpression\" + (api.types.importExpression ? \"|ImportExpression\" : \"\")](path) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;\n        let {\n          scope\n        } = path;\n        do {\n          scope.rename(\"require\");\n        } while (scope = scope.parent);\n        (0, _dynamicImport.transformDynamicImport)(path, noInterop, this.file);\n      },\n      Program: {\n        exit(path, state) {\n          if (!(0, _helperModuleTransforms.isModule)(path)) return;\n          path.scope.rename(\"exports\");\n          path.scope.rename(\"module\");\n          path.scope.rename(\"require\");\n          path.scope.rename(\"__filename\");\n          path.scope.rename(\"__dirname\");\n          if (!allowCommonJSExports) {\n            path.traverse(moduleExportsVisitor, {\n              scope: path.scope\n            });\n          }\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          const hooks = (0, _hooks.makeInvokers)(this.file);\n          const {\n            meta,\n            headers\n          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {\n            exportName: \"exports\",\n            constantReexports,\n            enumerableModuleMeta,\n            strict,\n            strictMode,\n            allowTopLevelThis,\n            noInterop,\n            importInterop,\n            wrapReference: hooks.wrapReference,\n            getWrapperPayload: hooks.getWrapperPayload,\n            esNamespaceOnly: typeof state.filename === \"string\" && state.filename.endsWith(\".mjs\") ? mjsStrictNamespace : strictNamespace,\n            noIncompleteNsImportDetection,\n            filename: this.file.opts.filename\n          });\n          for (const [source, metadata] of meta.source) {\n            const loadExpr = _core.types.callExpression(_core.types.identifier(\"require\"), [_core.types.stringLiteral(source)]);\n            let header;\n            if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {\n              if (lazy && metadata.wrap === \"function\") {\n                throw new Error(\"Assertion failure\");\n              }\n              header = _core.types.expressionStatement(loadExpr);\n            } else {\n              const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;\n              if (metadata.wrap) {\n                const res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);\n                if (res === false) continue;else header = res;\n              }\n              header != null ? header : header = _core.template.statement.ast`\n                var ${metadata.name} = ${init};\n              `;\n            }\n            header.loc = metadata.loc;\n            headers.push(header);\n            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));\n          }\n          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);\n          path.unshiftContainer(\"body\", headers);\n          path.get(\"body\").forEach(path => {\n            if (!headers.includes(path.node)) return;\n            if (path.isVariableDeclaration()) {\n              path.scope.registerDeclaration(path);\n            }\n          });\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformDynamicImport = transformDynamicImport;\nvar _core = require(\"@babel/core\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nconst requireNoInterop = source => _core.template.expression.ast`require(${source})`;\nconst requireInterop = (source, file) => _core.types.callExpression(file.addHelper(\"interopRequireWildcard\"), [requireNoInterop(source)]);\nfunction transformDynamicImport(path, noInterop, file) {\n  const buildRequire = noInterop ? requireNoInterop : requireInterop;\n  path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, true, false, specifier => buildRequire(specifier, file)));\n}\n\n//# sourceMappingURL=dynamic-import.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyImportsHook = void 0;\nvar _core = require(\"@babel/core\");\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\nconst lazyImportsHook = lazy => ({\n  name: `${\"@babel/plugin-transform-modules-commonjs\"}/lazy`,\n  version: \"7.28.6\",\n  getWrapperPayload(source, metadata) {\n    if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll) {\n      return null;\n    }\n    if (lazy === true) {\n      return source.includes(\".\") ? null : \"lazy/function\";\n    }\n    if (Array.isArray(lazy)) {\n      return !lazy.includes(source) ? null : \"lazy/function\";\n    }\n    if (typeof lazy === \"function\") {\n      return lazy(source) ? \"lazy/function\" : null;\n    }\n  },\n  buildRequireWrapper(name, init, payload, referenced) {\n    if (payload === \"lazy/function\") {\n      if (!referenced) return false;\n      return _core.template.statement.ast`\n        function ${name}() {\n          const data = ${init};\n          ${name} = function(){ return data; };\n          return data;\n        }\n      `;\n    }\n  },\n  wrapReference(ref, payload) {\n    if (payload === \"lazy/function\") return _core.types.callExpression(ref, []);\n  }\n});\nexports.lazyImportsHook = lazyImportsHook;\n\n//# sourceMappingURL=lazy.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineCommonJSHook = defineCommonJSHook;\nexports.makeInvokers = makeInvokers;\nconst commonJSHooksKey = \"@babel/plugin-transform-modules-commonjs/customWrapperPlugin\";\nfunction defineCommonJSHook(file, hook) {\n  let hooks = file.get(commonJSHooksKey);\n  if (!hooks) file.set(commonJSHooksKey, hooks = []);\n  hooks.push(hook);\n}\nfunction findMap(arr, cb) {\n  if (arr) {\n    for (const el of arr) {\n      const res = cb(el);\n      if (res != null) return res;\n    }\n  }\n}\nfunction makeInvokers(file) {\n  const hooks = file.get(commonJSHooksKey);\n  return {\n    getWrapperPayload(...args) {\n      return findMap(hooks, hook => hook.getWrapperPayload == null ? void 0 : hook.getWrapperPayload(...args));\n    },\n    wrapReference(...args) {\n      return findMap(hooks, hook => hook.wrapReference == null ? void 0 : hook.wrapReference(...args));\n    },\n    buildRequireWrapper(...args) {\n      return findMap(hooks, hook => hook.buildRequireWrapper == null ? void 0 : hook.buildRequireWrapper(...args));\n    }\n  };\n}\n\n//# sourceMappingURL=hooks.js.map\n"]}