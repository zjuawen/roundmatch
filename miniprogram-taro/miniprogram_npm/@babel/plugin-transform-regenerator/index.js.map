{"version":3,"sources":["index.js","regenerator/visit.js","regenerator/hoist.js","regenerator/emit.js","regenerator/leap.js","regenerator/meta.js","regenerator/util.js","regenerator/replaceShorthandObjectMethod.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,ADGA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,ADGA,AENA,AHSA;ADIA,AGTA,ADGA,AENA,ACHA,AJYA;ADIA,AGTA,ADGA,AENA,ACHA,AJYA;ADIA,AGTA,ADGA,AENA,ACHA,AJYA;ADIA,AGTA,ADGA,AENA,ACHA,ACHA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,ACHA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,ACHA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;ADIA,AGTA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;AELA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;AELA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;AELA,ADGA,AENA,ACHA,AENA,ADGA,ALeA;AELA,ADGA,AENA,ACHA,AENA,ANkBA;AELA,ADGA,AENA,ACHA,AENA,ANkBA;AELA,ADGA,AENA,ACHA,AENA,ANkBA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _visit = require(\"./regenerator/visit.js\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  traverse,\n  assertVersion\n}) => {\n  assertVersion(7);\n  return {\n    name: \"transform-regenerator\",\n    visitor: traverse.visitors.merge([(0, _visit.getVisitor)(), {\n      CallExpression(path) {\n        var _this$availableHelper;\n        if (!((_this$availableHelper = this.availableHelper) != null && _this$availableHelper.call(this, \"regeneratorRuntime\"))) {\n          return;\n        }\n        const callee = path.get(\"callee\");\n        if (!callee.isMemberExpression()) return;\n        const obj = callee.get(\"object\");\n        if (obj.isIdentifier({\n          name: \"regeneratorRuntime\"\n        })) {\n          const helper = this.addHelper(\"regeneratorRuntime\");\n          if (t.isArrowFunctionExpression(helper)) {\n            obj.replaceWith(helper.body);\n            return;\n          }\n          obj.replaceWith(t.callExpression(helper, []));\n        }\n      }\n    }])\n  };\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getVisitor = void 0;\nvar _assert = require(\"assert\");\nvar _hoist = require(\"./hoist.js\");\nvar _emit = require(\"./emit.js\");\nvar _replaceShorthandObjectMethod = require(\"./replaceShorthandObjectMethod.js\");\nvar util = require(\"./util.js\");\nvar _core = require(\"@babel/core\");\nconst getVisitor = () => ({\n  Method(path, state) {\n    const node = path.node;\n    if (!shouldRegenerate(node, state)) return;\n    const container = _core.types.functionExpression(null, [], _core.types.cloneNode(node.body, false), node.generator, node.async);\n    path.get(\"body\").set(\"body\", [_core.types.returnStatement(_core.types.callExpression(container, []))]);\n    node.async = false;\n    node.generator = false;\n    path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n  },\n  Function: {\n    exit(path, state) {\n      let node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      path = (0, _replaceShorthandObjectMethod.default)(path);\n      node = path.node;\n      const contextId = path.scope.generateUidIdentifier(\"context\");\n      const argsId = path.scope.generateUidIdentifier(\"args\");\n      path.ensureBlock();\n      const bodyBlockPath = path.get(\"body\");\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor, this);\n      }\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId,\n        pluginPass: this\n      });\n      const outerBody = [];\n      const innerBody = [];\n      bodyBlockPath.get(\"body\").forEach(function (childPath) {\n        const node = childPath.node;\n        if (_core.types.isExpressionStatement(node) && _core.types.isStringLiteral(node.expression)) {\n          outerBody.push(node);\n        } else if ((node == null ? void 0 : node._blockHoist) != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n      if (outerBody.length > 0) {\n        bodyBlockPath.node.body = innerBody;\n      }\n      const outerFnExpr = getOuterFnExpr(this, path);\n      _core.types.assertIdentifier(node.id);\n      const vars = (0, _hoist.hoist)(path);\n      const context = {\n        usesThis: false,\n        usesArguments: false,\n        getArgsId: () => _core.types.cloneNode(argsId)\n      };\n      path.traverse(argumentsThisVisitor, context);\n      if (context.usesArguments) {\n        vars.push(_core.types.variableDeclarator(_core.types.cloneNode(argsId), _core.types.identifier(\"arguments\")));\n      }\n      const emitter = new _emit.Emitter(contextId, path.scope, vars, this);\n      emitter.explode(path.get(\"body\"));\n      if (vars.length > 0) {\n        outerBody.push(_core.types.variableDeclaration(\"var\", vars));\n      }\n      const wrapArgs = [emitter.getContextFunction()];\n      const tryLocsList = emitter.getTryLocsList();\n      if (node.generator) {\n        wrapArgs.push(outerFnExpr);\n      } else if (context.usesThis || tryLocsList || node.async) {\n        wrapArgs.push(_core.types.nullLiteral());\n      }\n      if (context.usesThis) {\n        wrapArgs.push(_core.types.thisExpression());\n      } else if (tryLocsList || node.async) {\n        wrapArgs.push(_core.types.nullLiteral());\n      }\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      } else if (node.async) {\n        wrapArgs.push(_core.types.nullLiteral());\n      }\n      if (node.async) {\n        let currentScope = path.scope;\n        do {\n          if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n        } while (currentScope = currentScope.parent);\n        wrapArgs.push(_core.types.identifier(\"Promise\"));\n      }\n      const wrapCall = _core.types.callExpression(util.newHelpersAvailable(this) ? !node.async ? _core.types.memberExpression(_core.types.callExpression(this.addHelper(\"regenerator\"), []), _core.types.identifier(\"w\")) : node.generator ? this.addHelper(\"regeneratorAsyncGen\") : this.addHelper(\"regeneratorAsync\") : util.runtimeProperty(this, node.async ? \"async\" : \"wrap\"), wrapArgs);\n      outerBody.push(_core.types.returnStatement(wrapCall));\n      node.body = _core.types.blockStatement(outerBody);\n      path.get(\"body.body\").forEach(p => p.scope.registerDeclaration(p));\n      const oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        node.body.directives = oldDirectives;\n      }\n      const wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n      if (node.async) {\n        node.async = false;\n      }\n      if (wasGeneratorFunction && _core.types.isExpression(node)) {\n        path.replaceWith(_core.types.callExpression(util.newHelpersAvailable(this) ? _core.types.memberExpression(_core.types.callExpression(this.addHelper(\"regenerator\"), []), _core.types.identifier(\"m\")) : util.runtimeProperty(this, \"mark\"), [node]));\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n      const insertedLocs = emitter.getInsertedLocs();\n      path.traverse({\n        NumericLiteral(path) {\n          if (!insertedLocs.has(path.node)) {\n            return;\n          }\n          path.replaceWith(_core.types.numericLiteral(path.node.value));\n        }\n      });\n      path.requeue();\n    }\n  }\n});\nexports.getVisitor = getVisitor;\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      return state.opts.asyncGenerators !== false;\n    } else {\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    return state.opts.async !== false;\n  } else {\n    return false;\n  }\n}\nfunction getOuterFnExpr(state, funPath) {\n  const node = funPath.node;\n  _core.types.assertFunction(node);\n  if (!node.id) {\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n  if (node.generator && _core.types.isFunctionDeclaration(node)) {\n    return getMarkedFunctionId(state, funPath);\n  }\n  return _core.types.cloneNode(node.id);\n}\nconst markInfo = new WeakMap();\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n  return markInfo.get(node);\n}\nfunction getMarkedFunctionId(state, funPath) {\n  const node = funPath.node;\n  _core.types.assertIdentifier(node.id);\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n  if (!blockPath) {\n    return node.id;\n  }\n  const block = blockPath.node;\n  _assert.ok(Array.isArray(block.body));\n  const info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = _core.types.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n  _assert.strictEqual(info.declPath.node, info.decl);\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = _core.types.callExpression(util.newHelpersAvailable(state) ? _core.types.memberExpression(_core.types.callExpression(state.addHelper(\"regenerator\"), []), _core.types.identifier(\"m\")) : util.runtimeProperty(state, \"mark\"), [_core.types.cloneNode(node.id)]);\n  const index = info.decl.declarations.push(_core.types.variableDeclarator(markedId, markCallExp)) - 1;\n  const markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n  _assert.strictEqual(markCallExpPath.node, markCallExp);\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return _core.types.cloneNode(markedId);\n}\nconst argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function (path) {\n    path.skip();\n  },\n  Identifier: function (path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      path.replaceWith(state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function (path, state) {\n    state.usesThis = true;\n  }\n};\nconst functionSentVisitor = {\n  MetaProperty(path, state) {\n    const {\n      node\n    } = path;\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      path.replaceWith(_core.types.memberExpression(_core.types.cloneNode(state.context), _core.types.identifier(util.newHelpersAvailable(state.pluginPass) ? \"v\" : \"_sent\")));\n    }\n  }\n};\nconst awaitVisitor = {\n  Function: function (path) {\n    path.skip();\n  },\n  AwaitExpression: function (path) {\n    const argument = path.node.argument;\n    const helper = util.newHelpersAvailable(this) ? this.addHelper(\"awaitAsyncGenerator\") : util.runtimeProperty(this, \"awrap\");\n    path.replaceWith(_core.types.yieldExpression(_core.types.callExpression(helper, [argument]), false));\n  }\n};\n\n//# sourceMappingURL=visit.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hoist = hoist;\nvar _core = require(\"@babel/core\");\nfunction hoist(funPath) {\n  _core.types.assertFunction(funPath.node);\n  const vars = {\n    __proto__: null\n  };\n  function varDeclToExpr({\n    node: vdec\n  }, includeIdentifiers) {\n    _core.types.assertVariableDeclaration(vdec);\n    const exprs = [];\n    vdec.declarations.forEach(function (dec) {\n      vars[dec.id.name] = _core.types.identifier(dec.id.name);\n      if (dec.init) {\n        exprs.push(_core.types.assignmentExpression(\"=\", dec.id, dec.init));\n      } else if (includeIdentifiers) {\n        exprs.push(dec.id);\n      }\n    });\n    if (exprs.length === 0) return null;\n    if (exprs.length === 1) return exprs[0];\n    return _core.types.sequenceExpression(exprs);\n  }\n  funPath.get(\"body\").traverse({\n    VariableDeclaration: {\n      exit: function (path) {\n        const expr = varDeclToExpr(path, false);\n        if (expr === null) {\n          path.remove();\n        } else {\n          for (const name of Object.keys(vars)) {\n            path.scope.removeBinding(name);\n          }\n          path.replaceWith(_core.types.expressionStatement(expr));\n        }\n        path.skip();\n      }\n    },\n    ForStatement: function (path) {\n      const init = path.get(\"init\");\n      if (init.isVariableDeclaration()) {\n        const expr = varDeclToExpr(init, false);\n        if (expr) {\n          init.replaceWith(expr);\n        } else {\n          init.remove();\n        }\n      }\n    },\n    ForXStatement: function (path) {\n      const left = path.get(\"left\");\n      if (left.isVariableDeclaration()) {\n        left.replaceWith(varDeclToExpr(left, true));\n      }\n    },\n    FunctionDeclaration: function (path) {\n      const node = path.node;\n      vars[node.id.name] = node.id;\n      const assignment = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(node.id), _core.types.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.async)));\n      if (path.parentPath.isBlockStatement()) {\n        path.parentPath.unshiftContainer(\"body\", assignment);\n        path.remove();\n      } else {\n        path.replaceWith(assignment);\n        path.scope.removeBinding(node.id.name);\n      }\n      path.skip();\n    },\n    FunctionExpression: function (path) {\n      path.skip();\n    },\n    ArrowFunctionExpression: function (path) {\n      path.skip();\n    }\n  });\n  const paramNames = {\n    __proto__: null\n  };\n  funPath.get(\"params\").forEach(function (paramPath) {\n    const param = paramPath.node;\n    if (_core.types.isIdentifier(param)) {\n      paramNames[param.name] = param;\n    } else {}\n  });\n  const declarations = [];\n  Object.keys(vars).forEach(function (name) {\n    if (!hasOwnProperty.call(paramNames, name)) {\n      declarations.push(_core.types.variableDeclarator(vars[name], null));\n    }\n  });\n  return declarations;\n}\n\n//# sourceMappingURL=hoist.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Emitter = void 0;\nvar _assert = require(\"assert\");\nvar leap = require(\"./leap.js\");\nvar meta = require(\"./meta.js\");\nvar util = require(\"./util.js\");\nvar _core = require(\"@babel/core\");\nconst PENDING_LOCATION = Number.MAX_VALUE;\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\nconst catchParamVisitor = {\n  Identifier: function (path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      path.replaceWith(state.getSafeParam());\n    }\n  },\n  Scope: function (path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      path.skip();\n    }\n  }\n};\nclass Emitter {\n  constructor(contextId, scope, vars, pluginPass) {\n    this.nextTempId = void 0;\n    this.contextId = void 0;\n    this.index = void 0;\n    this.indexMap = void 0;\n    this.listing = void 0;\n    this.returns = void 0;\n    this.lastReferenceIndex = 0;\n    this.marked = void 0;\n    this.insertedLocs = void 0;\n    this.finalLoc = void 0;\n    this.tryEntries = void 0;\n    this.leapManager = void 0;\n    this.scope = void 0;\n    this.vars = void 0;\n    this.pluginPass = void 0;\n    this.pluginPass = pluginPass;\n    this.scope = scope;\n    this.vars = vars;\n    this.nextTempId = 0;\n    this.contextId = contextId;\n    this.listing = [];\n    this.index = 0;\n    this.indexMap = new Map([[0, 0]]);\n    this.returns = new Set();\n    this.lastReferenceIndex = 0;\n    this.marked = [true];\n    this.insertedLocs = new Set();\n    this.finalLoc = this.loc();\n    this.tryEntries = [];\n    this.leapManager = new leap.LeapManager(this);\n  }\n  loc() {\n    const l = _core.types.numericLiteral(PENDING_LOCATION);\n    this.insertedLocs.add(l);\n    return l;\n  }\n  getInsertedLocs() {\n    return this.insertedLocs;\n  }\n  getContextId() {\n    return _core.types.cloneNode(this.contextId);\n  }\n  getIndex() {\n    if (!this.indexMap.has(this.listing.length)) {\n      this.indexMap.set(this.listing.length, ++this.index);\n    }\n    return this.index;\n  }\n  mark(loc) {\n    if (loc.value === PENDING_LOCATION) {\n      loc.value = this.getIndex();\n    } else {\n      _assert.strictEqual(loc.value, this.index);\n    }\n    this.marked[this.listing.length] = true;\n    if (loc.value > this.lastReferenceIndex) {\n      this.lastReferenceIndex = loc.value;\n    }\n    return loc;\n  }\n  emit(node) {\n    if (_core.types.isExpression(node)) {\n      node = _core.types.expressionStatement(node);\n    }\n    _core.types.assertStatement(node);\n    this.listing.push(node);\n  }\n  emitAssign(lhs, rhs) {\n    this.emit(this.assign(lhs, rhs));\n    return lhs;\n  }\n  assign(lhs, rhs) {\n    return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(lhs), rhs));\n  }\n  contextProperty(name) {\n    const computed = name === \"catch\";\n    return _core.types.memberExpression(this.getContextId(), computed ? _core.types.stringLiteral(name) : _core.types.identifier(name), !!computed);\n  }\n  clearPendingException(tryLoc, assignee) {\n    const catchCall = _core.types.callExpression(this.contextProperty(\"catch\"), [_core.types.cloneNode(tryLoc)]);\n    if (assignee) {\n      this.emitAssign(assignee, catchCall);\n    } else {\n      this.emit(catchCall);\n    }\n  }\n  jump(toLoc) {\n    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"n\" : \"next\"), toLoc);\n    this.emit(_core.types.breakStatement());\n  }\n  jumpIf(test, toLoc) {\n    this.emit(_core.types.ifStatement(test, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"n\" : \"next\"), toLoc), _core.types.breakStatement()])));\n  }\n  jumpIfNot(test, toLoc) {\n    let negatedTest;\n    if (_core.types.isUnaryExpression(test) && test.operator === \"!\") {\n      negatedTest = test.argument;\n    } else {\n      negatedTest = _core.types.unaryExpression(\"!\", test);\n    }\n    this.emit(_core.types.ifStatement(negatedTest, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"n\" : \"next\"), toLoc), _core.types.breakStatement()])));\n  }\n  makeContextTempVar() {\n    return this.contextProperty(\"t\" + this.nextTempId++);\n  }\n  makeTempVar() {\n    const id = this.scope.generateUidIdentifier(\"t\");\n    this.vars.push(_core.types.variableDeclarator(id));\n    return _core.types.cloneNode(id);\n  }\n  getContextFunction() {\n    return _core.types.functionExpression(null, [this.getContextId()], _core.types.blockStatement([this.getDispatchLoop()]), false, false);\n  }\n  getDispatchLoop() {\n    const self = this;\n    const cases = [];\n    let current;\n    let alreadyEnded = false;\n    self.listing.forEach(function (stmt, i) {\n      if (self.marked[i]) {\n        cases.push(_core.types.switchCase(_core.types.numericLiteral(self.indexMap.get(i)), current = []));\n        alreadyEnded = false;\n      }\n      if (!alreadyEnded) {\n        current.push(stmt);\n        if (_core.types.isCompletionStatement(stmt)) alreadyEnded = true;\n      }\n    });\n    this.finalLoc.value = this.getIndex();\n    if (util.newHelpersAvailable(this.pluginPass)) {\n      if (this.lastReferenceIndex === this.index || !this.returns.has(this.listing.length)) {\n        cases.push(_core.types.switchCase(this.finalLoc, [_core.types.returnStatement(_core.types.callExpression(this.contextProperty(\"a\"), [_core.types.numericLiteral(2)]))]));\n      }\n    } else {\n      cases.push(_core.types.switchCase(this.finalLoc, []), _core.types.switchCase(_core.types.stringLiteral(\"end\"), [_core.types.returnStatement(_core.types.callExpression(this.contextProperty(\"stop\"), []))]));\n    }\n    return _core.types.whileStatement(_core.types.numericLiteral(1), _core.types.switchStatement(util.newHelpersAvailable(this.pluginPass) ? this.tryEntries.length === 0 ? this.contextProperty(\"n\") : _core.types.assignmentExpression(\"=\", this.contextProperty(\"p\"), this.contextProperty(\"n\")) : _core.types.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n  }\n  getTryLocsList() {\n    if (this.tryEntries.length === 0) {\n      return null;\n    }\n    let lastLocValue = 0;\n    const arrayExpression = _core.types.arrayExpression(this.tryEntries.map(function (tryEntry) {\n      const thisLocValue = tryEntry.firstLoc.value;\n      _assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n      const ce = tryEntry.catchEntry;\n      const fe = tryEntry.finallyEntry;\n      const locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n      return _core.types.arrayExpression(locs.map(loc => loc && _core.types.cloneNode(loc)));\n    }));\n    if (util.newHelpersAvailable(this.pluginPass)) {\n      arrayExpression.elements.reverse();\n    }\n    return arrayExpression;\n  }\n  explode(path, ignoreResult) {\n    const node = path.node;\n    const self = this;\n    if (_core.types.isDeclaration(node)) throw getDeclError(node);\n    if (path.isStatement()) return self.explodeStatement(path);\n    if (path.isExpression()) return self.explodeExpression(path, ignoreResult);\n    switch (node.type) {\n      case \"VariableDeclarator\":\n        throw getDeclError(node);\n      case \"ObjectProperty\":\n      case \"SwitchCase\":\n      case \"CatchClause\":\n        throw new Error(node.type + \" nodes should be handled by their parents\");\n      default:\n        throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n    }\n  }\n  explodeStatement(path, labelId = null) {\n    const stmt = path.node;\n    const self = this;\n    let before, after, head;\n    if (path.isBlockStatement()) {\n      path.get(\"body\").forEach(function (path) {\n        self.explodeStatement(path);\n      });\n      return;\n    }\n    if (!meta.containsLeap(stmt)) {\n      self.emit(stmt);\n      return;\n    }\n    switch (path.type) {\n      case \"ExpressionStatement\":\n        self.explodeExpression(path.get(\"expression\"), true);\n        break;\n      case \"LabeledStatement\":\n        after = this.loc();\n        self.leapManager.withEntry(new leap.LabeledEntry(after, path.node.label), function () {\n          self.explodeStatement(path.get(\"body\"), path.node.label);\n        });\n        self.mark(after);\n        break;\n      case \"WhileStatement\":\n        before = this.loc();\n        after = this.loc();\n        self.mark(before);\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n        self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n          self.explodeStatement(path.get(\"body\"));\n        });\n        self.jump(before);\n        self.mark(after);\n        break;\n      case \"DoWhileStatement\":\n        const first = this.loc();\n        const test = this.loc();\n        after = this.loc();\n        self.mark(first);\n        self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n          self.explode(path.get(\"body\"));\n        });\n        self.mark(test);\n        self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n        self.mark(after);\n        break;\n      case \"ForStatement\":\n        head = this.loc();\n        const update = this.loc();\n        after = this.loc();\n        if (path.node.init) {\n          self.explode(path.get(\"init\"), true);\n        }\n        self.mark(head);\n        if (path.node.test) {\n          self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n        } else {}\n        self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n          self.explodeStatement(path.get(\"body\"));\n        });\n        self.mark(update);\n        if (path.node.update) {\n          self.explode(path.get(\"update\"), true);\n        }\n        self.jump(head);\n        self.mark(after);\n        break;\n      case \"TypeCastExpression\":\n        return self.explodeExpression(path.get(\"expression\"));\n      case \"ForInStatement\":\n        head = this.loc();\n        after = this.loc();\n        const keyIterNextFn = self.makeTempVar();\n        const helper = util.newHelpersAvailable(this.pluginPass) ? this.pluginPass.addHelper(\"regeneratorKeys\") : util.runtimeProperty(this.pluginPass, \"keys\");\n        self.emitAssign(keyIterNextFn, _core.types.callExpression(helper, [self.explodeExpression(path.get(\"right\"))]));\n        self.mark(head);\n        const keyInfoTmpVar = self.makeTempVar();\n        self.jumpIf(_core.types.memberExpression(_core.types.assignmentExpression(\"=\", keyInfoTmpVar, _core.types.callExpression(_core.types.cloneNode(keyIterNextFn), [])), _core.types.identifier(\"done\"), false), after);\n        self.emitAssign(path.node.left, _core.types.memberExpression(_core.types.cloneNode(keyInfoTmpVar), _core.types.identifier(\"value\"), false));\n        self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n          self.explodeStatement(path.get(\"body\"));\n        });\n        self.jump(head);\n        self.mark(after);\n        break;\n      case \"BreakStatement\":\n        self.emitAbruptCompletion({\n          type: 3,\n          target: self.leapManager.getBreakLoc(path.node.label)\n        });\n        break;\n      case \"ContinueStatement\":\n        self.emitAbruptCompletion({\n          type: 3,\n          target: self.leapManager.getContinueLoc(path.node.label)\n        });\n        break;\n      case \"SwitchStatement\":\n        const disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n        after = this.loc();\n        const defaultLoc = this.loc();\n        let condition = defaultLoc;\n        const caseLocs = [];\n        const cases = path.node.cases || [];\n        for (let i = cases.length - 1; i >= 0; --i) {\n          const c = cases[i];\n          if (c.test) {\n            condition = _core.types.conditionalExpression(_core.types.binaryExpression(\"===\", _core.types.cloneNode(disc), c.test), caseLocs[i] = this.loc(), condition);\n          } else {\n            caseLocs[i] = defaultLoc;\n          }\n        }\n        const discriminant = path.get(\"discriminant\");\n        discriminant.replaceWith(condition);\n        self.jump(self.explodeExpression(discriminant));\n        self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n          path.get(\"cases\").forEach(function (casePath) {\n            const i = casePath.key;\n            self.mark(caseLocs[i]);\n            casePath.get(\"consequent\").forEach(function (path) {\n              self.explodeStatement(path);\n            });\n          });\n        });\n        self.mark(after);\n        if (defaultLoc.value === PENDING_LOCATION) {\n          self.mark(defaultLoc);\n          _assert.strictEqual(after.value, defaultLoc.value);\n        }\n        break;\n      case \"IfStatement\":\n        const elseLoc = path.node.alternate && this.loc();\n        after = this.loc();\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n        self.explodeStatement(path.get(\"consequent\"));\n        if (elseLoc) {\n          self.jump(after);\n          self.mark(elseLoc);\n          self.explodeStatement(path.get(\"alternate\"));\n        }\n        self.mark(after);\n        break;\n      case \"ReturnStatement\":\n        self.emitAbruptCompletion({\n          type: 2,\n          value: self.explodeExpression(path.get(\"argument\"))\n        });\n        break;\n      case \"WithStatement\":\n        throw new Error(\"WithStatement not supported in generator functions.\");\n      case \"TryStatement\":\n        after = this.loc();\n        const handler = path.node.handler;\n        const catchLoc = handler && this.loc();\n        const catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n        const finallyLoc = path.node.finalizer && this.loc();\n        const finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n        const tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n        self.tryEntries.push(tryEntry);\n        self.updateContextPrevLoc(tryEntry.firstLoc);\n        self.leapManager.withEntry(tryEntry, () => {\n          self.explodeStatement(path.get(\"block\"));\n          if (catchLoc) {\n            const body = path.node.block.body;\n            if (finallyLoc) {\n              self.jump(finallyLoc);\n            } else if (body.length && body[body.length - 1].type === \"ReturnStatement\") {\n              after = null;\n            } else {\n              self.jump(after);\n            }\n            self.updateContextPrevLoc(self.mark(catchLoc));\n            const bodyPath = path.get(\"handler.body\");\n            const safeParam = self.makeTempVar();\n            if (util.newHelpersAvailable(this.pluginPass)) {\n              this.emitAssign(safeParam, self.contextProperty(\"v\"));\n            } else {\n              self.clearPendingException(tryEntry.firstLoc, safeParam);\n            }\n            bodyPath.traverse(catchParamVisitor, {\n              getSafeParam: () => _core.types.cloneNode(safeParam),\n              catchParamName: handler.param.name\n            });\n            self.leapManager.withEntry(catchEntry, function () {\n              self.explodeStatement(bodyPath);\n            });\n          }\n          if (finallyLoc) {\n            self.updateContextPrevLoc(self.mark(finallyLoc));\n            self.leapManager.withEntry(finallyEntry, function () {\n              self.explodeStatement(path.get(\"finalizer\"));\n            });\n            self.emit(_core.types.returnStatement(_core.types.callExpression(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"f\" : \"finish\"), [finallyEntry.firstLoc])));\n          }\n        });\n        if (after) self.mark(after);\n        break;\n      case \"ThrowStatement\":\n        self.emit(_core.types.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n        break;\n      case \"ClassDeclaration\":\n        self.emit(self.explodeClass(path));\n        break;\n      default:\n        throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n    }\n  }\n  emitAbruptCompletion(record) {\n    const abruptArgs = [util.newHelpersAvailable(this.pluginPass) ? _core.types.numericLiteral(record.type) : _core.types.stringLiteral(record.type === 3 ? \"continue\" : \"return\")];\n    if (record.type === 3) {\n      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : _core.types.cloneNode(record.target);\n    } else if (record.type === 2) {\n      if (record.value) {\n        abruptArgs[1] = _core.types.cloneNode(record.value);\n      }\n    }\n    this.emit(_core.types.returnStatement(_core.types.callExpression(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"a\" : \"abrupt\"), abruptArgs)));\n    if (record.type === 2) {\n      this.returns.add(this.listing.length);\n    }\n  }\n  getUnmarkedCurrentLoc() {\n    return _core.types.numericLiteral(this.getIndex());\n  }\n  updateContextPrevLoc(loc) {\n    if (loc) {\n      if (loc.value === PENDING_LOCATION) {\n        loc.value = this.getIndex();\n      } else {\n        _assert.strictEqual(loc.value, this.index);\n      }\n    } else {\n      loc = this.getUnmarkedCurrentLoc();\n    }\n    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"p\" : \"prev\"), loc);\n  }\n  explodeViaTempVar(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {\n    _assert.ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n    let result = this.explodeExpression(childPath, ignoreChildResult);\n    if (ignoreChildResult) {} else if (tempVar || hasLeapingChildren && !_core.types.isLiteral(result)) {\n      result = this.emitAssign(tempVar || this.makeTempVar(), result);\n    }\n    return result;\n  }\n  explodeExpression(path, ignoreResult) {\n    const expr = path.node;\n    if (!expr) {\n      return expr;\n    }\n    const self = this;\n    let result;\n    let after;\n    function finish(expr) {\n      if (ignoreResult) {\n        self.emit(expr);\n      }\n      return expr;\n    }\n    if (!meta.containsLeap(expr)) {\n      return finish(expr);\n    }\n    const hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n    switch (path.type) {\n      case \"MemberExpression\":\n        return finish(_core.types.memberExpression(self.explodeExpression(path.get(\"object\")), path.node.computed ? self.explodeViaTempVar(null, path.get(\"property\"), hasLeapingChildren) : path.node.property, path.node.computed));\n      case \"CallExpression\":\n        const calleePath = path.get(\"callee\");\n        const argsPath = path.get(\"arguments\");\n        let newCallee;\n        let newArgs;\n        let lastLeapingArgIndex = argsPath.length - 1;\n        while (lastLeapingArgIndex >= 0 && !meta.containsLeap(argsPath[lastLeapingArgIndex].node)) {\n          lastLeapingArgIndex--;\n        }\n        let injectFirstArg = null;\n        if (_core.types.isMemberExpression(calleePath.node)) {\n          if (lastLeapingArgIndex !== -1) {\n            const newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get(\"object\"), hasLeapingChildren);\n            const newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(\"property\"), hasLeapingChildren) : calleePath.node.property;\n            injectFirstArg = newObject;\n            newCallee = _core.types.memberExpression(_core.types.memberExpression(_core.types.cloneNode(newObject), newProperty, calleePath.node.computed), _core.types.identifier(\"call\"), false);\n          } else {\n            newCallee = self.explodeExpression(calleePath);\n          }\n        } else {\n          newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);\n          if (_core.types.isMemberExpression(newCallee)) {\n            newCallee = _core.types.sequenceExpression([_core.types.numericLiteral(0), _core.types.cloneNode(newCallee)]);\n          }\n        }\n        if (lastLeapingArgIndex !== -1) {\n          newArgs = argsPath.map((argPath, index) => index >= lastLeapingArgIndex ? self.explodeExpression(argPath) : self.explodeViaTempVar(null, argPath, hasLeapingChildren));\n          if (injectFirstArg) newArgs.unshift(injectFirstArg);\n          newArgs = newArgs.map(arg => _core.types.cloneNode(arg));\n        } else {\n          newArgs = path.node.arguments;\n        }\n        return finish(_core.types.callExpression(newCallee, newArgs));\n      case \"NewExpression\":\n        return finish(_core.types.newExpression(self.explodeViaTempVar(null, path.get(\"callee\"), hasLeapingChildren), path.get(\"arguments\").map(function (argPath) {\n          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n        })));\n      case \"ObjectExpression\":\n        return finish(_core.types.objectExpression(path.get(\"properties\").map(function (propPath) {\n          if (propPath.isObjectProperty()) {\n            return _core.types.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(\"value\"), hasLeapingChildren), propPath.node.computed);\n          } else {\n            return propPath.node;\n          }\n        })));\n      case \"ArrayExpression\":\n        return finish(_core.types.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n          if (!elemPath.node) {\n            return null;\n          }\n          if (elemPath.isSpreadElement()) {\n            return _core.types.spreadElement(self.explodeViaTempVar(null, elemPath.get(\"argument\"), hasLeapingChildren));\n          } else {\n            return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);\n          }\n        })));\n      case \"SequenceExpression\":\n        const lastIndex = path.node.expressions.length - 1;\n        path.get(\"expressions\").forEach(function (exprPath) {\n          if (exprPath.key === lastIndex) {\n            result = self.explodeExpression(exprPath, ignoreResult);\n          } else {\n            self.explodeExpression(exprPath, true);\n          }\n        });\n        return result;\n      case \"LogicalExpression\":\n        after = this.loc();\n        if (!ignoreResult) {\n          result = self.makeTempVar();\n        }\n        const left = self.explodeViaTempVar(result, path.get(\"left\"), hasLeapingChildren);\n        if (path.node.operator === \"&&\") {\n          self.jumpIfNot(left, after);\n        } else {\n          _assert.strictEqual(path.node.operator, \"||\");\n          self.jumpIf(left, after);\n        }\n        self.explodeViaTempVar(result, path.get(\"right\"), hasLeapingChildren, ignoreResult);\n        self.mark(after);\n        return result;\n      case \"ConditionalExpression\":\n        const elseLoc = this.loc();\n        after = this.loc();\n        const test = self.explodeExpression(path.get(\"test\"));\n        self.jumpIfNot(test, elseLoc);\n        if (!ignoreResult) {\n          result = self.makeTempVar();\n        }\n        self.explodeViaTempVar(result, path.get(\"consequent\"), hasLeapingChildren, ignoreResult);\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeViaTempVar(result, path.get(\"alternate\"), hasLeapingChildren, ignoreResult);\n        self.mark(after);\n        return result;\n      case \"UnaryExpression\":\n        return finish(_core.types.unaryExpression(path.node.operator, self.explodeExpression(path.get(\"argument\")), !!path.node.prefix));\n      case \"BinaryExpression\":\n        return finish(_core.types.binaryExpression(path.node.operator, self.explodeViaTempVar(null, path.get(\"left\"), hasLeapingChildren), self.explodeViaTempVar(null, path.get(\"right\"), hasLeapingChildren)));\n      case \"AssignmentExpression\":\n        if (path.node.operator === \"=\") {\n          return finish(_core.types.assignmentExpression(path.node.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n        }\n        const lhs = self.explodeExpression(path.get(\"left\"));\n        const temp = self.emitAssign(self.makeTempVar(), lhs);\n        return finish(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(lhs), _core.types.assignmentExpression(path.node.operator, _core.types.cloneNode(temp), self.explodeExpression(path.get(\"right\")))));\n      case \"UpdateExpression\":\n        return finish(_core.types.updateExpression(path.node.operator, self.explodeExpression(path.get(\"argument\")), path.node.prefix));\n      case \"YieldExpression\":\n        after = this.loc();\n        const arg = path.node.argument && self.explodeExpression(path.get(\"argument\"));\n        if (arg && path.node.delegate) {\n          if (util.newHelpersAvailable(this.pluginPass)) {\n            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty(\"d\"), [_core.types.callExpression(this.pluginPass.addHelper(\"regeneratorValues\"), [arg]), after]));\n            ret.loc = expr.loc;\n            self.emit(ret);\n            self.mark(after);\n            return self.contextProperty(\"v\");\n          } else {\n            const result = self.makeContextTempVar();\n            const ret = _core.types.returnStatement(_core.types.callExpression(self.contextProperty(\"delegateYield\"), [arg, _core.types.stringLiteral(result.property.name), after]));\n            ret.loc = expr.loc;\n            self.emit(ret);\n            self.mark(after);\n            return result;\n          }\n        }\n        self.emitAssign(self.contextProperty(util.newHelpersAvailable(this.pluginPass) ? \"n\" : \"next\"), after);\n        const ret = _core.types.returnStatement(_core.types.cloneNode(arg) || null);\n        ret.loc = expr.loc;\n        self.emit(ret);\n        self.mark(after);\n        return self.contextProperty(util.newHelpersAvailable(self.pluginPass) ? \"v\" : \"sent\");\n      case \"ClassExpression\":\n        return finish(self.explodeClass(path));\n      default:\n        throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n    }\n  }\n  explodeClass(path) {\n    const explodingChildren = [];\n    if (path.node.superClass) {\n      explodingChildren.push(path.get(\"superClass\"));\n    }\n    path.get(\"body.body\").forEach(member => {\n      if (member.node.computed) {\n        explodingChildren.push(member.get(\"key\"));\n      }\n    });\n    const hasLeapingChildren = explodingChildren.some(child => meta.containsLeap(child.node));\n    for (let i = 0; i < explodingChildren.length; i++) {\n      const child = explodingChildren[i];\n      const isLast = i === explodingChildren.length - 1;\n      if (isLast) {\n        child.replaceWith(this.explodeExpression(child));\n      } else {\n        child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));\n      }\n    }\n    return path.node;\n  }\n}\nexports.Emitter = Emitter;\n\n//# sourceMappingURL=emit.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TryEntry = exports.SwitchEntry = exports.LoopEntry = exports.LeapManager = exports.LabeledEntry = exports.FunctionEntry = exports.FinallyEntry = exports.Entry = exports.CatchEntry = void 0;\nvar _assert = require(\"assert\");\nclass Entry {}\nexports.Entry = Entry;\nclass FunctionEntry extends Entry {\n  constructor(returnLoc) {\n    super();\n    this.returnLoc = void 0;\n    this.returnLoc = returnLoc;\n  }\n}\nexports.FunctionEntry = FunctionEntry;\nclass LoopEntry extends Entry {\n  constructor(breakLoc, continueLoc, label = null) {\n    super();\n    this.breakLoc = void 0;\n    this.continueLoc = void 0;\n    this.label = void 0;\n    this.breakLoc = breakLoc;\n    this.continueLoc = continueLoc;\n    this.label = label;\n  }\n}\nexports.LoopEntry = LoopEntry;\nclass SwitchEntry extends Entry {\n  constructor(breakLoc) {\n    super();\n    this.breakLoc = void 0;\n    this.breakLoc = breakLoc;\n  }\n}\nexports.SwitchEntry = SwitchEntry;\nclass TryEntry extends Entry {\n  constructor(firstLoc, catchEntry = null, finallyEntry = null) {\n    super();\n    this.firstLoc = void 0;\n    this.catchEntry = void 0;\n    this.finallyEntry = void 0;\n    _assert.ok(catchEntry || finallyEntry);\n    this.firstLoc = firstLoc;\n    this.catchEntry = catchEntry;\n    this.finallyEntry = finallyEntry;\n  }\n}\nexports.TryEntry = TryEntry;\nclass CatchEntry extends Entry {\n  constructor(firstLoc, paramId) {\n    super();\n    this.firstLoc = void 0;\n    this.paramId = void 0;\n    this.firstLoc = firstLoc;\n    this.paramId = paramId;\n  }\n}\nexports.CatchEntry = CatchEntry;\nclass FinallyEntry extends Entry {\n  constructor(firstLoc, afterLoc) {\n    super();\n    this.firstLoc = void 0;\n    this.afterLoc = void 0;\n    this.firstLoc = firstLoc;\n    this.afterLoc = afterLoc;\n  }\n}\nexports.FinallyEntry = FinallyEntry;\nclass LabeledEntry extends Entry {\n  constructor(breakLoc, label) {\n    super();\n    this.breakLoc = void 0;\n    this.label = void 0;\n    this.breakLoc = breakLoc;\n    this.label = label;\n  }\n}\nexports.LabeledEntry = LabeledEntry;\nclass LeapManager {\n  constructor(emitter) {\n    this.emitter = void 0;\n    this.entryStack = void 0;\n    this.emitter = emitter;\n    this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n  }\n  withEntry(entry, callback) {\n    this.entryStack.push(entry);\n    try {\n      callback.call(this.emitter);\n    } finally {\n      const popped = this.entryStack.pop();\n      _assert.strictEqual(popped, entry);\n    }\n  }\n  _findLeapLocation(property, label) {\n    for (let i = this.entryStack.length - 1; i >= 0; --i) {\n      const entry = this.entryStack[i];\n      const loc = entry[property];\n      if (loc) {\n        if (label) {\n          if (entry.label && entry.label.name === label.name) {\n            return loc;\n          }\n        } else if (entry instanceof LabeledEntry) {} else {\n          return loc;\n        }\n      }\n    }\n    return null;\n  }\n  getBreakLoc(label) {\n    return this._findLeapLocation(\"breakLoc\", label);\n  }\n  getContinueLoc(label) {\n    return this._findLeapLocation(\"continueLoc\", label);\n  }\n}\nexports.LeapManager = LeapManager;\n\n//# sourceMappingURL=leap.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSideEffects = exports.containsLeap = void 0;\nvar _assert = require(\"assert\");\nvar _core = require(\"@babel/core\");\nconst mMap = new WeakMap();\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n  return mMap.get(node);\n}\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    _core.types.assertNode(node);\n    let result = false;\n    function check(child) {\n      if (result) {} else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (_core.types.isNode(child)) {\n        _assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n    const keys = _core.types.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = node[key];\n        check(child);\n      }\n    }\n    return result;\n  }\n  function predicate(node) {\n    _core.types.assertNode(node);\n    const meta = m(node);\n    if (hasOwnProperty.call(meta, propertyName)) return meta[propertyName];\n    if (hasOwnProperty.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwnProperty.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\nconst opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\nconst sideEffectTypes = {\n  CallExpression: true,\n  ForInStatement: true,\n  UnaryExpression: true,\n  BinaryExpression: true,\n  AssignmentExpression: true,\n  UpdateExpression: true,\n  NewExpression: true\n};\nconst leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\nfor (const type in leapTypes) {\n  if (hasOwnProperty.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\nconst hasSideEffects = exports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nconst containsLeap = exports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n\n//# sourceMappingURL=meta.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isReference = isReference;\nexports.runtimeProperty = exports.newHelpersAvailable = void 0;\nvar _core = require(\"@babel/core\");\nlet newHelpersAvailable = exports.newHelpersAvailable = void 0;\nexports.newHelpersAvailable = newHelpersAvailable = file => {\n  return file.availableHelper(\"regenerator\") && !_core.types.isIdentifier(file.addHelper(\"regenerator\"), {\n    name: \"__interal_marker_fallback_regenerator__\"\n  });\n};\nlet runtimeProperty = exports.runtimeProperty = void 0;\nexports.runtimeProperty = runtimeProperty = function (file, name) {\n  const helper = file.addHelper(\"regeneratorRuntime\");\n  return _core.types.memberExpression(_core.types.isArrowFunctionExpression(helper) && _core.types.isIdentifier(helper.body) ? helper.body : _core.types.callExpression(helper, []), _core.types.identifier(name), false);\n};\nfunction isReference(path) {\n  return path.isReferenced() || path.parentPath.isAssignmentExpression({\n    left: path.node\n  });\n}\n\n//# sourceMappingURL=util.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = replaceShorthandObjectMethod;\nvar _core = require(\"@babel/core\");\nfunction replaceShorthandObjectMethod(path) {\n  if (!path.node || !_core.types.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  }\n  if (!_core.types.isObjectMethod(path.node)) {\n    return path;\n  }\n  if (!path.node.generator) {\n    return path;\n  }\n  const parameters = path.node.params.map(function (param) {\n    return _core.types.cloneNode(param);\n  });\n  const functionExpression = _core.types.functionExpression(null, parameters, _core.types.cloneNode(path.node.body), path.node.generator, path.node.async);\n  path.replaceWith(_core.types.objectProperty(_core.types.cloneNode(path.node.key), functionExpression, path.node.computed, false));\n  return path.get(\"value\");\n}\n\n//# sourceMappingURL=replaceShorthandObjectMethod.js.map\n"]}