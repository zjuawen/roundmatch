{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\nvar _core = require(\"@babel/core\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _options$allowArrayLi;\n  api.assertVersion(7);\n  const iterableIsArray = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose;\n  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\");\n  function getSpreadLiteral(spread, scope) {\n    if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {\n      name: \"arguments\"\n    })) {\n      return spread.argument;\n    } else {\n      const node = spread.argument;\n      if (_core.types.isIdentifier(node)) {\n        const binding = scope.getBinding(node.name);\n        if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n      if (_core.types.isArrayExpression(node)) {\n        return node;\n      }\n      if (_core.types.isIdentifier(node, {\n        name: \"arguments\"\n      })) {\n        return _core.template.expression.ast`\n          Array.prototype.slice.call(${node})\n        `;\n      }\n      const args = [node];\n      let helperName = \"toConsumableArray\";\n      if (arrayLikeIsIterable) {\n        args.unshift(scope.path.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n      return _core.types.callExpression(scope.path.hub.addHelper(helperName), args);\n    }\n  }\n  function hasHole(spread) {\n    return spread.elements.includes(null);\n  }\n  function hasSpread(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (_core.types.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function push(_props, nodes) {\n    if (!_props.length) return _props;\n    nodes.push(_core.types.arrayExpression(_props));\n    return [];\n  }\n  function build(props, scope, file) {\n    const nodes = [];\n    let _props = [];\n    for (const prop of props) {\n      if (_core.types.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n        if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = _core.types.callExpression(file.addHelper(\"arrayWithoutHoles\"), [spreadLiteral]);\n        }\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n    push(_props, nodes);\n    return nodes;\n  }\n  return {\n    name: \"transform-spread\",\n    visitor: {\n      ArrayExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n        if (nodes.length === 1 && first !== elements[0].argument) {\n          path.replaceWith(first);\n          return;\n        }\n        if (!_core.types.isArrayExpression(first)) {\n          first = _core.types.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n      },\n      CallExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const args = node.arguments;\n        if (!hasSpread(args)) return;\n        const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"callee\"));\n        if (calleePath.isSuper()) {\n          throw path.buildCodeFrameError(\"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n        }\n        let contextLiteral = scope.buildUndefinedNode();\n        node.arguments = [];\n        let nodes;\n        if (args.length === 1 && _core.types.isIdentifier(args[0].argument, {\n          name: \"arguments\"\n        })) {\n          nodes = [args[0].argument];\n        } else {\n          nodes = build(args, scope, this.file);\n        }\n        const first = nodes.shift();\n        if (nodes.length) {\n          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n        } else {\n          node.arguments.push(first);\n        }\n        const callee = calleePath.node;\n        if (_core.types.isMemberExpression(callee)) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n          if (temp) {\n            callee.object = _core.types.assignmentExpression(\"=\", temp, callee.object);\n            contextLiteral = temp;\n          } else {\n            contextLiteral = _core.types.cloneNode(callee.object);\n          }\n        }\n        node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"apply\"));\n        if (_core.types.isSuper(contextLiteral)) {\n          contextLiteral = _core.types.thisExpression();\n        }\n        node.arguments.unshift(_core.types.cloneNode(contextLiteral));\n      },\n      NewExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (!hasSpread(node.arguments)) return;\n        const nodes = build(node.arguments, scope, this.file);\n        const first = nodes.shift();\n        let args;\n        if (nodes.length) {\n          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes);\n        } else {\n          args = first;\n        }\n        path.replaceWith(_core.types.callExpression(path.hub.addHelper(\"construct\"), [node.callee, args]));\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n"]}