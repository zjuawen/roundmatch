{"version":3,"sources":["index.js","params.js","shadow-utils.js","rest.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"convertFunctionParams\", {\n  enumerable: true,\n  get: function () {\n    return _params.default;\n  }\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _params = require(\"./params.js\");\nvar _rest = require(\"./rest.js\");\nvar _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(7);\n  const ignoreFunctionLength = (_api$assumption = api.assumption(\"ignoreFunctionLength\")) != null ? _api$assumption : options.loose;\n  const noNewArrows = (_api$assumption2 = api.assumption(\"noNewArrows\")) != null ? _api$assumption2 : true;\n  return {\n    name: \"transform-parameters\",\n    visitor: {\n      Function(path) {\n        if (path.isArrowFunctionExpression() && path.get(\"params\").some(param => param.isRestElement() || param.isAssignmentPattern())) {\n          path.arrowFunctionToExpression({\n            allowInsertArrowWithRest: false,\n            noNewArrows\n          });\n          if (!path.isFunctionExpression()) return;\n        }\n        const convertedRest = (0, _rest.default)(path);\n        const convertedParams = (0, _params.default)(path, ignoreFunctionLength);\n        if (convertedRest || convertedParams) {\n          path.scope.crawl();\n        }\n      }\n    }\n  };\n});\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\nvar _core = require(\"@babel/core\");\nvar _shadowUtils = require(\"./shadow-utils.js\");\nconst buildDefaultParam = _core.template.statement(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\nconst buildLooseDefaultParam = _core.template.statement(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\nconst buildLooseDestructuredDefaultParam = _core.template.statement(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\nconst buildSafeArgumentsAccess = _core.template.statement(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\nfunction convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const body = [];\n  const shadowedParams = new Set();\n  for (const param of params) {\n    (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);\n  }\n  const state = {\n    needsOuterBinding: false,\n    scope\n  };\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n  let firstOptionalIndex = null;\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n    const transformedRestNodes = [];\n    if (replaceRestElement) {\n      replaceRestElement(path, param, transformedRestNodes);\n    }\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n    if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {\n      kind: \"set\"\n    }))) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n      uid.typeAnnotation = param.node.typeAnnotation;\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n  path.ensureBlock();\n  const path2 = path;\n  const {\n    async,\n    generator\n  } = node;\n  if (generator || state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path2.node.body));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path2.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = generator;\n    arrowPath.node.async = async;\n    node.generator = false;\n    node.async = false;\n    if (async && !generator) {\n      path2.node.body = _core.template.statement.ast`{\n        try {\n          ${path2.node.body.body}\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }`;\n    }\n  } else {\n    path2.get(\"body\").unshiftContainer(\"body\", body);\n  }\n  return true;\n}\n\n//# sourceMappingURL=params.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildScopeIIFE = buildScopeIIFE;\nexports.collectShadowedParamsNames = collectShadowedParamsNames;\nexports.iifeVisitor = void 0;\nvar _core = require(\"@babel/core\");\nconst iifeVisitor = exports.iifeVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      name\n    } = node;\n    if (name === \"eval\" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\": path => path.skip()\n};\nfunction collectShadowedParamsNames(param, functionScope, shadowedParams) {\n  for (const name of Object.keys(param.getBindingIdentifiers())) {\n    var _functionScope$bindin;\n    const constantViolations = (_functionScope$bindin = functionScope.bindings[name]) == null ? void 0 : _functionScope$bindin.constantViolations;\n    if (constantViolations) {\n      for (const redeclarator of constantViolations) {\n        const node = redeclarator.node;\n        switch (node.type) {\n          case \"VariableDeclarator\":\n            {\n              if (node.init === null) {\n                const declaration = redeclarator.parentPath;\n                if (!declaration.parentPath.isFor() || declaration.parentPath.get(\"body\") === declaration) {\n                  redeclarator.remove();\n                  break;\n                }\n              }\n              shadowedParams.add(name);\n              break;\n            }\n          case \"FunctionDeclaration\":\n            shadowedParams.add(name);\n            break;\n        }\n      }\n    }\n  }\n}\nfunction buildScopeIIFE(shadowedParams, body) {\n  const args = [];\n  const params = [];\n  for (const name of shadowedParams) {\n    args.push(_core.types.identifier(name));\n    params.push(_core.types.identifier(name));\n  }\n  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));\n}\n\n//# sourceMappingURL=shadow-utils.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\nvar _core = require(\"@babel/core\");\nvar _shadowUtils = require(\"./shadow-utils.js\");\nconst buildRest = _core.template.statement(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\nconst restIndex = _core.template.expression(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\nconst restIndexImpure = _core.template.expression(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\nconst restLength = _core.template.expression(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n  return false;\n}\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n    if (!referencesRest(path, state)) return;\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n      state.references.push(path);\n    }\n  },\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n};\nfunction getParamsCount(node) {\n  let count = node.params.length;\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n  return count;\n}\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n  let index;\n  const parent = path.parent;\n  if (_core.types.isNumericLiteral(parent.property)) {\n    index = _core.types.numericLiteral(parent.property.value + offset);\n  } else if (offset === 0) {\n    index = parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n  const {\n    scope,\n    parentPath\n  } = path;\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const replacedParentPath = parentPath;\n    const offsetTestPath = replacedParentPath.get(\"test\");\n    const valRes = offsetTestPath.get(\"left\").evaluate();\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        replacedParentPath.replaceWith(scope.buildUndefinedNode());\n      } else {\n        offsetTestPath.replaceWith(offsetTestPath.get(\"right\"));\n      }\n    }\n  }\n}\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  const restPath = path.get(`params.${node.params.length - 1}.argument`);\n  if (!restPath.isIdentifier()) {\n    const shadowedParams = new Set();\n    (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);\n    let needsIIFE = shadowedParams.size > 0;\n    if (!needsIIFE) {\n      const state = {\n        needsOuterBinding: false,\n        scope\n      };\n      restPath.traverse(_shadowUtils.iifeVisitor, state);\n      needsIIFE = state.needsOuterBinding;\n    }\n    if (needsIIFE) {\n      path.ensureBlock();\n      path.set(\"body\", _core.types.blockStatement([(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)]));\n    }\n  }\n  let rest = restPath.node;\n  node.params.pop();\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n    path.ensureBlock();\n    node.body.body.unshift(declar);\n  } else if (rest.name === \"arguments\") {\n    scope.rename(rest.name);\n  }\n  const argsId = _core.types.identifier(\"arguments\");\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n    return true;\n  }\n  state.references.push(...state.candidates.map(({\n    path\n  }) => path));\n  const start = _core.types.numericLiteral(paramsCount);\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n  return true;\n}\n\n//# sourceMappingURL=rest.js.map\n"]}