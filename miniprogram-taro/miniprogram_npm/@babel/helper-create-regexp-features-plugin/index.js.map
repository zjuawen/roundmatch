{"version":3,"sources":["index.js","features.js","util.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\nvar _regexpuCore = require(\"regexpu-core\");\nvar _core = require(\"@babel/core\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _semver = require(\"semver\");\nvar _features = require(\"./features.js\");\nvar _util = require(\"./util.js\");\nconst versionKey = \"@babel/plugin-regexp-features/version\";\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {},\n  manipulateOptions = () => {}\n}) {\n  return {\n    name,\n    manipulateOptions,\n    pre() {\n      var _file$get;\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime\n      } = options;\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n      if (runtime !== undefined) {\n        if (file.has(_features.runtimeKey) && file.get(_features.runtimeKey) !== runtime && (0, _features.hasFeature)(newFeatures, _features.FEATURES.duplicateNamedCaptureGroups)) {\n          throw new Error(`The 'runtime' option must be the same for ` + `'@babel/plugin-transform-named-capturing-groups-regex' and ` + `'@babel/plugin-transform-duplicate-named-capturing-groups-regex'.`);\n        }\n        if (feature === \"namedCaptureGroups\") {\n          if (!runtime || !file.has(_features.runtimeKey)) file.set(_features.runtimeKey, runtime);\n        } else {\n          file.set(_features.runtimeKey, runtime);\n        }\n      }\n      {\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, \"7.28.5\");\n          return;\n        }\n      }\n      if (!file.get(versionKey) || _semver.lt(file.get(versionKey), \"7.28.5\")) {\n        file.set(versionKey, \"7.28.5\");\n      }\n    },\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node.pattern, features);\n        if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) {\n          return;\n        }\n        const namedCaptureGroups = {\n          __proto__: null\n        };\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n        let newFlags;\n        if (regexpuOptions.modifiers === \"transform\") {\n          regexpuOptions.onNewFlags = flags => {\n            newFlags = flags;\n          };\n        }\n        node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);\n        if (regexpuOptions.namedGroups === \"transform\" && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n        node.flags = (0, _util.transformFlags)(regexpuOptions, newFlags != null ? newFlags : node.flags);\n      }\n    }\n  };\n}\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FEATURES = void 0;\nexports.enableFeature = enableFeature;\nexports.featuresKey = void 0;\nexports.hasFeature = hasFeature;\nexports.runtimeKey = void 0;\nconst FEATURES = exports.FEATURES = Object.freeze({\n  unicodeFlag: 1 << 0,\n  dotAllFlag: 1 << 1,\n  unicodePropertyEscape: 1 << 2,\n  namedCaptureGroups: 1 << 3,\n  unicodeSetsFlag_syntax: 1 << 4,\n  unicodeSetsFlag: 1 << 5,\n  duplicateNamedCaptureGroups: 1 << 6,\n  modifiers: 1 << 7\n});\nconst featuresKey = exports.featuresKey = \"@babel/plugin-regexp-features/featuresKey\";\nconst runtimeKey = exports.runtimeKey = \"@babel/plugin-regexp-features/runtimeKey\";\nfunction enableFeature(features, feature) {\n  return features | feature;\n}\nfunction hasFeature(features, feature) {\n  return !!(features & feature);\n}\n\n//# sourceMappingURL=features.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canSkipRegexpu = canSkipRegexpu;\nexports.generateRegexpuOptions = generateRegexpuOptions;\nexports.transformFlags = transformFlags;\nvar _features = require(\"./features.js\");\nfunction generateRegexpuOptions(pattern, toTransform) {\n  const feat = name => {\n    return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? \"transform\" : false;\n  };\n  const featDuplicateNamedGroups = () => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n    const regex = /\\(\\?<([^>]+)(>|$)/g;\n    const seen = new Set();\n    for (let match; (match = regex.exec(pattern)) && match[2]; seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n    return false;\n  };\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag: feat(\"unicodeSetsFlag\"),\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {},\n    modifiers: feat(\"modifiers\")\n  };\n}\nfunction canSkipRegexpu(node, options) {\n  const {\n    flags,\n    pattern\n  } = node;\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n    if (options.unicodePropertyEscapes === \"transform\" && /\\\\p\\{/i.test(pattern)) {\n      return false;\n    }\n  }\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n  if (options.modifiers === \"transform\" && /\\(\\?[\\w-]+:/.test(pattern)) {\n    return false;\n  }\n  return true;\n}\nfunction transformFlags(regexpuOptions, flags) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n  return flags;\n}\n\n//# sourceMappingURL=util.js.map\n"]}