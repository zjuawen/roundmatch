{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar core = require('@babel/core');\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\n\nfunction isNameOrLength(key) {\n  if (core.types.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (core.types.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\nfunction isStaticFieldWithValue(node) {\n  return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;\n}\nconst hasReferenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, {\n    name\n  }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  }\n};\nfunction isReferenceOrThis(node, name) {\n  return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {\n    name\n  });\n}\nconst hasReferenceOrThisVisitor = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      if (path.requeueComputedKeyAndDecorators) {\n        path.requeueComputedKeyAndDecorators();\n      } else {\n        require(\"@babel/traverse\").NodePath.prototype.requeueComputedKeyAndDecorators.call(path);\n      }\n    }\n  }\n};\nfunction getPotentiallyBuggyFieldsIndexes(path) {\n  var _path$node$id;\n  const buggyPublicStaticFieldsIndexes = [];\n  let classReferenced = false;\n  const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;\n  const hasReferenceState = {\n    name: className,\n    ref: () => classReferenced = true\n  };\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if (el.node.computed) {\n        el.get(\"key\").traverse(hasReferenceVisitor, hasReferenceState);\n        if (classReferenced) break;\n      }\n    }\n  }\n  let nextPotentiallyBuggy = false;\n  const {\n    body\n  } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (!nextPotentiallyBuggy) {\n      if (core.types.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            path.get(`body.body.${i}.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n    if (core.types.isClassProperty(node, {\n      static: true\n    }) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n  return buggyPublicStaticFieldsIndexes;\n}\nfunction getNameOrLengthStaticFieldsIndexes(path) {\n  const indexes = [];\n  const {\n    body\n  } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (core.types.isClassProperty(node, {\n      static: true,\n      computed: false\n    }) && isNameOrLength(node.key)) {\n      indexes.push(i);\n    }\n  }\n  return indexes;\n}\nfunction toRanges(nums) {\n  const ranges = [];\n  if (nums.length === 0) return ranges;\n  let start = nums[0];\n  let end = start + 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      throw new Error(\"Internal Babel error: nums must be in ascending order\");\n    }\n    if (nums[i] === end) {\n      end++;\n    } else {\n      ranges.push([start, end]);\n      start = nums[i];\n      end = start + 1;\n    }\n  }\n  ranges.push([start, end]);\n  return ranges;\n}\n\nfunction buildFieldsReplacement(fields, scope, file) {\n  return core.types.staticBlock(fields.map(field => {\n    const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);\n    return core.types.expressionStatement(core.types.callExpression(file.addHelper(\"defineProperty\"), [core.types.thisExpression(), key, field.value || scope.buildUndefinedNode()]));\n  }));\n}\nvar index = helperPluginUtils.declare(api => {\n  api.assertVersion(\"^7.0.0-0 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  return {\n    name: \"bugfix-v8-static-class-fields-redefine-readonly\",\n    visitor: {\n      Class(path) {\n        const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));\n        for (let i = ranges.length - 1; i >= 0; i--) {\n          const [start, end] = ranges[i];\n          const startPath = path.get(\"body.body\")[start];\n          startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));\n          for (let j = end - 1; j > start; j--) {\n            path.get(\"body.body\")[j].remove();\n          }\n        }\n      }\n    }\n  };\n});\n\nexports.default = index;\n//# sourceMappingURL=index.js.map\n"]}