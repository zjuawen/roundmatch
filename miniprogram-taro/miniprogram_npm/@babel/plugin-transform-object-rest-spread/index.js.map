{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\nvar pluginTransformParameters = require('@babel/plugin-transform-parameters');\nvar helperCompilationTargets = require('@babel/helper-compilation-targets');\nvar pluginTransformDestructuring = require('@babel/plugin-transform-destructuring');\n\nfunction shouldStoreRHSInTemporaryVariable(node) {\n  if (!node) return false;\n  if (node.type === \"ArrayPattern\") {\n    const nonNullElements = node.elements.filter(element => element !== null && element.type !== \"VoidPattern\");\n    if (nonNullElements.length > 1) return true;else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (node.type === \"ObjectPattern\") {\n    const {\n      properties\n    } = node;\n    if (properties.length > 1) return true;else if (properties.length === 0) return false;else {\n      const firstProperty = properties[0];\n      if (firstProperty.type === \"ObjectProperty\") {\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (node.type === \"AssignmentPattern\") {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (node.type === \"RestElement\") {\n    if (node.argument.type === \"Identifier\") return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    return false;\n  }\n}\n\nvar compatData = {\n  \"Object.assign\": {\n    chrome: \"49\",\n    opera: \"36\",\n    edge: \"13\",\n    firefox: \"36\",\n    safari: \"10\",\n    node: \"6\",\n    deno: \"1\",\n    ios: \"10\",\n    samsung: \"5\",\n    opera_mobile: \"36\",\n    electron: \"0.37\"\n  }\n};\n\nconst node = core.types.identifier(\"a\");\nconst property = core.types.objectProperty(core.types.identifier(\"key\"), node);\nconst pattern = core.types.objectPattern([property]);\nvar ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;\nvar index = helperPluginUtils.declare((api, opts) => {\n  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;\n  api.assertVersion(\"^7.0.0-0 || ^8.0.0-0 || >8.0.0-alpha <8.0.0-beta\");\n  const targets = api.targets();\n  const supportsObjectAssign = !helperCompilationTargets.isRequired(\"Object.assign\", targets, {\n    compatData\n  });\n  const {\n    useBuiltIns = supportsObjectAssign,\n    loose = false\n  } = opts;\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n  const ignoreFunctionLength = (_api$assumption = api.assumption(\"ignoreFunctionLength\")) != null ? _api$assumption : loose;\n  const objectRestNoSymbols = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : loose;\n  const pureGetters = (_api$assumption3 = api.assumption(\"pureGetters\")) != null ? _api$assumption3 : loose;\n  const setSpreadProperties = (_api$assumption4 = api.assumption(\"setSpreadProperties\")) != null ? _api$assumption4 : loose;\n  function getExtendsHelper(file) {\n    return useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n  function* iterateObjectRestElement(path) {\n    switch (path.type) {\n      case \"ArrayPattern\":\n        for (const elementPath of path.get(\"elements\")) {\n          if (elementPath.isRestElement()) {\n            yield* iterateObjectRestElement(elementPath.get(\"argument\"));\n          } else {\n            yield* iterateObjectRestElement(elementPath);\n          }\n        }\n        break;\n      case \"ObjectPattern\":\n        for (const propertyPath of path.get(\"properties\")) {\n          if (propertyPath.isRestElement()) {\n            yield propertyPath;\n          } else {\n            yield* iterateObjectRestElement(propertyPath.get(\"value\"));\n          }\n        }\n        break;\n      case \"AssignmentPattern\":\n        yield* iterateObjectRestElement(path.get(\"left\"));\n        break;\n    }\n  }\n  function hasObjectRestElement(path) {\n    const objectRestPatternIterator = iterateObjectRestElement(path);\n    return !objectRestPatternIterator.next().done;\n  }\n  function visitObjectRestElements(path, visitor) {\n    for (const restElementPath of iterateObjectRestElement(path)) {\n      visitor(restElementPath);\n    }\n  }\n  function hasSpread(node) {\n    for (const prop of node.properties) {\n      if (core.types.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function extractNormalizedKeys(pattern) {\n    const propsList = pattern.get(\"properties\").map(p => p.node);\n    const keys = [];\n    let allPrimitives = true;\n    let hasTemplateLiteral = false;\n    for (const prop of propsList) {\n      const key = prop.key;\n      if (core.types.isIdentifier(key) && !prop.computed) {\n        keys.push(core.types.stringLiteral(key.name));\n      } else if (core.types.isTemplateLiteral(key)) {\n        keys.push(core.types.cloneNode(key));\n        hasTemplateLiteral = true;\n      } else if (core.types.isLiteral(key)) {\n        keys.push(core.types.stringLiteral(String(key.value)));\n      } else {\n        if (core.types.isAssignmentExpression(key) && core.types.isIdentifier(key.left)) {\n          keys.push(core.types.cloneNode(key.left));\n        } else {\n          keys.push(core.types.cloneNode(key));\n        }\n        const keyToCheck = core.types.isAssignmentExpression(key) ? key.right : key;\n        if (core.types.isMemberExpression(keyToCheck, {\n          computed: false\n        }) && core.types.isIdentifier(keyToCheck.object, {\n          name: \"Symbol\"\n        }) || core.types.isCallExpression(keyToCheck) && core.types.matchesPattern(keyToCheck.callee, \"Symbol.for\")) ; else {\n          allPrimitives = false;\n        }\n      }\n    }\n    return {\n      keys,\n      allPrimitives,\n      hasTemplateLiteral\n    };\n  }\n  function replaceImpureComputedKeys(properties, scope) {\n    const tempVariableDeclarations = [];\n    for (const property of properties) {\n      const keyExpression = property.get(\"key\");\n      if (keyExpression.isAssignmentExpression() && keyExpression.get(\"left\").isIdentifier()) {\n        const identName = keyExpression.node.left.name;\n        if (scope.hasUid(identName)) {\n          continue;\n        }\n      }\n      if (property.node.computed && !keyExpression.isPure()) {\n        const tempVariableName = scope.generateUidBasedOnNode(keyExpression.node);\n        const tempVariableDeclaration = core.types.variableDeclarator(core.types.identifier(tempVariableName), keyExpression.node);\n        tempVariableDeclarations.push(tempVariableDeclaration);\n        keyExpression.replaceWith(core.types.identifier(tempVariableName));\n      }\n    }\n    return tempVariableDeclarations;\n  }\n  function removeUnusedExcludedKeys(path) {\n    const bindings = path.getOuterBindingIdentifierPaths();\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n  function collectComputedKeysInSourceOrder(destructuringPattern) {\n    const computedProperties = [];\n    function visitPattern(pattern) {\n      if (pattern.isObjectPattern()) {\n        const properties = pattern.get(\"properties\");\n        for (const property of properties) {\n          if (property.isRestElement()) continue;\n          if (property.node.computed) {\n            computedProperties.push(property);\n          }\n          const nestedPattern = property.get(\"value\");\n          visitPattern(nestedPattern);\n        }\n      } else if (pattern.isArrayPattern()) {\n        for (const element of pattern.get(\"elements\")) {\n          if (!element) continue;\n          if (element.isRestElement()) {\n            const restArgument = element.get(\"argument\");\n            visitPattern(restArgument);\n          } else {\n            visitPattern(element);\n          }\n        }\n      } else if (pattern.isAssignmentPattern()) {\n        visitPattern(pattern.get(\"left\"));\n      }\n    }\n    visitPattern(destructuringPattern);\n    return computedProperties;\n  }\n  function createObjectRest(path, file, objRef) {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    core.types.assertRestElement(last.node);\n    const restElement = core.types.cloneNode(last.node);\n    last.remove();\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get(\"properties\"), path.scope);\n    const {\n      keys,\n      allPrimitives,\n      hasTemplateLiteral\n    } = extractNormalizedKeys(path);\n    if (keys.length === 0) {\n      return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(getExtendsHelper(file), [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])])];\n    }\n    let keyExpression;\n    if (!allPrimitives) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier(\"map\")), [file.addHelper(\"toPropertyKey\")]);\n    } else {\n      keyExpression = core.types.arrayExpression(keys);\n      if (!hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\"\n        });\n        keyExpression = core.types.cloneNode(id);\n      }\n    }\n    return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression])];\n  }\n  function replaceRestElement(parentPath, paramPath, container) {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n    if (paramPath.isArrayPattern() && hasObjectRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n    if (paramPath.isObjectPattern() && hasObjectRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n      const declar = core.types.variableDeclaration(\"let\", [core.types.variableDeclarator(paramPath.node, uid)]);\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n      paramPath.replaceWith(core.types.cloneNode(uid));\n    }\n  }\n  return {\n    name: \"transform-object-rest-spread\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"objectRestSpread\"),\n    visitor: {\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasObjectRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n        let idInRest = false;\n        const IdentifierHandler = function (path, functionScope) {\n          const name = path.node.name;\n          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n        let i;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse({\n                \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler\n              }, path.scope);\n            }\n          }\n        }\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);\n          pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);\n        }\n      },\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n        let insertionPath = path;\n        const originalPath = path;\n        if (hasObjectRestElement(path.get(\"id\"))) {\n          const destructuringPattern = originalPath.get(\"id\");\n          const propertiesWithComputedKeys = collectComputedKeysInSourceOrder(destructuringPattern);\n          for (const property of propertiesWithComputedKeys) {\n            const computedKeyExpression = property.get(\"key\");\n            if (computedKeyExpression.isAssignmentExpression() && computedKeyExpression.get(\"left\").isIdentifier() && originalPath.scope.hasUid(computedKeyExpression.node.left.name)) {\n              continue;\n            }\n            if (!computedKeyExpression.isPure()) {\n              const tempVariableName = originalPath.scope.generateUidBasedOnNode(computedKeyExpression.node);\n              const tempIdentifier = core.types.identifier(tempVariableName);\n              originalPath.scope.push({\n                id: tempIdentifier,\n                kind: \"var\"\n              });\n              computedKeyExpression.replaceWith(core.types.assignmentExpression(\"=\", core.types.cloneNode(tempIdentifier), computedKeyExpression.node));\n            }\n          }\n        }\n        visitObjectRestElements(path.get(\"id\"), path => {\n          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, \"ref\");\n            originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init));\n            originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));\n            return;\n          }\n          let ref = originalPath.node.init;\n          const refPropertyPath = [];\n          let kind;\n          path.findParent(path => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);\n          refPropertyPath.forEach(prop => {\n            const keyPath = prop.get(\"key\");\n            let keyForMemberExpression = keyPath.node;\n            if (core.types.isAssignmentExpression(keyPath.node)) {\n              keyForMemberExpression = keyPath.node.left;\n            }\n            ref = core.types.memberExpression(ref, core.types.cloneNode(keyForMemberExpression), prop.node.computed || core.types.isLiteral(keyPath.node));\n          });\n          const objectPatternPath = path.parentPath;\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n          core.types.assertIdentifier(argument);\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n          insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0];\n          path.scope.registerBinding(kind, insertionPath);\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();\n          }\n        });\n      },\n      ExportNamedDeclaration(path) {\n        var _path$splitExportDecl;\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        const hasRest = declaration.get(\"declarations\").some(path => hasObjectRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n        (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n        path.splitExportDeclaration();\n      },\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasObjectRestElement(leftPath)) {\n          const nodes = [];\n          const refName = path.scope.generateUidBasedOnNode(path.node.right, \"ref\");\n          nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.identifier(refName), path.node.right)]));\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(core.types.variableDeclaration(\"var\", impureComputedPropertyDeclarators));\n          }\n          const nodeWithoutSpread = core.types.cloneNode(path.node);\n          nodeWithoutSpread.right = core.types.identifier(refName);\n          nodes.push(core.types.expressionStatement(nodeWithoutSpread));\n          nodes.push(core.types.expressionStatement(core.types.assignmentExpression(\"=\", argument, callExpression)));\n          nodes.push(core.types.expressionStatement(core.types.identifier(refName)));\n          path.replaceWithMultiple(nodes);\n        }\n      },\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const leftPath = path.get(\"left\");\n        if (!leftPath.isVariableDeclaration()) {\n          if (!hasObjectRestElement(leftPath)) {\n            return;\n          }\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", leftPath.node, core.types.cloneNode(temp))));\n          pluginTransformDestructuring.unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        } else {\n          const patternPath = leftPath.get(\"declarations\")[0].get(\"id\");\n          if (!hasObjectRestElement(patternPath)) {\n            return;\n          }\n          const left = leftPath.node;\n          const pattern = patternPath.node;\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n          path.ensureBlock();\n          pluginTransformDestructuring.unshiftForXStatementBody(path, [core.types.variableDeclaration(node.left.kind, [core.types.variableDeclarator(pattern, core.types.cloneNode(key))])]);\n          scope.crawl();\n          return;\n        }\n      },\n      ArrayPattern(path) {\n        const objectPatterns = [];\n        const {\n          scope\n        } = path;\n        const uidIdentifiers = [];\n        visitObjectRestElements(path, path => {\n          const objectPattern = path.parentPath;\n          const uid = scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push({\n            left: objectPattern.node,\n            right: uid\n          });\n          uidIdentifiers.push(uid);\n          objectPattern.replaceWith(core.types.cloneNode(uid));\n          path.skip();\n        });\n        if (objectPatterns.length > 0) {\n          const patternParentPath = path.findParent(path => !(path.isPattern() || path.isObjectProperty()));\n          const patternParent = patternParentPath.node;\n          switch (patternParent.type) {\n            case \"VariableDeclarator\":\n              patternParentPath.insertAfter(objectPatterns.map(({\n                left,\n                right\n              }) => core.types.variableDeclarator(left, right)));\n              break;\n            case \"AssignmentExpression\":\n              {\n                for (const uidIdentifier of uidIdentifiers) {\n                  scope.push({\n                    id: core.types.cloneNode(uidIdentifier)\n                  });\n                }\n                patternParentPath.insertAfter(objectPatterns.map(({\n                  left,\n                  right\n                }) => core.types.assignmentExpression(\"=\", left, right)));\n              }\n              break;\n            default:\n              throw new Error(`Unexpected pattern parent type: ${patternParent.type}`);\n          }\n        }\n      },\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n        let helper;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch (_unused) {\n            this.file.declarations.objectSpread2 = null;\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n        let exp = null;\n        let props = [];\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = core.types.objectExpression(props);\n          props = [];\n          if (!exp) {\n            exp = core.types.callExpression(helper, [obj]);\n            return;\n          }\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n          exp = core.types.callExpression(core.types.cloneNode(helper), [exp, ...(hadProps ? [core.types.objectExpression([]), obj] : [])]);\n        }\n        for (const prop of path.node.properties) {\n          if (core.types.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n        if (props.length) make();\n        path.replaceWith(exp);\n      }\n    }\n  };\n});\n\nexports.default = index;\n//# sourceMappingURL=index.js.map\n"]}