{"version":3,"sources":["remapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    factory(module, require('@jridgewell/gen-mapping'), require('@jridgewell/trace-mapping'));\n    module.exports = def(module);\n  } else if (typeof define === 'function' && define.amd) {\n    define(['module', '@jridgewell/gen-mapping', '@jridgewell/trace-mapping'], function(mod) {\n      factory.apply(this, arguments);\n      mod.exports = def(mod);\n    });\n  } else {\n    const mod = { exports: {} };\n    factory(mod, global.genMapping, global.traceMapping);\n    global = typeof globalThis !== 'undefined' ? globalThis : global || self;\n    global.remapping = def(mod);\n  }\n  function def(m) { return 'default' in m.exports ? m.exports.default : m.exports; }\n})(this, (function (module, require_genMapping, require_traceMapping) {\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// umd:@jridgewell/trace-mapping\nvar require_trace_mapping = __commonJS({\n  \"umd:@jridgewell/trace-mapping\"(exports, module2) {\n    module2.exports = require_traceMapping;\n  }\n});\n\n// umd:@jridgewell/gen-mapping\nvar require_gen_mapping = __commonJS({\n  \"umd:@jridgewell/gen-mapping\"(exports, module2) {\n    module2.exports = require_genMapping;\n  }\n});\n\n// src/remapping.ts\nvar remapping_exports = {};\n__export(remapping_exports, {\n  default: () => remapping\n});\nmodule.exports = __toCommonJS(remapping_exports);\n\n// src/build-source-map-tree.ts\nvar import_trace_mapping2 = __toESM(require_trace_mapping());\n\n// src/source-map-tree.ts\nvar import_gen_mapping = __toESM(require_gen_mapping());\nvar import_trace_mapping = __toESM(require_trace_mapping());\nvar SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject(\"\", -1, -1, \"\", null, false);\nvar EMPTY_SOURCES = [];\nfunction SegmentObject(source, line, column, name, content, ignore) {\n  return { source, line, column, name, content, ignore };\n}\nfunction Source(map, sources, source, content, ignore) {\n  return {\n    map,\n    sources,\n    source,\n    content,\n    ignore\n  };\n}\nfunction MapSource(map, sources) {\n  return Source(map, sources, \"\", null, false);\n}\nfunction OriginalSource(source, content, ignore) {\n  return Source(null, EMPTY_SOURCES, source, content, ignore);\n}\nfunction traceMappings(tree) {\n  const gen = new import_gen_mapping.GenMapping({ file: tree.map.file });\n  const { sources: rootSources, map } = tree;\n  const rootNames = map.names;\n  const rootMappings = (0, import_trace_mapping.decodedMappings)(map);\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced = SOURCELESS_MAPPING;\n      if (segment.length !== 1) {\n        const source2 = rootSources[segment[1]];\n        traced = originalPositionFor(\n          source2,\n          segment[2],\n          segment[3],\n          segment.length === 5 ? rootNames[segment[4]] : \"\"\n        );\n        if (traced == null) continue;\n      }\n      const { column, line, name, content, source, ignore } = traced;\n      (0, import_gen_mapping.maybeAddSegment)(gen, i, genCol, source, line, column, name);\n      if (source && content != null) (0, import_gen_mapping.setSourceContent)(gen, source, content);\n      if (ignore) (0, import_gen_mapping.setIgnore)(gen, source, true);\n    }\n  }\n  return gen;\n}\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return SegmentObject(source.source, line, column, name, source.content, source.ignore);\n  }\n  const segment = (0, import_trace_mapping.traceSegment)(source.map, line, column);\n  if (segment == null) return null;\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(\n    source.sources[segment[1]],\n    segment[2],\n    segment[3],\n    segment.length === 5 ? source.map.names[segment[4]] : name\n  );\n}\n\n// src/build-source-map-tree.ts\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map((m) => new import_trace_mapping2.TraceMap(m, \"\"));\n  const map = maps.pop();\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(\n        `Transformation map ${i} must have exactly one source file.\nDid you specify these with the most recent transformation maps first?`\n      );\n    }\n  }\n  let tree = build(map, loader, \"\", 0);\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n  return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n  const { resolvedSources, sourcesContent, ignoreList } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || \"\",\n      content: void 0,\n      ignore: void 0\n    };\n    const sourceMap = loader(ctx.source, ctx);\n    const { source, content, ignore } = ctx;\n    if (sourceMap) return build(new import_trace_mapping2.TraceMap(sourceMap, source), loader, source, depth);\n    const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;\n    const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;\n    return OriginalSource(source, sourceContent, ignored);\n  });\n  return MapSource(map, children);\n}\n\n// src/source-map.ts\nvar import_gen_mapping2 = __toESM(require_gen_mapping());\nvar SourceMap = class {\n  constructor(map, options) {\n    const out = options.decodedMappings ? (0, import_gen_mapping2.toDecodedMap)(map) : (0, import_gen_mapping2.toEncodedMap)(map);\n    this.version = out.version;\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.ignoreList = out.ignoreList;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n};\n\n// src/remapping.ts\nfunction remapping(input, loader, options) {\n  const opts = typeof options === \"object\" ? options : { excludeContent: !!options, decodedMappings: false };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n}));\n//# sourceMappingURL=remapping.umd.js.map\n"]}